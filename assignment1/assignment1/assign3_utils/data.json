[{"url": "https://en.wikibooks.org/wiki/Java_Programming/About_This_Book", "content": "The Java Programming Wikibook is a shared effort in amassing a comprehensive guide of the complete Java platform  from programming advice and tutorials for the desktop computer to programming on mobile phones. The information presented in this book has been conceptualised with the combined efforts of various contributors, and anonymous editors.The primary purpose of this book is to teach the Java programming language to an audience of beginners, but its progressive layout of tutorials increasing in complexity, it can be just as helpful for intermediate and experienced programmers. Thus, this book is meant to be used as:a collection of tutorials building upon one another in a progressive manner;\na guidebook for efficient programming with the Java programming language; and,\na comprehensive manual resource for the advanced programmer.This book is intended to be used in conjunction with various other online resources, such as:the Java platform API documentation;\nthe official Java website; and,\nactive Java communities online, such as Java.net and JavaRanch, etc.", "subdata": [{"content": "Everything you would need to know to write computer programs would be explained in this book. By the time you finish reading, you will find yourself proficient enough to tackle just about anything in Java and programs written using it. This book serves as the first few stepping stones of many you would need to cross the unfriendly waters of computer programming. We have put a lot of emphasis in structuring this book in a way that lets you start programming from scratch, with Java as your preferred language of choice. This book is designed for you if any one of the following is true.You are relatively new to programming and have heard how easy it is to learn Java.\nYou had some BASIC or Pascal in school, and have a grasp of basic programming and logic.\nYou already know and have been introduced to programming in earlier versions of Java.\nYou are an experienced developer and know how to program in other languages like C++, Visual Basic, Python, Ruby, etc.\nYou've heard that Java is great for web applications and web services programming.Although this book is generally meant to be for readers who are beginning to learn programming, it can be highly beneficial for intermediate and advanced programmers who may have missed out on some vital information. After completing this book you should be able to solve many complicated problems using the Java skills presented in the following chapters. Once you finish, you are also encouraged to undertake ambitious programming projects of your own.This book assumes that the reader has no prior knowledge of programming in Java, or for that matter, any object-oriented programming language. Practical examples and exercises following each topic and module make it easy to understand the software development methodology. If you are a complete beginner, we suggest that you move slowly through this book and complete each exercise at your own pace.", "title": "Who should read this book?[edit]"}, {"content": "This book is a reference book of the Java language and its related technologies. Its goal is to give a complete picture of Java and its technologies. While the book can be read from the beginning to end, it is also designed to have individual sections that can be read independently. To help find information quickly, navigation boxes are given in the online version for access to individual topics.This book is divided to sections. Pages are grouped together into section topics. To make this book expandable in the future via the addition of new sections, the sections navigation-wide are independent from each other. Each section can be considered as a mini book by itself. Pages that belong to the same topic can be navigated by the links on the right hand side.", "title": "How to use this book[edit]"}], "title": "About This Book"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/History", "content": "On 23 May 1995, John Gage, the director of the Science Office of the Sun Microsystems along with Marc Andreesen, co-founder and executive vice president at Netscape announced to an audience of SunWorldTM that Java technology wasn't a myth and that it was going to be incorporated into Netscape Navigator.[1]At the time the total number of people working on Java was less than 30.[1] This team would shape the future in the next decade and no one had any idea as to what was in store. From running an unmanned vehicle on Mars to serving as the operating environment of most consumer electronics, e.g. cable set-top boxes, VCRs, toasters and PDAs,[2] Java has come a long way from its inception. Let's see how it all began.", "subdata": [{"content": "Before Java emerged as a programming language, C++ was the dominant player in the trade. The primary goal of the creators of Java was to create a language that could tackle most of the things that C++ offered while getting rid of some of the more tedious tasks that came with the earlier languages.Computer hardware went through a performance and price revolution from 1972 to 1991. Better, faster hardware was available at ever lower prices, and the demand for big and complex software exponentially increased. To accommodate the demand, new development technologies were invented.The C language developed in 1972 by Dennis Ritchie had taken a decade to become the most popular language amongst programmers working on PCs and similar platforms (other languages, like COBOL and FORTRAN, dominated the mainframe market). But, with time programmers found that programming in C became tedious with its structural syntax.[3] Although people attempted to solve this problem, it would be later that a new development philosophy was introduced, one named Object-Oriented Programming (OOP). With OOP, one can write code that can be reused later without needing to rewrite the code over and over again. In 1979, Bjarne Stroustrup developed C++, an enhancement to the C language with included OOP fundamentals and features. Sun generated revenue from Java through the selling of licenses for specialized products such as the Java Enterprise System.", "title": "Earlier programming languages[edit]"}, {"content": "James Gosling, architect and designer of the compiler for the Java technologyIn December of 1990, a project was initiated behind closed doors with the aim to create a programming tool that could render obsolete the C and C++ programming languages. Engineer Patrick Naughton had become extremely frustrated with the state of Sun's C++ and C APIs (Application Programming Interfaces) and tools. While he was considering to move towards NeXT, he was offered a chance to work on new technology and the Stealth Project was started, a secret nobody but he knew.This Stealth Project was later named the Green Project when James Gosling and Mike Sheridan joined Patrick.[1] As the Green Project teethed, the prospects of the project started becoming clearer to the engineers working on it. No longer did it aim to create a new language far superior to the present ones, but it aimed to target devices other than the computer.Staffed at 13 people, they began work in a small office on Sand Hill Road in Menlo Park, California. This team came to be called the Green Team henceforth in time. The project they underwent was chartered by Sun Microsystems to anticipate and plan for the \"next wave\" in computing. For the team, this meant at least one significant trend, that of the convergence of digitally controlled consumer devices and computers.[1]", "title": "The Green team[edit]"}, {"content": "The team started thinking of replacing C++ with a better version, a faster version, a responsive version. But the one thing they hadn't thought of, as of yet, was that the language they were aiming for had to be developed for an embedded system with limited resources. An embedded system is a computer system scaled to a minimalistic interface demanding only a few functions from its design. For such a system, C++ or any successor would seem too large as all the languages at the time demanded a larger footprint than what was desired. The team thus had to think in a different way to go about solving all these problems.Co-founder of Sun Microsystems, Bill Joy, envisioned a language combining the power of Mesa and C in a paper named Further he wrote for the engineers at Sun. Gathering ideas, Gosling began work on enhancing C++ and named it \"C++ ++ --\", a pun on the evolutionary structure of the language's name. The ++ and -- meant, putting in and taking out stuff. He soon abandoned the name and called it Oak[1] after the tree that stood outside his office.Table 1: Who's who of the Java technology[1]\nHas worked for GT (Green Team), FP (FirstPerson) and JP (Java Products Group)\n\nName\nGT\nFP\nJP\nDetails\n\n\nLisa Friendly\n\nYes\nYes\nFirstPerson employee and member of the Java Products Group\n\n\nJohn Gage\n\n\n\nScience Office (Director), Sun Microsystems\n\n\nJames Gosling\nYes\nYes\nYes\nLead engineer and key architect of the Java technology\n\n\nBill Joy\n\n\n\nCo-founder and VP, Sun Microsystems; Principal designer of the UC Berkeley, version of the UNIX OS\n\n\nJonni Kanerva\n\nYes\n\nJava Products Group employee, author of The Java FAQ1\n\n\nTim Lindholm\n\nYes\nYes\nFirstPerson employee and member Java Products Group\n\n\nScott McNealy\n\n\n\nChairman, President, and CEO of Sun Microsystems\n\n\nPatrick Naughton\nYes\nYes\n\nGreen Team member, FirstPerson co-founder\n\n\nGeorge Paolini\n\n\n\nCorporate Marketing (Director), Sun's Java Software Division\n\n\nKim Polese\n\nYes\n\nFirstPerson product marketing\n\n\nLisa Poulson\n\n\n\nOriginal director of public relations for Java technology (Burson-Marsteller)\n\n\nWayne Rosing\n\nYes\n\nFirstPerson President\n\n\nEric Schmidt\n\n\n\nFormer Sun Microsystems Chief Technology Officer\n\n\nMike Sheridan\nYes\n\n\nGreen Team member", "title": "Reshaping thought[edit]"}, {"content": "By now, the work on Oak had been significant but come the year 1993, people saw the demise of set-top boxes, interactive TV and the PDAs. A failure that completely ushered the inventors' thoughts to be reinvented. Only a miracle could make the project a success now. And such a miracle awaited anticipation.National Center for Supercomputing Applications (NCSA) had just unveiled its new commercial web browser for the internet the previous year. The focus of the team, now diverted towards where they thought the \"next-wave\" of computing would be  the internet. The team then divulged into the realms of creating the same embeddable technology to be used in the web browser space calling it an applet  a small application. Keeping all of this in mind, the team created a list of features tackling the C++ problems. In their opinion, the project should.....be simple and gather tested fundamentals and features from the earlier languages in it,\n..have standard sets of APIs with basic and advanced features bundled with the language,\n..get rid of concepts requiring direct manipulation of hardware (in this case, memory) to make the language safe,\n..be platform independent and may written for every platform once (giving birth to the WORA idiom),\n..be able to manipulate network programming out-of-the-box,\n..be embeddable in web browsers, and...\n..have the ability for a single program to multi-task and do multiple things at the same time.The team now needed a proper identity and they decided on naming the new technology they created Java ushering a new generation of products for the internet boom. A by-product of the project was a cartoon named \"Duke\" created by Joe Parlang which became its identity then.Finally at the SunWorldTM conference, Andreesen unveiled the new technology to the masses. Riding along with the explosion of interest and publicity in the Internet, Java quickly received widespread recognition and expectations grew for it to become the dominant software for browser and consumer applications.[2]Initially Java was owned by Sun Microsystems, but later it was released to open source; the term Java was a trademark of Sun Microsystems. Sun released the source code for its HotSpot Virtual Machine and compiler in November 2006, and most of the source code of the class library in May 2007. Some parts were missing because they were owned by third parties, not by Sun Microsystems. The released parts were published under the terms of the GNU General Public License, a free software license.", "title": "The demise of an idea, birth of another[edit]"}, {"content": "Unlike C and C++, Java's growth is pretty recent. Here, we'd quickly go through the development paths that Java took with age.Development of Java over the years. From version 1.0 to version 1.7, Java has displayed a steady growth.Initial Release (versions 1.0 and 1.1)[edit]Introduced in 1996 for the Solaris, Windows, Mac OS Classic and Linux, Java was initially released as the Java Development Kit 1.0 (JDK 1.0). This included the Java runtime (the virtual machine and the class libraries), and the development tools (e.g., the Java compiler). Later, Sun also provided a runtime-only package, called the Java Runtime Environment (JRE). The first name stuck, however, so usually people refer to a particular version of Java by its JDK version (e.g., JDK 1.0).Java 2 (version 1.2)[edit]Introduced in 1998 as a quick fix to the former versions, version 1.2 was the start of a new beginning for Java. The JDKs of version 1.2 and later versions are often called Java 2 as well. For example, the official name of JDK 1.4 is The Java(TM) 2 Platform, Standard Edition version 1.4.Major changes include:\n\nRewrite the event handling (add Event Listeners)\nChange Thread synchronizations\nIntroduction of the JIT-Just in time compilersKestrel (Java 1.3)[edit]Released in 8 May 2000. The most notable changes were:HotSpot JVM included (the HotSpot JVM was first released in April, 1999 for the J2SE 1.2 JVM)\nRMI was modified to support optional compatibility with CORBA\nJavaSound\nJava Naming and Directory Interface (JNDI) included in core libraries (previously available as an extension)\nJava Platform Debugger Architecture (JPDA)\nSynthetic proxy classesMerlin (Java 1.4)[edit]Released in 6 February 2002, Java 1.4 has improved programmer productivity by expanding language features and available APIs:Assertion\nRegular Expression\nXML processing\nCryptography and Secure Socket Layer (SSL)\nNon-blocking I/O (NIO)\nLoggingTiger (version 1.5.0; Java SE 5)[edit]Released in September 2004Major changes include:\n\nGenerics - Provides compile-time type safety for collections:and eliminates the drudgery of casting.\nAutoboxing/unboxing - Eliminates the drudgery of manual conversion between primitive types (such as int) and wrapper types (such as Integer).\nEnhanced for - Shorten the for loop with Collections use.\nStatic imports - Lets you import all the static part of a class.\nAnnotation/Metadata - Enabling tools to generate code and deployment descriptors from annotations in the source code. This leads to a \"declarative\" programming style where the programmer says what should be done and tools emit the code to do it. Annotations can be inspected through source parsing or by using the additional reflection APIs added in Java 5.\nJVM Improvements - Most of the run time library is now mapped into memory as a memory image, as opposed to being loaded from a series of class files. Large portion of the runtime libraries will now be shared among multiple JVM instances.Mustang (version 1.6.0; Java SE 6)[edit]Released on 11 December 2006.What's New in Java SE 6:Web Services - First-class support for writing XML web service client applications.Scripting - You can now mix in JavaScript technology source code, useful for prototyping. Also useful when you have teams with a variety of skill sets. More advanced developers can plug in their own scripting engines and mix their favorite scripting language in with Java code as they see fit.Database - No more need to find and configure your own JDBC database when developing a database application. Developers will also get the updated JDBC 4.0, a well-used API with many important improvements, such as special support for XML as an SQL datatype and better integration of Binary Large OBjects (BLOBs) and Character Large OBjects (CLOBs) into the APIs.More Desktop APIs - GUI developers get a large number of new tricks to play like the ever popular yet newly incorporated SwingWorker utility to help you with threading in GUI apps, JTable sorting and filtering, and a new facility for quick splash screens to quiet impatient users.Monitoring and Management - The really big deal here is that you don't need to do anything special to the startup to be able to attach on demand with any of the monitoring and management tools in the Java SE platform.Compiler Access - Really aimed at people who create tools for Java development and for frameworks like JavaServer Pages (JSP) or Personal Home Page construction kit (PHP) engines that need to generate a bunch of classes on demand, the compiler API opens up programmatic access to javac for in-process compilation of dynamically generated Java code. The compiler API is not directly intended for the everyday developer, but for those of you deafened by your screaming inner geek, roll up your sleeves and give it a try. And the rest of us will happily benefit from the tools and the improved Java frameworks that use this.Pluggable Annotations allows programmer to write annotation processor so that it can analyse your code semantically before javac compiles. For example, you could write an annotation processor that verifies whether your program obeys naming conventions.Desktop Deployment - At long last, Java SE 6 unifies the Java Plug-in technology and Java WebStart engines, which just makes sense. Installation of the Java WebStart application got a much needed makeover.Security - Java SE 6 has simplified the job of its security administrators by providing various new ways to access platform-native security services, such as native Public Key Infrastructure (PKI) and cryptographic services on Microsoft Windows for secure authentication and communication, Java Generic Security Services (Java GSS) and Kerberos services for authentication, and access to LDAP servers for authenticating users.The -lities: Quality, Compatibility, Stability - Bug fixes ...Dolphin (version 1.7.0; Java SE 7)[edit]Released on 28 July 2011.Feature additions for Java 7 include:JVM support for dynamic languages, following the prototyping work currently done on the Multi Language Virtual Machine\nCompressed 64-bit pointers Available in Java 6 with -XX:+UseCompressedOops\nSmall language changes (grouped under a project named Coin):Strings in switch\nAutomatic resource management in try-statement\nImproved type inference for generic instance creation\nSimplified varargs method declaration\nBinary integer literals\nAllowing underscores in numeric literals\nCatching multiple exception types and rethrowing exceptions with improved type checkingConcurrency utilities under JSR 166\nNew file I/O library to enhance platform independence and add support for metadata and symbolic links. The new packages are java.nio.file and java.nio.file.attribute\nLibrary-level support for Elliptic curve cryptography algorithms\nAn XRender pipeline for Java 2D, which improves handling of features specific to modern GPUs\nNew platform APIs for the graphics features originally planned for release in Java version 6u10\nEnhanced library-level support for new network protocols, including SCTP and Sockets Direct Protocol\nUpstream updates to XML and UnicodeLambda (Java's implementation of lambda functions), Jigsaw (Java's implementation of modules), and part of Coin were dropped from Java 7.Spider (version 1.8.0; Java SE 8)[edit]Java 8 was released on 18 March 2014, and included some features that were planned for Java 7 but later deferred.Work on features was organized in terms of JDK Enhancement Proposals (JEPs).JSR 335, JEP 126: Language-level support for lambda expressions (officially, lambda expressions; unofficially, closures) under Project Lambda which allow the addition of methods to interfaces without breaking existing implementations. There was an ongoing debate in the Java community on whether to add support for lambda expressions. Supporting lambda expressions also allows the performance of functional-style operations on streams of elements, such as MapReduce-inspired transformations on collections. Default methods allow an author of an API to add new methods to an interface without breaking the old code using it. Although it was not their primary intent, default methods also allow multiple inheritance of behavior (but not state).JSR 223, JEP 174: Project Nashorn, a JavaScript runtime which allows developers to embed JavaScript code within applications\nJSR 308, JEP 104: Annotation on Java Types\nUnsigned Integer Arithmetic\nJSR 337, JEP 120: Repeating annotations\nJSR 310, JEP 150: Date and Time API\nJEP 178: Statically-linked JNI libraries\nJEP 153: Launch JavaFX applications (direct launching of JavaFX application JARs)\nJEP 122: Remove the permanent generation", "title": "Versions[edit]"}], "title": "History"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Java_Overview", "content": "The new features and upgrades included into Java changed the face of programming environment and gave a new definition to Object Oriented Programming (OOP in short). But unlike its predecessors, Java needed to be bundled with standard functionality and be independent of the host platform.The primary goals in the creation of the Java language:It is simple.\nIt is object-oriented.\nIt is independent of the host platform.\nIt contains language facilities and libraries for networking.\nIt is designed to execute code from remote sources securely.The Java language introduces some new features that did not exist in other languages like C and C++.", "subdata": [{"content": "Object oriented programming can be represented with UML diagrams.Object orientation (\"OO\") refers to a method of programming and language technique. The main idea of OO is to design software around the \"things\" (i.e. objects) it manipulates, rather than the actions it performs.As the hardware of the computer advanced, it brought about the need to create better software techniques to be able to create ever increasing complex applications. The intent is to make large software projects easier to manage, thus improving quality and reducing the number of failed projects. Object oriented solution is the latest software technique.Assembly languages\nSoftware techniques started with the assembly languages, that were close to machine instruction and were easy to convert into executable code. Each hardware had its own assembly language. Assembly language contains low level instructions like move data from memory to hardware registers, do arithmetic operations, and move data back to memory. Programmers had to know the detailed architecture of the computer in order to write programs.Procedural languages\nAfter the assembly languages, high level languages were developed. Here the language compiler is used to convert the high level program to machine instructions, freeing the programmers from the burden of knowing the computer hardware architecture. To promote the re-use of code and to minimize the use of GOTO instructions, \"procedural\" techniques were introduced. This simplified the creation and maintenance of software control flow, but left out the organization of data. It became a nightmare to debug and maintain programs having many global variables (i.e. variables that contain data that can be modified anywhere in the application).Object oriented languages\nIn OO languages, data is taken seriously with information hiding. Data that is specific to an object can only be accessed by procedures in that object. As a result, objects contain data as well as control flow and a program becomes a series of interactions between objects.", "title": "Object orientation[edit]"}, {"content": "In C or C++ programming, you start to write a source code:... you compile it to a machine code file:... and then you execute it:In this situation, the machine code file and its execution are specific to the platform (Windows, Linux, Mac OS, ...) it was compiled for, that is to say to the targeted platform:... because the compiled file is a machine code file designed to work on a specific platform and hardware. It would have produced a different results/output for another platform. So if you want your program to run on several platforms, you have to compile your program several times:It poses greater vulnerability risks. Note here that when a certain code is compiled into an executable format, the executable cannot be changed dynamically. It would need to be recompiled from the changed code for the changes to be reflected in the finished executable. Modularity (dividing code into modules) is not present in Java's predecessors. If instead of a single executable, the output application was in the form of modules, one could easily change a single module and review changes in the application. In C/C++ on the other hand, a slight change in code required the whole application to be recompiled.The idea of Java is to compile the source code into an intermediate language that will be interpreted.The source code\nThe intermediate file\nThe interpretorThe intermediate language is the byte code. The interpretor is the Java Virtual Machine (JVM). The byte code file is universal and the JVM is platform specific:So a JVM should be coded for each platform. And that's the case. So you just have to generate a unique byte code file (a .class file).The first implementations of the language used an interpreted virtual machine to achieve portability, and many implementations still do. These implementations produce programs that run more slowly than the fully-compiled programs created by the typical C++ compiler, so the language suffered a reputation for producing slow programs. Since Java 1.2, Java VM produces programs that run much faster, using multiple techniques.The first of these is to simply compile directly into native code like a more traditional compiler, skipping bytecode entirely. This achieves great performance, but at the expense of portability. This is not really used any more.Another technique, the just-in-time (JIT) compiler, compiles the Java bytecode into native code at the time the program is run, and keep the compiled code to be used again and again. More sophisticated VMs even use dynamic recompilation, in which the VM can analyze the behavior of the running program and selectively recompile and optimize critical parts of the program. Both of these techniques allow the program to take advantage of the speed of native code without losing portability.Portability is a technically difficult goal to achieve, and Java's success at that goal is a matter of some controversy. Although it is indeed possible to write programs for the Java platform that behave consistently across many host platforms, the large number of available platforms with small errors or inconsistencies led some to parody Sun's \"Write once, run anywhere\" slogan as \"Write once, debug everywhere\".", "title": "Platform dependence[edit]"}, {"content": "C++ was built atop the C language and as a result divergent ways of doing the same thing manifested around the language. For instance, creating an object could be done in three different ways in C++. Furthermore, C++ did not come with a standard library bundled with its compilers. Instead, it relied on resources created by other programmers; code which rarely fit together.In Java, standardized libraries are provided to allow access to features of the host machines (such as graphics and networking) in unified ways. The Java language also includes support for multi-threaded programsa necessity for many networking applications.Platform independent Java is, however, very successful with server side applications, such as web services, servlets, or Enterprise JavaBeans.Swing does not rely on the underlying native user interface.Java also made progress on the client side, first it had Abstract Window Toolkit (AWT), then Swing, and the most recent client side library is the Standard Widget Toolkit (SWT). It is interesting to see how they tried to handle the two opposing consuming forces. Those are:Efficient, fast code; port to most popular hardware (write once, test anywhere)\nUse the underlying native subroutine to create a GUI component. This approach was taken by AWT, and SWT.Portability to any hardware where JVM ported (write once, run anywhere)\nTo achieve this to the latter, the Java toolkit should not rely on the underlying native user interface. Swing took this approach.It is interesting to see how the approach was switched back and forth. AWT  Swing  SWT.", "title": "Standardization[edit]"}, {"content": "The segmentation fault, one of the most recurrent issues in C programming.With the high-level of control built into the language to manipulate hardware, a C/C++ programmer could access almost any resource, either hardware or software on the system. This was intended to be one of the languages' strong points, but this very flexibility led to confusion and complex programming practices.", "title": "Secure execution[edit]"}, {"content": "The old way of error handling was to let each function return an error code then let the caller check what was returned. The problem with this method was that if the return code was full of error-checking codes, this got in the way of the original one that was doing the actual work, which in turn did not make it very readable.In the new way of error handling, functions/methods do not return error codes. Instead, when there is an error, an exception is thrown. The exceptions can be handled by the catch keyword at the end of a try block. This way, the code that is calling the function does not need to be mangled with error checking codes, thus making the code more readable. This new way of error handling is called Exception handling.Exception handling was also added to C++. However, there are two differences between Java and C++ Exception handling:In Java, the exception that is thrown is a Java object like any other object in Java. It only has to implement Throwable interface.\nIn Java, the compiler checks whether an exception may be caught or not. The compiler gives an error if there is no catch block for a thrown exception.The optional exception handling in the Java predecessors leads the developers not to care about the error handling. As a consequence, unexpected errors often occur. Java forces the developers to handle exceptions. The programmer must handle exception or declare that the user must handle it. Someone must handle it.", "title": "Error handling[edit]"}, {"content": "However powerful, the predecessors of Java lacked a standard feature to network with other computers, and usually relied on the platforms' intricate networking capabilities. With almost all network protocols being standardized, the creators of Java technology wanted this to be a flagship feature of the language while keeping true to the spirit of earlier advances made towards standardizing Remote Procedure Call. Another feature that the Java team focused on was its integration in the World Wide Web and the Internet.The Java platform was one of the first systems to provide wide support for the execution of code from remote sources. The Java language was designed with network computing in mind.An applet could run within a user's browser, executing code downloaded from a remote HTTP server. The remote code runs in a highly restricted \"sandbox\", which protects the user from misbehaving or malicious code; publishers could apply for a certificate that they could use to digitally sign applets as \"safe\", giving them permission to break out of the sandbox and access the local file system and network, presumably under user control.", "title": "Networking capabilities[edit]"}, {"content": "In conventional languages like C and C++, all code had to be compiled and linked to one executable program, before execution. In Java, classes are compiled as needed. If a class is not needed during an execution phase, that class is not even compiled into byte code.This feature comes in handy especially in network programming when we do not know, beforehand, what code will be executed. A running program could load classes from the file system or from a remote server.Also this feature makes it theoretically possible for a Java program to alter its own code during execution, in order to do some self-learning behavior. It would be more realistic to imagine, however, that a Java program would generate Java code before execution, and then, that code would be executed. With some feedback mechanism, the generated code could improve over time.", "title": "Dynamic class loading[edit]"}, {"content": "In conventional languages like C and C++, the programmer has to make sure that all memory that was allocated is freed. Memory leaks became a regular nuisance in instances where the programmers had to manually allocate the system's memory resources.Memory resources or buffers have specific modes of operation for optimal performance. Once a buffer is filled with data, it needs to be cleaned up after there is no further use for its content. If a programmer forgets to clean it in his/her code, the memory is easily overloaded. Programming in C/C++ languages became tedious and unsafe because of these very quirks, and programs built in these languages were prone to memory leakages and sudden system crashes  sometimes even harming the hardware itself. Freeing memory is particularly important in servers, since it has to run without stopping for days. If a piece of memory is not freed after use and the server just keeps allocating memory, that memory leak can take down the server.In Java, freeing up memory is taken out of the programmers hands; the Java Virtual Machine keeps track of all used memory. When memory is not used any more it is automatically freed up. A separate task is running in the background by the JVM, freeing up unreferenced, unused memory. That task is called the Garbage Collector.The Garbage Collector is always running. This automatic memory garbage collection feature makes it easy to write robust server side programs in Java. The only thing the programmer has to watch for is the speed of object creation. If the application is creating objects faster than the Garbage Collector can free them, it can cause memory problems. Depending on how the JVM is configured, the application either can run out of memory by throwing the NotEnoughMemoryException, or can halt to give time for the Garbage Collector to do its job.", "title": "Automatic memory garbage collection[edit]"}, {"content": "The Java creators created the concept of the applet. A Java program can be run in a client browser program. Java was released in 1995; the time when the Internet was becoming more available and familiar to the general public. The promise of Java was in the client browser-side in that code would be downloaded and executed as a Java applet in the client browser program.See also Java Programming/Applets.", "title": "Applet[edit]"}, {"content": "Over the years, some features in C/C++ programming became abused by the programmers. Although the language allows it, it was known as bad practices. So the creators of Java have disabled them:Operator overloading\nMultiple inheritance\nFriend classes (access another object's private members)\nRestrictions of explicit type casting (related to memory management)", "title": "Forbidden bad practices[edit]"}], "title": "Java Overview"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/The_Java_Platform", "content": "The Java platform is the name given to the computing platform from Oracle that helps users to run and develop Java applications. The platform does not just enable a user to run and develop a Java application, but also features a wide variety of tools that can help developers work efficiently with the Java programming language.The platform consists of two essential softwares:the Java Runtime Environment (JRE), which is needed to run Java applications and applets; and,\nthe Java Development Kit (JDK), which is needed to develop those Java applications and applets. If you have installed the JDK, you should know that it comes equipped with a JRE as well. So, for all the purposes of this book, you would only require the JDK.In this section, we will explore in further detail what these two software components of the Java platform do.", "subdata": [{"content": "Any piece of code written in the Java programming language can be run on any operating system, platform or architecture  in fact, it can be run on any device that supports the Java platform. Before Java, this amount of ubiquity was very hard to achieve. If a software was written for a Unix-based system, it was impossible to run the same application on a Windows system  in this case, the application was native only to Unix-based systems.A major milestone in the development of the Java programming language was to develop a special runtime environment that would execute any Java application independent of the computer's operating system, platform or architecture.The Java Runtime Environment (JRE) sits on top of the machine's operating system, platform and architecture. If and when a Java application is run, the JRE acts as a liaison between the underlying platform and that application. It interprets the Java application to run in accordance with the underlying platform, such that upon running the application, it looks and behaves like a native application. The part of the JRE that accomplishes this complex liaison agreement is called the Java Virtual Machine (JVM).Figure 1: Java applications can be written once and run anywhere. This feature of the Java platform\nis commonly abbreviated to WORA in formal Java texts.Executing native Java code (or byte-code)[edit]Native Java applications are preserved in a special format called the byte-code. Byte-code remains the same, no matter what hardware architecture, operating system, or software platform it is running under. On a file-system, Java byte-code resides in files that have the .class (also known as a class file) or the .jar (also known as a Java archive) extension. To run byte-code, the JRE comes with a special tool (appropriately named java).Suppose your byte-code is called SomeApplication.class. If you want to execute this Java byte-code, you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):Execution\n\n$ java SomeApplicationIf you want to execute a Java byte-code with a .jar extension (say, SomeApplication.jar), you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):Execution with a jar\n\n$ java -jar SomeApplication.jarNot all Java class files or Java archives are executable. Therefore, the java tool would only be able to execute files that are executable. Non-executable class files and Java archives are simply called class libraries.Do you have a JRE?[edit]Most computers come with a pre-installed copy of the JRE. If your computer doesn't have a JRE, then the above commands would not work. You can always check what version of the JRE is installed on the computer by writing the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):Java version\n\n$ java -versionJava Virtual Machine (JVM)[edit]Quite possibly, the most important part of the JRE is the Java Virtual Machine (JVM). The JVM acts like a virtual processor, enabling Java applications to be run on the local system. Its main purpose is to interpret (read translate) the received byte-code and make it appear as native code. The older Java architecture used this process of interpretation to execute Java byte-code. Even though the process of interpretation brought the WORA principle to diverse machines, it had a drawback  it consumed a lot of time and clocked the system processor intensively to load an application.Figure 2: A JVM interpreter translates the byte-code line-by-line to make it appear as if a native application is being executed.Just-in-Time Compilation[edit]Since version 1.2, the JRE features a more robust JVM. Instead of interpreting byte-code, it down-right converts the code straight into equivalent native code for the local system. This process of conversion is called just-in-time compilation or JIT-compilation. This process only occurs when the byte-code is executed for the first time. Unless the byte-code itself is changed, the JVM uses the compiled version of the byte-code on every successive execution. Doing so saves a lot of time and processor effort, allowing applications to execute much faster at the cost of a small delay on first execution.Figure 3: A just-in-time compiler only compiles the byte-code to equivalent native code at first execution. Upon every successive\nexecution, the JVM merely uses the already compiled native code to optimize performance.Native optimization[edit]The JVM is an intelligent virtual processor. It has the ability to identify areas within the Java code itself that can be optimized for faster and better performance. Based on every successive run of your Java applications, the JVM would optimize it to run even better.There are portions of Java code that do not require it to be JIT-compiled at runtime, e.g., the Reflection API; therefore, code that uses such functions are not necessarily fully compiled to native code.Was JVM the first virtual machine?[edit]Java was not the first virtual-machine-based platform, though it is by far the most successful and well-known. Previous uses for virtual machine technology primarily involved emulators to aid development for not-yet-developed hardware or operating systems, but the JVM was designed to be implemented entirely in software, while making it easy to efficiently port an implementation to hardware of all kinds.", "title": "Java Runtime Environment (JRE)[edit]"}, {"content": "The JRE takes care of running the Java code on multiple platforms, however as developers, we are interested in writing pure code in Java which can then be converted into Java byte-code for mass deployment. As developers, we do not need to write Java byte-code; rather we write the code in the Java programming language (which is quite similar to writing C or C++ code).Upon downloading the JDK, a developer ensures that their system has the appropriate JRE and additional tools to help with the development of applications in the Java programming language. Java code can be found in files with the extension .java. These files are called Java source files. In order to convert the Java code in these source files to Java byte-code, you need to use the Java compiler tool installed with your JDK.The Java compiler[edit]The Java compiler tool (named javac in the JDK) is the most important utility found with the JDK. In order to compile a Java source file (say, SomeApplication.java) to its respective Java byte-code, you would need to use the following command in Command Prompt (on Windows) or Terminal (on Linux or Mac OS):Compilation\n\njavac SomeApplication.javaThis command would convert the SomeApplication.java source file into its equivalent Java byte-code. The resultant byte-code would exist in a newly created file named SomeApplication.class. This process of converting Java source files into their equivalent byte-codes is known as compilation.Figure 4: The basic Java compilation processA list of other JDK tools\n\nThere are a huge array of tools available with the JDK that will all be explained in due time as you progress with the book. These tools are briefly listed below in order of their usage:\nApplet development[edit]\n\nappletviewer  Java applets require a particular environment to execute. Typically, this environment is provided by a browser with a Java plug-in, and a web server serving the applet. However, during development and testing of an applet it might be more convenient to start an applet without the need to fiddle with a browser and a web server. In such a case, Oracle's appletviewer from the JDK can be used to run an applet.\n\nAnnotation processing[edit]\n\nFor more about annotation processing, read this\n\nIn Java 1.5 (alias Java 5.0) Oracle added a mechanism called annotations. Annotations allow the addition of meta-data to Java source code, and even provide mechanisms to carry that meta-data into compiled .class files.\n\napt  An annotation processing tool which digs through source code, finds annotation statements in the source code and executes actions if it finds known annotations. The most common task is to generate some particular source code. The actions apt performs when finding annotations in the source code are not hard-coded into apt. Instead, one has to code particular annotation handlers (in Java). These handlers are called annotation processors. It can also be described in a simple way without the Oracle terminology: apt can be seen as a source code preprocessor framework, and annotation processors are typically code generators.\n\nIntegration of non-Java and Java code[edit]\n\njavah  A Java class can call native, or non-Java, code that has been prepared to be called from Java. The details and procedures are specified in the JNI (Java Native Interface). Commonly, native code is written in C (or C++). The JDK tool javah helps to write the necessary C code, by generating C header files and C stub code.\n\nClass library conflicts[edit]\n\nextcheck  It can be used prior to the installation of a Java extension into the JDK or JRE environment. It checks if a particular Jar file conflicts with an already installed extension. This tool appeared first with Java 1.5.\n\nSoftware security and cryptography tools[edit]\nThe JDK comes with a large number of tools related to the security features of Java. Usage of these tools first requires study of the particular security mechanisms. The tools are:\n\nkeytool  To manage keys and certificates\njarsigner  To generate and verify digital signatures of JARs (Java ARchives)\npolicytool  To edit policy files\nkinit  To obtain Kerberos v5 tickets\nklist  To manage Kerberos credential cache and key table\nktab  To manage entries in a key table\n\nThe Java archiver[edit]\n\njar  (short for Java archiver) is a tool for creating Java archives or jar files  a file with .jar as the extension. A Java archive is a collection of compiled Java classes and other resources which those classes may require (such as text files, configuration files, images) at runtime. Internally, a jar file is really a .zip file.\n\nThe Java debugger[edit]\n\njdb  (short for Java debugger) is a command-line console that provides a debugging environment for Java programs. Although you can use this command line console, IDE's normally provide easier to use debugging environments.\n\nDocumenting code with Java[edit]\nAs programs grow large and complex, programmers need ways to track changes and to understand the code better at each step of its evolution. For decades, programmers have been employing the use of special programming constructs called comments  regions that help declare user definitions for a code snippet within the source code. But comments are prone to be verbose and incomprehensible, let alone be difficult to read in applications having hundreds of lines of code.\n\njavadoc  Java provides the user with a way to easily publish documentation about the code using a special commenting system and the javadoc tool. The javadoc tool generates documentation about the Application Programming Interface (API) of a set of user-created Java classes. javadoc reads source file comments from the .java source files and generates HTML documents that are easier to read and understand without looking at the code itself.\n\n\njavap  Where Javadoc provide a detailed view into the API and documentation of a Java class, the javap tool prints information regarding members (constructors, methods and variables) in a class. In other words, it lists the class' API and/or the compiled instructions of the class. javap is a formatting disassembler for Java bytecode.\n\nThe native2ascii tool[edit]\nnative2ascii is an important, though underappreciated, tool for writing properties files  files containing configuration data  or resource bundles  files containing language translations of text.\nSuch files can contain only ASCII and Latin-1 characters, but international programmers need a full range of character sets. Text using these characters can appear in properties files and resource bundles only if the non-ASCII and non-Latin-^1 characters are converted into Unicode escape sequences (\\uXXXX notation).\nThe task of writing such escape sequences is handled by native2ascii. You can write the international text in an editor using the appropriate character encoding, then use native2ascii to generate the necessary ASCII text with embedded Unicode escape sequences. Despite the name, native2ascii can also convert from ASCII to native, so it is useful for converting an existing properties file or resource bundle back to some other encoding.\nnative2ascii makes most sense when integrated into a build system to automate the conversion.\nRemote Method Invocation (RMI) tools[edit]\n\n\n\n\n\n\n\nTo do:\nAdd section\n\n\n\n\nJava IDL and RMI-IIOP Tools[edit]\n\n\n\n\n\n\n\nTo do:\nAdd section\n\n\n\n\nDeployment & Web Start Tools[edit]\n\n\n\n\n\n\n\nTo do:\nAdd section\n\n\n\n\nBrowser Plug-In Tools[edit]\n\n\n\n\n\n\n\nTo do:\nAdd section\n\n\n\n\nMonitoring and Management Tools / Troubleshooting Tools[edit]\nWith Java 1.5 a set of monitoring and management tools have been added to the JDK, in addition to a set of troubleshooting tools.\nThe monitoring and management tools are intended for monitoring and managing the virtual machine and the execution environment. They allow, for example, monitoring memory usage during the execution of a Java program.\nThe troubleshooting tools provide rather esoteric insight into aspects of the virtual machine. (Interestingly, the Java debugger is not categorized as a troubleshooting tool.)\nAll the monitoring and management and troubleshooting tools are currently marked as \"experimental\" (which does not affect jdb). So they might disappear in future JDKs.Java class libraries (JCL)[edit]In most modern operating systems, a large body of reusable code is provided to simplify the programmer's job. This code is typically provided as a set of dynamically loadable libraries that applications can call at runtime. Because the Java platform is not dependent on any specific operating system, applications cannot rely on any of the existing libraries. Instead, the Java platform provides a comprehensive set of standard class libraries, containing much of the same reusable functions commonly found in modern operating systems.The Java class libraries serve three purposes within the Java platform. Like other standard code libraries, they provide the programmer with a well-known set of functions to perform common tasks, such as maintaining lists of items or performing complex string parsing. In addition, the class libraries provide an abstract interface to tasks that would normally depend heavily on the hardware and operating system. Tasks such as network access and file access are often heavily dependent on the native capabilities of the platform. The Java java.net and java.io libraries implement the required native code internally, then provide a standard interface for the Java applications to perform those tasks. Finally, some underlying platforms may not support all of the features a Java application expects. In these cases, the class libraries can either emulate those features using whatever is available, or provide a consistent way to check for the presence of a specific feature.", "title": "Java Development Kit (JDK)[edit]"}], "title": "The Java Platform"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Getting_started", "content": "Navigate Getting Started topic: (vde)\n\n Installing Java on Your Computer\n Compiling programs\n Running Java programs\n Understanding a Java program\n Java IDEs", "subdata": [{"content": "We conceptualize the world around us in terms of systems. A system is a web of interconnected objects working together in tandem. In the systems theory, a system is set out as a single entity within a world surrounded by an environment. A system interacts with its surrounding environment using messages of two distinct types:inputs: messages received from the surrounding environment; and,\noutputs: messages given back to the surrounding environment.Figure 1: A simple system interacting with its environment using input and output messages.Life is a complicated mess of interconnected objects sending signals and messages. See the illustration below in figure 2 demonstrating a complex system for an economic ecosphere for a single company. Imagine what this system diagram would be like if you were to add a few more companies and their sub-systems. Computer software systems in general are a complex web of further interconnected sub-systems  where each sub-systems may or may not be divided into further sub-systems. Each sub-system communicates with others using feedback messages  that is, inputs and outputs.Figure 2: Example of a complex system with multiple sub-systems and interactions", "title": "Understanding systems[edit]"}, {"content": "Programming is essentially thinking of solutions to problems in real life as a system. With any programming language, you need to know how to address real-life problems into something that could be accurately represented within a computer system. In order to begin programming with the Java programming language (or in fact, with any programming language), a programmer must first understand the basics of abstraction.Abstraction is the process of representing real-life problems and objects into your programs.Suppose a novelist, a painter and a programmer were asked to abstract (i.e., represent) a real-life object in their work. Suppose, the real-life object that needs to be abstracted is an animal. Abstraction for a novelist would include writing the description of the animal whilst the painter would draw a picture of the animal  but what about a computer programmer?The Java programming language uses a programming paradigm called object-oriented programming (OOP), which shows you exactly what a programmer needs to be doing. According to OOP, every object or problem in real-life can be translated into a virtual object within your computer system.Thinking in objects[edit]In OOP, every abstraction of a real-life object is simply called an object within your code. An object is essentially the most basic representation of a real-life object as part of a computer system. With Java being an object-oriented language, everything within Java is represented as an object. To demonstrate this effect, if you were to define an abstraction of an animal in your code, you would write the following lines of code (as you would for any other abstraction):class Animal { }The code above creates a space within your code where you can start defining an object; this space is called a class (or type) definition. All objects need to be defined using a class definition in order for them to be used in your program. Notice the curly brackets  anything you write within these brackets would serve as a definition or specification for your object. In the case of the example above, we created a class definition called Animal for objects that could serve as an abstract representation of any animal in real-life. The way that a Java environment evaluates this code to be a class definition is by looking at the prefix word we used to begin our class definition (i.e., class). Such predefined words in the Java language are known as keywords and make up the grammar for the language (known as programming syntax).Understanding class definitions and types[edit]Aristotle was perhaps the first person to think of abstract types or typologies of objects. He started calling them classes  e.g., classes of birds, classes of mammals. Class definitions therefore serve the purpose well in defining the common characteristics or types of objects you would be creating. Upon declaring a class definition, you can create objects based on that definition. In order to do so however, you need to write a special syntax that goes like this:Animal dog = new Animal();The code above effectively creates an object called dog based on the class definition for Animal. In non-programmer parlance, the code above would translate into something akin to saying, \"Create a new object dog of type Animal.\" A single class definition enables you to create multiple objects as the code below indicates:Animal dog = new Animal();\nAnimal cat = new Animal();\nAnimal camel = new Animal();Basically, you just have to write the code for your class or type definition once, and then use it to create countless numbers of objects based on that specification. Although you might not grasp the importance of doing so, this little exercise saves you a lot of time (a luxury that was not readily available to programmers in the pre-Java days).Expanding your class definitions[edit]Although each object you create from a class definition is essentially the same, there has to be a way of differentiating those objects in your code. Object fields (or simply fields) are what makes your objects unique from other objects. Let's take our present abstraction for instance. An animal could be a dog, cat, camel or a duck but since this abstraction is of a very generic kind, you need to define fields that are common to all of these animals and yet makes the animals stand apart. For instance, you can have two fields: name (a common name given to any one of these animals) and legs (the number of limbs any one of these animals would require to walk). As you start defining your objects, they start to look like this:class Animal {\n\n  String name;\n  int legs;\n}In the code above you defined two object fields:a field called name of type String; and,\na field called legs of type int.These special pre-defined types are called data types. The String data type is used for fields that can hold textual values like names, while the int (integer) data type is used for fields that can hold numeric valuesFigure 3: In order to denote the Animal object as a system within the Java Environment,\nyou present it as such. Note how fields are presented.In order to demonstrate how fields work, we will go ahead and create objects from this amended version of our class definition as such:Animal animal1 = new Animal();\nAnimal animal2 = new Animal();\n\nanimal1.name = \"dog\";\nanimal1.legs = 4;\n\nanimal2.name = \"duck\";\nanimal2.legs = 2;You can access the fields of your created objects by using the . (dot) or membership operator. In the example above, we created two objects: animal1 and animal2 of type Animal. And since, we had established that each Animal has two fields namely name and legs, we accessed and modified these fields for each of our objects using the membership operator to set the two apart. By declaring different values for different objects, we can manipulate their current state. So, for instance:the animal1 object is a \"dog\" with 4 legs to walk with; while,\nthe animal2 object is a \"duck\" with 2 legs to walk with.What sets the two objects apart is their current state. Both the objects have different states and thus stand out as two different objects even though they were created from the same template or class definition.Adding behavior to objects[edit]At this point, your objects do nothing more than declare a bunch of fields. Being a system, your objects should have the ability to interact with its environment and other systems as well. To add this capability for interaction, you need to add interactive behavior to your object class definitions as well. Such behavior is added to class definitions using a programming construct called method.In the case of the Animal, you require your virtual representation of an animal to be able to move through its environment. Let's say, as an analogy, you want your Animal object to be able to walk in its environment. Thus, you need to add a method named walk to our object. To do so, we need to write the following code:class Animal {\n\n  String name;\n  int legs;\n\n  void walk() { }\n}As you write this code, one thing becomes immediately apparent. Just like the class description, a method has curly brackets as well. Generally, curly brackets are used to define an area (or scope) within your object. So the first set of curly brackets defined a scope for your class definition called the class-level scope. This new set of curly brackets alongside a method defines a scope for the further definition of your method called the method-level scope.In this instance, the name of our method is walk. Notice however that the name of our method also features a set of round brackets as well. More than just being visual identifiers for methods, these round brackets are used to provide our methods with additional input information called arguments.A method therefore enables an object to:Accept input: Receive some argument(s);\nProcess information: work on the received argument(s) within its curly brackets; and,\nGenerate ouput: occasionally, return something back.In essence, methods are what makes an object behave more like a system.Notice the keyword void before the name of the method  this tells us that the method walk returns nothing. You can set a method to return any data type  it can be a String or an int as well.Figure 4: The Animal object can now be denoted as having an interaction behavior within the Java Environment\nas illustrated here. Note the difference between the presentation of fields and methods.", "title": "The process of abstraction[edit]"}], "title": "Getting started"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Installation", "subdata": [], "title": "Installation"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Compilation", "content": "Navigate Getting Started topic: (vde)\n\n Installing Java on Your Computer\n Compiling programs\n Running Java programs\n Understanding a Java program\n Java IDEsIn Java, programs are not compiled into executable files; they are compiled into bytecode (as discussed earlier), which the JVM (Java Virtual Machine) then executes at runtime. Java source code is compiled into bytecode when we use the javac compiler. The bytecode gets saved on the disk with the file extension .class. When the program is to be run, the bytecode is converted, using the just-in-time (JIT) compiler. The result is machine code which is then fed to the memory and is executed.Java code needs to be compiled twice in order to be executed:Java programs need to be compiled to bytecode.\nWhen the bytecode is run, it needs to be converted to machine code.The Java classes/bytecode are compiled to machine code and loaded into memory by the JVM when needed the first time. This is different from other languages like C/C++ where programs are to be compiled to machine code and linked to create an executable file before it can be executed.", "subdata": [{"content": "To execute your first Java program, follow the instructions below:1.\nProceed only if you have successfully installed and configured your system for Java as discussed here.\n\n\n2.\nOpen your preferred text editor  this is the editor you set while installing the Java platform.\n\n\n\nFor example, Notepad or Notepad++ on Windows; Gedit, Kate or SciTE on Linux; or, XCode on Mac OS, etc.\n\n\n3.\nWrite the following lines of code in a new text document:\n\n\n\nCode listing 2.5: HelloWorld.java\n\n\npublic class HelloWorld {\n  public static void main(String[] args) {\n    System.out.println(\"Hello World!\");\n  }\n}\n\n\n\n\n\n\n\n4.\nSave the file as HelloWorld.java  the name of your file should be the same as the name of your class definition and followed by the .java extension. This name is case-sensitive, which means you need to capitalize the precise letters that were capitalized in the name for the class definition.\n\n\n5.\nNext, open your preferred command-line application.\n\n\n\nFor example, Command Prompt on Windows; and, Terminal on Linux and Mac OS.\n\n\n6.\nIn your command-line application, navigate to the directory where you just created your file. If you do not know how to do this, consider reading through our crash courses for command-line applications for Windows or Linux.\n\n\n7.\nCompile the Java source file using the following command which you can copy and paste in if you want:\n\n\n\nCompilation\n\njavac HelloWorld.java\n\n\n\n\n\n\nIf you obtain an error message like error: cannot read: HelloWorld.java 1 error, your file is not in the current folder or it is badly spelled. Did you navigate to the program's location in the command prompt using the cd (change directory) command?\nIf you obtain another message ending by 1 error or ... errors, there may be a mistake in your code. Are you sure all words are spelled correctly and with the exact case as shown? Are there semicolons and brackets in the appropriate spot? Are you missing a quote? Usually, modern IDEs would try coloring the entire source as a quote in this case.\nIf your computer emits beeps, then you may have illegal characters in your HelloWorld.java.\nIf no HelloWorld.class file has been created in the same folder, then you've got an error. Are you launching the javac program correctly?\n\n\n\n\n\n\n8.\nOnce the compiler returns to the prompt, run the application using the following command:\n\n\n\nExecution\n\njava HelloWorld\n\n\n\n\n\n\nIf you obtain an error message like Exception in thread \"main\" java.lang.NoClassDefFoundError: HelloWorld, the HelloWorld.class file is not in the current folder or it is badly spelled.\nIf you obtain an error message like Exception in thread \"main\" java.lang.NoSuchMethodError: main, your source file may have been badly written.\n\n\n\n\n\n\n9.\nThe above command should result in your command-line application displaying the following result:\n\n\n\nOutput\n\nHello World!Ask for help if the program did not execute properly in the Discussion page for this chapter.", "title": "Quick compilation procedure[edit]"}, {"content": "In Java, if you have used any reference to any other java object, then the class for that object will be automatically compiled, if that was not compiled already. These automatic compilations are nested, and this continues until all classes are compiled that are needed to run the program. So it is usually enough to compile only the high level class, since all the dependent classes will be automatically compiled.Main class compilation\n\njavac ... MainClass.javaHowever, you can't rely on this feature if your program is using reflection to create objects, or you are compiling for servlets or for a \"jar\", package. In these cases you should list these classes for explicit compilation.Main class compilation\n\njavac ... MainClass.java ServletOne.java ...", "title": "Automatic Compilation of Dependent Classes[edit]"}, {"content": "Each Java top level class belongs to a package (covered in the chapter about Packages). This may be declared in a package statement at the beginning of the file; if that is missing, the class belongs to the unnamed package.For compilation, the file must be in the right directory structure. A file containing a class in the unnamed package must be in the current/root directory; if the class belongs to a package, it must be in a directory with the same name as the package.The convention is that package names and directory names corresponding to the package consist of only lower case letters.Top level package[edit]A class with this package declarationCode section 2.1: Package declaration\n\n\npackage example;has to be in a directory named example.Subpackages[edit]A class with this package declarationCode section 2.2: Package declaration with sub-packages\n\n\npackage org.wikibooks.en;has to be in a directory named en which has to be a sub-directory of wikibooks which in turn has to be a sub-directory of org resulting in org/wikibooks/en on Linux or org\\wikibooks\\en on Windows.Java programs often contain non-code files such as images and properties files. These are referred to generally as resources and stored in directories local to the classes in which they're used. For example, if the class com.example.ExampleApp uses the icon.png file, this file could be stored as /com/example/resources/icon.png. These resources present a problem when a program is compiled, because javac does not copy them to wherever the .class files are being complied to (see above); it is up to the programmer to move the resource files and directories.", "title": "Packages, Subdirectories, and Resources[edit]"}, {"content": "The Java source file name must be the same as the public class name that the file contains. There can be only one public class defined per file. The Java class name is case sensitive, as is the source file name.The naming convention for the class name is for it to start with a capital letter.", "title": "Filename Case[edit]"}, {"content": "Debugging and Symbolic Information[edit]To debug into Java system classes such as String and ArrayList, you need a special version of the JRE which is compiled with \"debug information\". The JRE included inside the JDK provides this info, but the regular JRE does not. Regular JRE does not include this info to ensure better performance.Modern compilers do a pretty good job converting your high-level code, with its nicely indented and nested control structures and arbitrarily typed variables into a big pile of bits called machine code (or bytecode in case of Java), the sole purpose of which is to run as fast as possible on the target CPU (virtual CPU of your JVM). Java code gets converted into several machine code instructions. Variables are shoved all over the place  into the stack, into registers, or completely optimized away. Structures and objects dont even exist in the resulting code  theyre merely an abstraction that gets translated to hard-coded offsets into memory buffers.So how does a debugger know where to stop when you ask it to break at the entry to some function? How does it manage to find what to show you when you ask it for the value of a variable? The answer is  debugging information.Debugging information is generated by the compiler together with the machine code. It is a representation of the relationship between the executable program and the original source code. This information is encoded into a pre-defined format and stored alongside the machine code. Many such formats were invented over the years for different platforms and executable files.Symbolic Information: Symbolic resolution is done at class loading time at linking resolution step. It is the process of replacing symbolic references from the type with direct references. It is done by searching into method area to locate the referenced entity", "title": "Compiler Options[edit]"}, {"content": "For comprehensive information about all aspects of Ant, please see the Ant Wikibook.The best way to build your application is to use a build tool. This checks all the needed dependencies and compiles only the needed class for the build. Ant tool is one of the best and the most popular build tools currently available. Ant is a build management tool designed to replace MAKE as the tool for automated builds of large Java applications. Like Java, and unlike MAKE, Ant is designed to be platform independent.Using Ant you would build your application from the command line by typing:Ant building\n\nant build.xmlThe build.xml file contains all the information needed to build the application.Building a Java application requires certain tasks to be performed defined in a build.xml file. Those tasks may include not only compiling the code, but also copying code, packaging the program to a Jar, creating EJBs, running automated tests, doing ftp for the code to remote site, and so on. For some tasks a condition can be assigned, for example to compile only changed code, or do the task if that was not already done so. Tasks dependency can also be specified, which will make sure that the order of executions of the tasks are in the right order. For example, when compiling the code before packaging it to a jar, the package-to-jar task depends on the compilation task.In rare cases, your code may appear to compile correctly but the program behaves as if you were using an old copy of the source code (or otherwise reports errors during runtime.) When this occurs, you may need to clean your compilation folder by either deleting the class files or using the Clean command from an IDE.The build.xml file is generally kept in the root directory of the java project. Ant parses this file and executes the tasks therein. Below we give an example build.xml file.Ant tool is written in Java and is open source, so it can be extended if there is a task you'd like to be done during the build that is not in the predefined tasks list. It is very easy to hook your ant task code to the other tasks: your code only needs to be in the classpath, and the Ant tool will load it at runtime. For more information about writing your own Ant tasks, please see the project website at http://ant.apache.org/.Example build.xml file.\n\n\n\n<?xml version=\"1.0\"?>\n\n<project name=\"ExampleApp\" basedir=\".\" default=\"main\">\n\n    <property name=\"source.dir\"    value=\"source\" />\n    <property name=\"libraries.dir\" value=\"libraries\" />\n    <property name=\"build.dir\"     value=\"build\" />\n    <property name=\"classes.dir\"   value=\"${build.dir}/classes\" />\n    <property name=\"dist.dir\"      value=\"${build.dir}/dist\" />\n    <property name=\"main-class\"    value=\"com.example.ExampleApp\"/>\n\n    <path id=\"classpath\">\n        <fileset dir=\"${libraries.dir}\" includes=\"**/*.jar\"/>\n    </path>\n\n    <target name=\"clean\">\n        <delete dir=\"${build.dir}\"/>\n    </target>\n\n    <target name=\"compile\">\n        <mkdir dir=\"${classes.dir}\"/>\n        <javac srcdir=\"${source.dir}\" destdir=\"${classes.dir}\" classpathref=\"classpath\" />\n        <copy todir=\"${classes.dir}\">\n            <fileset dir=\"${src.dir}\" excludes=\"**/*.java\" />\n        </copy>\n    </target>\n\n    <target name=\"build\" depends=\"compile\">\n        <mkdir dir=\"${dist.dir}\"/>\n        <copy todir=\"${dist.dir}/lib\" flatten=\"true\">\n            <path refid=\"classpath\" />\n        </copy>\n        <path id=\"dist.classpath\">\n            <fileset dir=\"${dist.dir}/lib\" includes=\"*.jar\" />\n        </path>\n        <manifestclasspath property=\"dist.manifest.classpath\" jarfile=\"${dist.dir}/${ant.project.name}.jar\">\n            <classpath refid=\"dist.classpath\" />\n        </manifestclasspath>\n        <jar destfile=\"${dist.dir}/${ant.project.name}.jar\" >\n            <zipfileset dir=\"${classes.dir}\" />\n            <manifest>\n                <attribute name=\"Class-Path\" value=\"${dist.manifest.classpath}\"/>\n                <attribute name=\"Main-Class\" value=\"${main-class}\" />\n            </manifest>\n        </jar>\n    </target>\n\n    <target name=\"run-build\" depends=\"build\">\n        <java jar=\"${dist.dir}/${ant.project.name}.jar\" fork=\"true\">\n            <classpath>\n                <path refid=\"classpath\"/>\n                <path location=\"${dist.dir}/${ant.project.name}.jar\"/>\n            </classpath>\n        </java>\n    </target>\n\n    <target name=\"run\" depends=\"compile\">\n        <java classname=\"${main-class}\" >\n            <classpath>\n                <path refid=\"classpath\"/>\n                <pathelement location=\"${classes.dir}\" />\n            </classpath>\n        </java>\n    </target>\n\n    <target name=\"clean-build\" depends=\"clean, build\"/>\n\n    <target name=\"main\" depends=\"clean, run\"/>\n\n</project>The next most popular way to build applications is using an Integrated Development Environment (IDE).", "title": "Ant[edit]"}], "title": "Compilation"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Execution", "content": "Navigate Getting Started topic: (vde)\n\n Installing Java on Your Computer\n Compiling programs\n Running Java programs\n Understanding a Java program\n Java IDEsThere are various ways in which Java code can be executed. A complex Java application usually uses third party APIs or services. In this section we list the most popular ways a piece of Java code may be packed together and/or executed.", "subdata": [{"content": "Java language first edition came out in the client-server era. Thick clients were developed with rich GUI interfaces. Java first edition, JSE (Java Standard Edition) had/has the following in its belt:GUI capabilities (AWT, Swing)\nNetwork computing capabilities (RMI)\nMulti-tasking capabilities (Threads)With JSE the following Java code executions are possible:Figure 1: Stand alone executionStand alone Java application\n(Figure 1) Stand alone application refers to a Java program where both the user interface and business modules are running on the same computer. The application may or may not use a database to persist data. The user interface could be either AWT or Swing.\nThe application would start with a main() method of a Class. The application stops when the main() method exits, or if an exception is thrown from the application to the JVM. Classes are loaded to memory and compiled as needed, either from the file system or from a *.jar file, by the JVM.\nInvocation of Java programs distributed in this manner requires usage of the command line. Once the user has all the class files, he needs to launch the application by the following command line (where Main is the name of the class containing the main() method.)Execution of class\n\njava MainJava 'jar' class libraries\nUtility classes, framework classes, and/or third party classes are usually packaged and distributed in Java ' *.jar' files. These 'jar' files need to be put in the CLASSPATH of the java program from which these classes are going to be used.\nIf a jar file is executable, it can be run from the command line:Execution of archive\n\njava -jar Application.jarFigure 2: Applet ExecutionJava Applet code\n(Figure 2) Java Applets are Java code referenced from HTML pages, by the <APPLET> tag. The Java code is downloaded from a server and runs in the client browser JVM. Java has built-in support to render applets in the browser window.\nSophisticated GUI clients were found hard to develop, mostly because of download time, incompatibilities between browser JVM implementations, and communication requirements back to the server. Applets are rarely used today, and are most commonly used as small, separate graphic-like animation applets. The popularity of Java declined when Microsoft withdrew its Java support from Internet Explorer default configuration, however, the plugin is still available as a free download from java.com.\nMore information can be found about applets at the Applet Chapter, in this book. Also, Wikipedia has an article about Java Applets.Client Server applications\nThe client server applications consist of a front-end, and a back-end part, each running on a separate computer. The idea is that the business logic would be on the back-end part of the program, which would be reused by all the clients. Here the challenge is to achieve a separation between front-end user interface code, and the back-end business logic code.\nThe communication between the front-end and the back-end can be achieved by two ways.\n\n\n\nOne way is to define a data communication protocol between the two tiers. The back-end part would listen for an incoming request. Based on the protocol it interprets the request and sends back the result in data form.\nThe other way is to use Java Remote Invocation (RMI). With the use of RMI, a remote object can be created and used by the client. In this case Java objects are transmitted across the network.\n\n\n\n\nMore information can be found about client-server programming, with sample code, at the Client Server Chapter in this book.Web Applications\nFor applications needed by lots of client installations, the client-server model did not work. Maintaining and upgrading the hundreds or thousands of clients caused a problem. It was not practical. The solution to this problem was to create a unified, standard client, for all applications, and that is the Browser.\nHaving a standard client, it makes sense to create a unified, standard back-end service as well, and that is the Application Server.\nWeb Application is an application that is running in the Application Server, and it can be accessed and used by the Browser client.\nThere are three main area of interest in Web Applications, those are:\n\nThe Web Browser. This is the container of rendering HTML text, and running client scripts\nThe HTTP protocol. Text data are sent back and forth between Browser and the Server\nThe Web server to serve static content, Application server to serve dynamic content and host EJBs.\n\n\nWikipedia also has an article about Web application.", "title": "JSE code execution[edit]"}, {"content": "As the focus was shifting from reaching GUI clients to thin client applications, with Java version 2, Sun introduced J2EE (Java 2 Extended Edition). J2EE added:Components Base Architecture, (Servlet, JSP, EJB Containers)With J2EE the following Java component executions are possible:Figure 3: Servlet ExecutionJava Servlet code\n(Figure 3) Java got its popularity with server side programming, more specifically with J2EE servlets. Servlets are running in a simple J2EE framework to handle client HTTP requests. They are meant to replace CGI programming for web pages rendering dynamic content.\nThe servlet is running in a so called servlet-container/web container. The servlet's responsibility is to:\n\nHandle the request by doing the business logic computation,\nConnecting to a database if needed,\nCreate HTML to present to the user through the browser\n\n\nThe HTML output represents both the presention logic and the results of the business computations. This represents a huge problem, and there is no real application relying only on servlets to handle the presention part of the responsibility. There are two main solutions to this:\n\nUse a template tool (Store the presentation part in an HTML file, marking the areas that need to be replaced after business logic computations).\nUse JSP (See next section)\n\n\nWikipedia also has an article about Servlets.Figure 4: Jsp ExecutionJava Server Pages (JSP) code\n(Figure 4) JSP is an HTML file with embedded Java code inside. The first time the JSP is accessed, the JSP is converted to a Java Servlet. This servlet outputs HTML which has inside the result of the business logic computation. There are special JSP tags that helps to add data dynamically to the HTML. Also JSP technology allows to create custom tags.\nUsing the JSP technology correctly, business logic computations should not be in the embedded Java part of the JSP. JSP should be used to render the presentation of the static and dynamic data. Depending on the complexity of the data, 100% separation is not easy to achieve. Using custom tags, however may help to get closer to 100%. This is advocated also in MVC architecture (see below).Figure 5: EJB ExecutionEJB code\n(Figure 5) In the 1990s, with the client server computing, a trend started, that is to move away from Mainframe computing. That resulted in many small separate applications in a Company/Enterprise. Many times the same data was used in different applications. A new philosophy, \"Enterprise Computing\", was created to address these issues. The idea was to create components that can be reused throughout the Enterprise. The Enterprise Java Beans (EJBs) were supposed to address this.\nAn EJB is an application component that runs in an EJB container. The client accesses the EJB modules through the container, never directly. The container manages the life cycle of the EJB modules, and handles all the issues that arise from network/enterpise computing. Some of those are security/access control, object pooling, transaction management, ... .\nEJBs have the same problems as any reusable code: they need to be generic enough to be able to be reused and the changes or maintenance of EJBs can affect existing clients. Many times EJBs are used unnecessarily when they are not really needed. An EJB should be designed as a separate application in the enterprise, fulfilling one function.Figure 6: MVC ExecutionCombine J2EE components to create an MVC architecture\nThis leads us to the three layers/tiers as shown in (Figure 6).\nIn modern web applications, with lots of static data and nice graphics, how the data is presented to the user became very important and usually needs the help of a graphic artist.\nTo help programmers and graphic artists to work together, the separation between data, code, and how it is presented became crucial.\n\n\nThe view (User Interface Logic) contains the logic that is necessary to construct the presentation. This could be handled by JSP technology.\nThe servlet acts as the controller and contains the logic that is necessary to process user events and to select an appropriate response.\nThe business logic (model) actually accomplishes the goal of the interaction. This might be a query or an update to a database. This could be handled by EJB technology.\n\n\nFor more information about MVC, please see MVC.", "title": "J2EE code execution[edit]"}], "title": "Execution"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Understanding_a_Java_Program", "content": "Navigate Getting Started topic: (vde)\n\n Installing Java on Your Computer\n Compiling programs\n Running Java programs\n Understanding a Java program\n Java IDEsThis article presents a small Java program which can be run from the console. It computes the distance between two points on a plane. You do not need to understand the structure and meaning of the program just yet; we will get to that soon. Also, because the program is intended as a simple introduction, it has some room for improvement, and later in the module we will show some of these improvements. But let's not get too far ahead of ourselves!", "subdata": [{"content": "This class is named Distance, so using your favorite editor or Java IDE, first create a file named Distance.java, then copy the source below, paste it into the file and save the file.Code listing 2.1: Distance.java\n\n\n 1  public class Distance {\n 2    private java.awt.Point point0, point1;\n 3  \n 4    public Distance(int x0, int y0, int x1, int y1) {\n 5      point0 = new java.awt.Point(x0, y0);\n 6      point1 = new java.awt.Point(x1, y1);\n 7    }\n 8  \n 9    public void printDistance() {\n10      System.out.println(\"Distance between \" + point0 + \" and \" + point1\n11                      + \" is \" + point0.distance(point1));\n12    }\n13  \n14    public static void main(String[] args) {\n15      Distance dist = new Distance(\n16               intValue(args[0]), intValue(args[1]),\n17               intValue(args[2]), intValue(args[3]));\n18      dist.printDistance();\n19    }\n20  \n21    private static int intValue(String data) {\n22      return Integer.parseInt(data);\n23    }\n24  }At this point, you may wish to review the source to see how much you might be able to understand. While perhaps not being the most literate of programming languages, someone with understanding of other procedural languages such as C, or other object oriented languages such as C++ or C#, will be able to understand most if not all of the sample program.Once you save the file, compile the program:Compilation command\n\n$ javac Distance.java(If the javac command fails, review the installation instructions.)To run the program, you supply it with the x and y coordinates of two points on a plane separated by a space. For this version of Distance, only integer points are supported. The command sequence is java Distance <x0> <y0> <x1> <y1> to compute the distance between the points (x0, y0) and (x1, y1).If you get a java.lang.NumberFormatException exception, some arguments are not a number. If you get a java.lang.ArrayIndexOutOfBoundsException exception, you did not provide enough numbers.Here are two examples:Output for the distance between the points (0, 3) and (4, 0)\n\n$ java Distance 0 3 4 0\nDistance between java.awt.Point[x=0,y=3] and java.awt.Point[x=4,y=0] is 5.0Output for the distance between the points (-4, 5) and (11, 19)\n\n$ java Distance -4 5 11 19\nDistance between java.awt.Point[x=-4,y=5] and java.awt.Point[x=11,y=19] is 20.518284528683193We'll explain this strange looking output, and also show how to improve it, later.", "title": "The Distance Class: Intent, Source, and Use[edit]"}, {"content": "As promised, we will now provide a detailed description of this Java program. We will discuss the syntax and structure of the program and the meaning of that structure.Introduction to Java Syntax[edit]public class Distance {\n   private java.awt.Point point0, point1;\n\n   public Distance(int x0, int y0, int x1, int y1) {\n     point0 = new java.awt.Point(x0, y0);\n     point1 = new java.awt.Point(x1, y1);\n   }\n\n   public void printDistance() {\n     System.out.println(\"Distance between \" + point0 + \" and \" + point1\n                     + \" is \" + point0.distance(point1));\n   }\n\n   public static void main(String[] args) {\n     Distance dist = new Distance(\n              intValue(args[0]), intValue(args[1]),\n              intValue(args[2]), intValue(args[3]));\n     dist.printDistance();\n   }\n\n   private static int intValue(String data) {\n     return Integer.parseInt(data);\n   }\n}Figure 2.1: Basic Java syntax.\n\nFor a further treatment of the syntax elements of Java, see also Syntax.The syntax of a Java class is the characters, symbols and their structure used to code the class. Java programs consist of a sequence of tokens. There are different kinds of tokens. For example, there are word tokens such as class and public which represent keywords (in purple above)  special words with reserved meaning in Java. Other words such as Distance, point0, x1, and printDistance are not keywords but identifiers (in grey). Identifiers have many different uses in Java but primarily they are used as names. Java also has tokens to represent numbers, such as 1 and 3; these are known as literals (in orange). String literals (in blue), such as \"Distance between \", consist of zero or more characters embedded in double quotes, and operators (in red) such as + and = are used to express basic computation such as addition or String concatenation or assignment. There are also left and right braces ({ and }) which enclose blocks. The body of a class is one such block. Some tokens are punctuation, such as periods . and commas , and semicolons ;. You use whitespace such as spaces, tabs, and newlines, to separate tokens. For example, whitespace is required between keywords and identifiers: publicstatic is a single identifier with twelve characters, not two Java keywords.Declarations and Definitions[edit]public class Distance {\n\nprivate java.awt.Point point0, point1;\n\n\n\npublic Distance(int x0, int y0, int x1, int y1) {\npoint0 = new java.awt.Point(x0, y0);\npoint1 = new java.awt.Point(x1, y1);\n}\n\n\n\npublic void printDistance() {\nSystem.out.println(\"Distance between \" + point0 + \" and \" + point1\n+ \" is \" + point0.distance(point1));\n}\n\n\n\npublic static void main(String[] args) {\nDistance dist = new Distance(\nintValue(args[0]), intValue(args[1]),\nintValue(args[2]), intValue(args[3]));\ndist.printDistance();\n}\n\n\n\nprivate static int intValue(String data) {\nreturn Integer.parseInt(data);\n}\n\n\n}Figure 2.2: Declarations and Definitions.Sequences of tokens are used to construct the next building blocks of Java classes as shown above: declarations and definitions. A class declaration provides the name and visibility of a class. In our example, public class Distance is the class declaration. It consists (in this case) of two keywords, public and class followed by the identifier Distance.This means that we are defining a class named Distance. Other classes, or in our case, the command line, can refer to the class by this name. The public keyword is an access modifier which declares that this class and its members may be accessed from other classes. The class keyword, obviously, identifies this declaration as a class. Java also allows declarations of interfaces and annotations.The class declaration is then followed by a block (surrounded by curly braces) which provides the class's definition (in blue in figure 2.2). The definition is the implementation of the class  the declaration and definitions of the class's members. This class contains exactly six members, which we will explain in turn.Two field declarations, named point0 and point1 (in green)\nA constructor declaration (in orange)\nThree method declarations (in red)Example: Instance Fields[edit]The declarationCode section 2.1: Declaration.\n\n\n1 private java.awt.Point point0, point1;...declares two instance fields. Instance fields represent named values that are allocated whenever an instance of the class is constructed. When a Java program creates a Distance instance, that instance will contain space for point0 and point1. When another Distance object is created, it will contain space for its own point0 and point1 values. The value of point0 in the first Distance object can vary independently of the value of point0 in the second Distance object.This declaration consists of:The private access modifier,\nwhich means these instance fields are not visible to other classes.\nThe type of the instance fields. In this case, the type is java.awt.Point.\nThis is the class Point in the java.awt package.\nThe names of the instance fields in a comma separated list.These two fields could also have been declared with two separate but more verbose declarations,Code section 2.2: Verbose declarations.\n\n\n1  private java.awt.Point point0;\n2  private java.awt.Point point1;Since the type of these fields is a reference type (i.e. a field that refers to or can hold a reference to an object value), Java will implicitly initialize the values of point0 and point1 to null when a Distance instance is created. The null value means that a reference value does not refer to an object. The special Java literal null is used to represent the null value in a program. While you can explicitly assign null values in a declaration, as inCode section 2.3: Declarations and assignments.\n\n\n1  private java.awt.Point point0 = null;\n2  private java.awt.Point point1 = null;It is not necessary and most programmers omit such default assignments.Example: Constructor[edit]A constructor is a special method in a class which is used to construct an instance of the class. The constructor can perform initialization for the object, beyond that which the Java VM does automatically. For example, Java will automatically initialize the fields point0 and point1 to null.Code section 2.4: The constructor for the class\n\n\n1 public Distance(int x0, int y0, int x1, int y1) {\n2    point0 = new java.awt.Point(x0, y0);\n3    point1 = new java.awt.Point(x1, y1);\n4 }The constructor above consists of five parts:The optional access modifier(s).\nIn this case, the constructor is declared public\nThe constructor name, which must match the class name exactly: Distance in this case.\nThe constructor parameters.\nThe parameter list is required. Even if a constructor does not have any parameters, you must specify the empty list (). The parameter list declares the type and name of each of the method's parameters.\nAn optional throws clause which declares the exceptions that the constructor may throw. This constructor does not declare any exceptions.\nThe constructor body, which is a Java block (enclosed in {}). This constructor's body contains two statements.This constructor accepts four parameters, named x0, y0, x1 and y1. Each parameter requires a parameter type declaration, which in this example is int for all four parameters. The parameters in the parameter list are separated by commas.The two assignments in this constructor use Java's new operator to allocate two java.awt.Point objects. The first allocates an object representing the first point, (x0, y0), and assigns it to the point0 instance variable (replacing the null value that the instance variable was initialized to). The second statement allocates a second java.awt.Point instance with (x1, y1) and assigns it to the point1 instance variable.This is the constructor for the Distance class. Distance implicitly extends from java.lang.Object. Java inserts a call to the super constructor as the first executable statement of the constructor if there is not one explicitly coded. The above constructor body is equivalent to the following body with the explicit super constructor call:Code section 2.5: Super constructor.\n\n\n1 {\n2    super();\n3    point0 = new java.awt.Point(x0, y0);\n4    point1 = new java.awt.Point(x1, y1);\n5 }While it is true that this class could be implemented in other ways, such as simply storing the coordinates of the two points and computing the distance as \n\n\n\n\n\n(\n\nx\n\n1\n\n\n\n\nx\n\n0\n\n\n\n)\n\n2\n\n\n+\n(\n\ny\n\n1\n\n\n\n\ny\n\n0\n\n\n\n)\n\n2\n\n\n\n\n\n\n{\\displaystyle {\\sqrt {(x_{1}-x_{0})^{2}+(y_{1}-y_{0})^{2}}}}\n\n, this class instead uses the existing java.awt.Point class. This choice matches the abstract definition of this class: to print the distance between two points on the plane. We take advantage of existing behavior already implemented in the Java platform rather than implementing it again. We will see later how to make the program more flexible without adding much complexity, because we choose to use object abstractions here. However, the key point is that this class uses information hiding. That is, how the class stores its state or how it computes the distance is hidden. We can change this implementation without altering how clients use and invoke the class.Example: Methods[edit]Methods are the third and most important type of class member. This class contains three methods in which the behavior of the Distance class is defined: printDistance(), main(), and intValue()The printDistance() method[edit]The printDistance() method prints the distance between the two points to the standard output (normally the console).Code section 2.6: printDistance() method.\n\n\n1 public void printDistance() {\n2   System.out.println(\"Distance between \" + point0\n3     + \" and \" + point1\n4     + \" is \" + point0.distance(point1));\n5 }This instance method executes within the context of an implicit Distance object. The instance field references, point0 and point1, refer to instance fields of that implicit object. You can also use the special variable this to explicitly reference the current object. Within an instance method, Java binds the name this to the object on which the method is executing, and the type of this is that of the current class. The body of the printDistance method could also be coded asCode section 2.7: Explicit instance of the current class.\n\n\n1   System.out.println(\"Distance between \" + this.point0\n2     + \" and \" + this.point1\n3     + \" is \" + this.point0.distance(this.point1));to make the instance field references more explicit.This method both computes the distance and prints it in one statement. The distance is computed with point0.distance(point1); distance() is an instance method of the java.awt.Point class (of which point0 and point1 are instances). The method operates on point0 (binding this to the object that point0 refers to during the execution of the method) and accepting another Point as a parameter. Actually, it is slightly more complicated than that, but we'll explain later. The result of the distance() method is a double precision floating point number.This method uses the syntaxCode section 2.8: String concatenation.\n\n\n1  \"Distance between \" + this.point0\n2  + \" and \" + this.point1\n3  + \" is \" + this.point0.distance(this.point1)to construct a String to pass to the System.out.println(). This expression is a series of String concatenation methods which concatenates Strings or the String representation of primitive types (such as doubles) or objects, and returns a long string. For example, the result of this expression for the points (0,3) and (4,0) is the StringOutput\n\n\"Distance between java.awt.Point[x=0,y=3] and java.awt.Point[x=4,y=0] is 5.0\"which the method then prints to System.out.In order to print, we invoke the println(). This is an instance method from java.io.PrintStream, which is the type of the static field out in the class java.lang.System. The Java VM binds System.out to the standard output stream when it starts a program.The main() method[edit]The main() method is the main entry point which Java invokes when you start a Java program from the command line. The commandOutput\n\njava Distance 0 3 4 0instructs Java to locate the Distance class, put the four command line arguments into an array of String values, then pass those arguments to the public static main(String[]) method of the class. We will introduce arrays shortly. Any Java class that you want to invoke from the command line or desktop shortcut must have a main method with this signature or the following signature: public static main(String...).Code section 2.9: main() method.\n\n\n1 public static void main(String[] args) {\n2    Distance dist = new Distance(\n3          intValue(args[0]), intValue(args[1]),\n4          intValue(args[2]), intValue(args[3]));\n5    dist.printDistance();\n6 }The main() method invokes the final method, intValue(), four times. The intValue() takes a single string parameter and returns the integer value represented in the string. For example, intValue(\"3\") will return the integer 3.People who do test-first programming or perform regression testing write a main() method in every Java class, and a main() function in every Python module, to run automated tests. When a person executes the file directly, the main() method executes and runs the automated tests for that file. When a person executes some other Java file that in turn imports many other Java classes, only one main() method is executed -- the main() method of the directly-executed file.The intValue() method[edit]The intValue() method delegates its job to the Integer.parseInt() method. The main method could have called Integer.parseInt() directly; the intValue() method simply makes the main() method slightly more readable.Code section 2.10: intValue() method.\n\n\n1 private static int intValue(String data) {\n2    return Integer.parseInt(data);\n3 }This method is private since, like the fields point0 and point1, it is part of the internal implementation of the class and is not part of the external programming interface of the Distance class.Static vs. Instance Methods[edit]Both the main() and intValue() methods are static methods. The static keyword tells the compiler to create a single memory space associated with the class. Each individual object instantiated has its own private state variables and methods but use the same static methods and members common to the single class object created by the compiler when the first class object is instantiated or created. This means that the method executes in a static or non-object context  there is no implicit separate instance available when the static methods run from various objects, and the special variable this is not available. As such, static methods cannot access instance methods or instance fields (such as printDistance()) or point0) directly. The main() method can only invoke the instance method printDistance() method via an instance reference such as dist.Data Types[edit]Most declarations have a data type. Java has several categories of data types: reference types, primitive types, array types, and a special type, void.Primitive Types[edit]The primitive types are used to represent boolean, character, and numeric values. This program uses only one primitive type explicitly, int, which represents 32 bit signed integer values. The program also implicitly uses double, which is the return type of the distance() method of java.awt.Point. double values are 64 bit IEEE floating point values. The main() method uses integer values 0, 1, 2, and 3 to access elements of the command line arguments. The Distance() constructor's four parameters also have the type int. Also, the intValue() method has a return type of int. This means a call to that method, such as intValue(args[0]), is an expression of type int. This helps explain why the main method cannot call:Code section 2.11: Wrong type.\n\n\n1 new Distance(args[0], args[1], args[2], args[3]) // This is an errorSince the type of the args array element is String, and our constructor's parameters must be int, such a call would result in an error because Java will not automatically convert values of type String into int values.Java's primitive types are boolean, byte, char, short, int, long, float and double. Each of which are also Java language keywords.Reference Types[edit]In addition to primitive types, Java supports reference type. A reference type is a Java data type which is defined by a Java class or interface. Reference types derive this name because such values refer to an object or contain a reference to an object. The idea is similar to pointers in other languages like C.Java represents sequences of character data, or String, with the reference type java.lang.String which is most commonly referred to as String. String literals, such as \"Distance between \" are constants whose type is String.This program uses three separate reference types:java.lang.String (or simply String)\nDistance\njava.awt.PointFor more information see chapter: Java Programming/Classes, Objects and Types.Array Types[edit]Java supports arrays, which are aggregate types which have a fixed element type (which can be any Java type) and an integral size. This program uses only one array, String[] args. This indicates that args has an array type and that the element type is String. The Java VM constructs and initializes the array that is passed to the main method. See arrays for more details on how to create arrays and access their size.The elements of arrays are accessed with integer indices. The first element of an array is always element 0. This program accesses the first four elements of the args array explicitly with the indices 0, 1, 2, and 3. This program does not perform any input validation, such as verifying that the user passed at least four arguments to the program. We will fix that later.void[edit]void is not a type in Java; it represents the absence of a type. Methods which do not return values are declared as void methods.This class defines two void methods:Code section 2.12: Void methods\n\n\n1 public static void main(String[] args) { ... }\n2 public void printDistance()  { ... }", "title": "Detailed Program Structure and Overview[edit]"}, {"content": "Whitespace in Java is used to separate the tokens in a Java source file. Whitespace is required in some places, such as between access modifiers, type names and Identifiers, and is used to improve readability elsewhere.Wherever whitespace is required in Java, one or more whitespace characters may be used. Wherever whitespace is optional in Java, zero or more whitespace characters may be used.Java whitespace consists of thespace character ' ' (0x20),\nthe tab character (hex 0x09),\nthe form feed character (hex 0x0c),\nthe line separators characters newline (hex 0x0a) or carriage return (hex 0x0d) characters.Line separators are special whitespace characters in that they also terminate line comments, whereas normal whitespace does not.Other Unicode space characters, including vertical tab, are not allowed as whitespace in Java.Required Whitespace[edit]Look at the static method intValue:Code section 2.13: Method declaration\n\n\n1 private static int intValue(String data) {\n2   return Integer.parseInt(data);\n3 }Whitespace is required between private and static, between static and int, between int and intValue, and between String and data.If the code is written like this:Code section 2.14: Collapsed code\n\n\n1 privatestaticint intValue(String data) {\n2   return Integer.parseInt(data);\n3 }...it means something completely different: it declares a method which has the return type privatestaticint It is unlikely that this type exists and the method is no longer static, so the above would result in a semantic error.", "title": "Whitespace[edit]"}], "title": "Understanding a Java Program"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Java_IDEs", "content": "Navigate Getting Started topic: (vde)\n\n Installing Java on Your Computer\n Compiling programs\n Running Java programs\n Understanding a Java program\n Java IDEs", "subdata": [{"content": "A Java IDE (for Integrated Development Environment) is a software application which enables users to more easily write and debug Java programs. Many IDEs provide features like syntax highlighting and code completion, which help the user to code more easily.", "title": "What is a Java IDE?[edit]"}, {"content": "Eclipse on UbuntuEclipse is a Free and Open Source IDE, plus a developer tool framework that can be extended for a particular development need. IBM was behind its development, and it replaced IBM VisualAge tool. The idea was to create a standard look and feel that can be extended via plugins. The extensibility distinguishes Eclipse from other IDEs. Eclipse was also meant to compete with Microsoft Visual Studio tools. Microsoft tools give a standard way of developing code in the Microsoft world. Eclipse gives a similar standard way of developing code in the Java world, with a big success so far. With the online error checking only, coding can be sped up by at least 50% (coding does not include programming).The goals for Eclipse are twofold:Give a standard IDE for developing code\nGive a starting point, and the same look and feel for all other more sophisticated tools built on EclipseIBM's WSAD, and later IBM Rational Software Development Platform, are built on Eclipse.Standard Eclipse features:Standard window management (perspectives, views, browsers, explorers, ...)\nError checking as you type (immediate error indications, ...)\nHelp window as you type (type ., or <ctrl> space, ...)\nAutomatic build (changes in source code are automatically compiled, ...)\nBuilt-in debugger (full featured GUI debugger)\nSource code generation (getters and setters, ...)\nSearches (for implementation, for references, ...)\nCode refactoring (global reference update, ...)\nPlugin-based architecture (ability to build tools that integrate seamlessly with the environment, and some other tools)\n...More info: Eclipse and Plugincentral.", "title": "Eclipse[edit]"}, {"content": "NetBeans on GNU/LinuxThe NetBeans IDE is a Free and Open Source IDE for software developers. The IDE runs on many platforms including Windows, GNU/Linux, Solaris and Mac OS X. It is easy to install and use straight out of the box. You can easily create Java applications for mobile devices using Mobility Pack in NetBeans. With Netbeans 6.0, the IDE has become one of the most preferred development tools, whether it be designing a Swing UI, building a mobile application, an enterprise application or using it as a platform for creating your own IDE.More info: netbeans.org", "title": "NetBeans[edit]"}, {"content": "JCreator is a simple and lightweight JAVA IDE from XINOX Software. It runs only on Windows platforms. It is very easy to install and starts quickly, as it is a native application. This is a good choice for beginners.More info: http://www.apcomputerscience.com/ide/jcreator/index.htm or JCreator", "title": "JCreator[edit]"}, {"content": "Processing is an enhanced IDE. It adds some extra commands and a simplified programming model. This makes it much easier for beginners to start programming in Java. It was designed to help graphic artists learn a bit of programming without struggling too much. Processing runs on Windows, GNU/Linux and Mac OS X platforms.More info: Processing.", "title": "Processing[edit]"}, {"content": "BlueJ on Mac OS XBlueJ is an IDE that includes templates and will compile and run the applications for you. BlueJ is often used by classes because it is not necessary to set classpaths. BlueJ has its own sets of libraries and you can add your own under preferences. That sets the classpath for all compilations that come out of it to include those you have added and the BlueJ libraries.BlueJ offers an interesting GUI for creation of packages and programs. Classes are represented as boxes with arrows running between them to represent inheritance/implementation or if on is constructed in another. The source code is generated by the UML diagram or vice-versa. BlueJ adds all those classes (the project) into the classpath at compile time.By default it doesn't display the line numbers, so this should be ticked into Options\\Preferences...More info: BlueJ Homesite", "title": "BlueJ[edit]"}, {"content": "Kawa is basically a Java editor developed by Tek-Tools. It does not include wizards and GUI tools, best suited to experienced Java programmers in small and midsized development teams. It looks that there is no new development for Kawa.See also a javaworld article", "title": "Kawa[edit]"}, {"content": "JBuilder is an IDE with proprietary source code, sold by Embarcadero Technologies. One of the advantages is the integration with Together, a modeling tool.More info: Embarcadero.", "title": "JBuilder[edit]"}, {"content": "DrJava is an IDE developed by the JavaPLT group at Rice University. It is designed for students.For more information see DrJava.", "title": "DrJava[edit]"}], "title": "Java IDEs"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Language_Fundamentals", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsTopics:\n\nPreface\nGetting started\nLanguage fundamentals\nClasses and objects\nAggregate\nExceptions\nConcurrent Programming\nJavadoc & Annotations\nDesigning user interfaces\nAdvanced topicsThe previous chapter \"Getting started\" was a primer course in the basics of understanding how Java programming works. Throughout the chapter, we tackled a variety of concepts that included:Objects and class definitions;\nAbstract and data types;\nProperties;\nMethods;\nClass-level and method-level scopes;\nKeywords; and,\nAccess modifiers, etc.From this point on, we will be looking into the above mentioned concepts and many more in finer detail with a deeper and richer understanding of how each one of them works. This chapter on Language fundamentals introduces the fundamental elements of the Java programming language in detail. The discussions in this chapter will use the concepts we have already gathered from our previous discussions and build upon them in a progressive manner.", "subdata": [], "title": "Language Fundamentals"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Statements", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsNow that we have the Java platform on our systems and have run the first program successfully, we are geared towards understanding how programs are actually made. As we have already discussed, a program is a set of instructions, which are tasks provided to a computer. These instructions are called statements in Java. Statements can be anything from a single line of code to a complex mathematical equation. Consider the following line:Code section 3.1: A simple assignment statement.\n\n\n1 int age = 24;This line is a simple instruction that tells the system to initialize a variable and set its value as 24. If the above statement was the only one in the program, it would look similar to this:Code listing 3.1: A statement in a simple class.\n\n\n1 public class MyProgram {\n2     public static void main(String[] args) {\n3         int age = 24;\n4     }\n5 }Java places its statements within a class declaration and, in the class declaration, the statements are usually placed in a method declaration, as above.", "subdata": [{"content": "The simplest statement is a variable declaration:Code section 3.2: A simple declaration statement.\n\n\n1 int age;It defines a variable that can be used to store values for later use. The first token is the data type of the variable (which type of values this variable can store). The second token is the name of the variable, by which you will be referring to it. Then each declaration statement is ended by a semicolon (;).", "title": "Variable declaration statement[edit]"}, {"content": "Up until now, we've assumed the creation of variables as a single statement. In essence, we assign a value to those variables, and that's just what it is called. When you assign a value to a variable in a statement, that statement is called an assignment statement (also called an initialization statement). Did you notice one more thing? It's the semicolon (;), which is at the end of each statement. A clear indicator that a line of code is a statement is its termination with an ending semicolon. If one was to write multiple statements, it is usually done with each statement on a separate line ending with a semicolon. Consider the example below:Code section 3.3: Multiple assignment statements.\n\n\n1 int a = 10;\n2 int b = 20;\n3 int c = 30;You do not necessarily have to use a new line to write each statement. Just like English, you can begin writing the next statement where you ended the first one as depicted below:Code section 3.4: Multiple assignment statements on the same line.\n\n\n1 int a = 10; int b = 20; int c = 30;However, the only problem with putting multiple statements on one line is, it's very difficult to read it. It doesn't look that intimidating at first, but once you've got a significant amount of code, it's usually better to organize it in a way that makes sense. It would look more complex and incomprehensible written as it is in Listing 3.4.Now that we have looked into the anatomy of a simple assignment statement, we can look back at what we've achieved. We know that...A statement is a unit of code in programming.\nIf we are assigning a variable a value, the statement is called an assignment statement.\nAn assignment statement includes three parts: a data type, the variable name (also called the identifier) and the value of a variable. We will look more into the nature of identifiers and values in the section Variables later.Now, before we move on to the next topic, you need to try and understand what the code below does.Code section 3.5: Multiple assignment statements with expressions.\n\n\n1 int firstNumber = 10;\n2 int secondNumber = 20;\n3 int result = firstNumber + secondNumber;\n4 System.out.println(result);\n5 secondNumber = 30;\n6 System.out.println(result);The first two statements are pretty much similar to those in Section 3.3 but with different variable names. The third however is a bit interesting. We've already talked of variables as being similar to gift boxes. Think of your computer's memory as a shelf where you put all those boxes. Whenever you need a box (or variable), you call its identifier (that's the name of the variable). So calling the variable identifier firstNumber gives you the number 10, calling secondNumber would give you 20 hence when you add the two up, the answer should be 30. That's what the value of the last variable result would be. The part of the third statement where you add the numbers, i.e., firstNumber + secondNumber is called an expression and the expression is what decides what the value is to be. If it's just a plain value, like in the first two statements, then it's called a literal (the value is literally the value, hence the name literal).Note that after the assignment to result its value will not be changed if we assign different values to firstNumber or secondNumber, like in line 5.With the information you have just attained, you can actually write a decent Java program that can sum up values.", "title": "Assignment statements[edit]"}, {"content": "An assertion checks if a condition is true:Code section 3.6: A return statement.\n\n\n1     public int getAge() {\n2         assert age >= 0;\n3         return age;\n4     }Each assert statement is ended by a semi-colon (;). However, assertions are disabled by default, so you must run the program with the -ea argument in order for assertions to be enabled (java -ea [name of compiled program]).", "title": "Assertion[edit]"}, {"content": "Statements are evaluated in the order as they occur. The execution of flow begins at the top most statement and proceed downwards till the last statement is encountered. A statement can be substituted by a statement block. There are special statements that can redirect the execution flow based on a condition, those statements are called branching statements, described in detail in a later section.", "title": "Program Control Flow[edit]"}, {"content": "A bunch of statements can be placed in braces to be executed as a single block. Such a block of statements can be named or be provided with a condition for execution. Below is how you'd place a series of statements in a block.Code section 3.7: A statement block.\n\n\n1 {\n2     int a = 10;\n3     int b = 20;\n4     int result = a + b;\n5 }", "title": "Statement Blocks[edit]"}, {"content": "Program flow can be affected using function/method calls, loops and iterations. Of various types of branching constructs, we can easily pick out two generic branching methods.Unconditional Branching\nConditional BranchingUnconditional Branching Statements[edit]If you look closely at a method, you'll see that a method is a named statement block that is executed by calling that particular name. An unconditional branch is created either by invoking the method or by calling break, continue, return or throw, all of which are described below.When a name of a method is encountered in a flow, it stops execution in the current method and branches to the newly called method. After returning a value from the called method, execution picks up at the original method on the line below the method call.Code listing 3.8: UnconditionalBranching.java\n\n\n 1 public class UnconditionalBranching {\n 2     public static void main(String[] args) {\n 3         System.out.println(\"Inside main method! Invoking aMethod!\");\n 4         aMethod();\n 5         System.out.println(\"Back in main method!\");\n 6     }\n 7 \n 8     public static void aMethod() {\n 9         System.out.println(\"Inside aMethod!\");\n10     }\n11 }\n\n\n\n\n\n\n\n\n\nOutput provided with the screen of information running the above code.\n\nInside main method! Invoking aMethod!\nInside aMethod!\nBack in main method!The program flow begins in the main method. Just as aMethod is invoked, the flow travels to the called method. At this very point, the flow branches to the other method. Once the method is completed, the flow is returned to the point it left off and resumes at the next statement after the call to the method.", "title": "Branching Statements[edit]"}, {"content": "A return statement exits from a block, so it is often the last statement of a method:Code section 3.9: A return statement.\n\n\n1     public int getAge() {\n2         int age = 24;\n3         return age;\n4     }A return statement can return the content of a variable or nothing. Beware not to write statements after a return statement which would not be executed! Each return statement is ended by a semi-colon (;).Conditional Branching Statements[edit]Conditional branching is attained with the help of the if...else and switch statements. A conditional branch occurs only if a certain condition expression evaluates to true.Conditional Statements[edit]Also referred to as if statements, these allow a program to perform a test and then take action based on the result of that test.The form of the if statement:if (condition) {\n  do statements here if condition is true\n} else {\n  do statements here if condition is false\n}The condition is a boolean expression which can be either true or false. The actions performed will depend on the value of the condition.Example:Code section 3.10: An if statement.\n\n\n1 if (i > 0) {\n2    System.out.println(\"value stored in i is greater than zero\");\n3 } else {\n4    System.out.println(\"value stored is not greater than zero\");\n5 }If statements can also be made more complex using the else if combination:if (condition 1) {\n   do statements here if condition 1 is true\n} else if (condition 2) {\n   do statements here if condition 1 is false and condition 2 is true\n} else {\n  do statements here if neither condition 1 nor condition 2 is true\n}Example:Code section 3.11: An if/else if/else statement.\n\n\n1 if (i > 0) {\n2    System.out.println(\"value stored in i is greater than zero\");\n3 } else if (i < 0) {\n4    System.out.println(\"value stored in i is less than zero\");\n5 } else {\n6    System.out.println(\"value stored is equal to 0\");\n7 }If there is only one statement to be executed after the condition, as in the above example, it is possible to omit the curly braces, however Oracle's Java Code Conventions explicitly state that the braces should always be used.There is no looping involved in an if statement so once the condition has been evaluated the program will continue with the next instruction after the statement.If...else statements[edit]The if ... else statement is used to conditionally execute one of two blocks of statements, depending on the result of a boolean condition.Example:Code section 3.12: An if/else statement.\n\n\n1 if (list == null) {\n2   // This block of statements executes if the condition is true.\n3 } else {\n4   // This block of statements executes if the condition is false.\n5 }Oracle's Java Code Conventions recommend that the braces should always be used.An if statement has two forms:if (boolean-condition)\n   statement1andif (boolean-condition)\n   statement1\nelse\n   statement2Use the second form if you have different statements to execute if the boolean-condition is true or if it is false. Use the first if you only wish to execute statement1 if the condition is true and you do not wish to execute alternate statements if the condition is false.The code section 3.13 calls two int methods, f() and y(), stores the results, then uses an if statement to test if x is less than y and if it is, the statement1 body will swap the values. The end result is x always contains the larger result and y always contains the smaller result.Code section 3.13: Value swap.\n\n\n1 int x = f();\n2 int y = y();\n3 if (x < y) {\n4   int z = x;\n5   x = y;\n6   y = z;\n7 }if...else statements also allow for the use of another statement, else if. This statement is used to provide another if statement to the conditional that can only be executed if the others are not true. For example:Code section 3.14: Multiple branching.\n\n\n1 if (x == 2)\n2   x = 4;\n3 else if (x == 3)\n4   x = 6;\n5 else\n6   x = -1;The else if statement is useful in this case because if one of the conditionals is true, the other must be false. Keep in mind that if one is true, the other will not execute. For example, if the statement at line 2 contained in the first conditional were changed to x = 3;, the second conditional, the else if, would still not execute. However, when dealing with primitive types in conditional statements, it is more desirable to use switch statements rather than multiple else if statements.Switch statements[edit]The switch conditional statement is basically a shorthand version of writing many if...else statements. The syntax for switch statements is as follows:switch(<variable>) {\n  case <result>: <statements>; break;\n  case <result>: <statements>; break;\n  default: <statements>; break;\n}This means that if the variable included equals one of the case results, the statements following that case, until the word break will run. The default case executes if none of the others are true. Note: the only types that can be analysed through switch statements are char, byte, short, or int primitive types. This means that Object variables can not by analyzed through switch statements. However, as of the JDK 7 release, you can use a String object in the expression of a switch statement.Code section 3.15: A switch.\n\n\n 1 int n = 2, x;\n 2 switch (n) {\n 3   case 1: x = 2;\n 4     break;\n 5   case 2: x = 4;\n 6     break;\n 7   case 3: x = 6;\n 8     break;\n 9   case 4: x = 8;\n10     break;\n11 }\n12 return x;In this example, since the integer variable n is equal to 2, case 2 will execute, make x equal to 4. Thus, 4 is returned by the method.", "title": "Return statement[edit]"}, {"content": "Iteration Statements are statements that are used to iterate a block of statements. Such statements are often referred to as loops. Java offers four kinds of iterative statements.The while loop\nThe do...while loop\nThe for loop\nThe foreach loopThe while loop[edit]Main page: Java Programming/Keywords/whileThe while loop iterates a block of code while the condition it specifies is true.The syntax for the loop is:while (condition) {\n   statement;\n }Here the condition is an expression. An expression as discussed earlier is any statement that returns a value. While condition statements evaluate to a boolean value, that is, either true or false. As long as the condition is true, the loop will iterate the block of code over and over and again. Once the condition evaluates to false, the loop exits to the next statement outside the loop.The do...while loop[edit]The do-while loop is functionally similar to the while loop, except the condition is evaluated AFTER the statement executesdo {\n   statement;\n } while (condition);The for loop[edit]Main page: Java Programming/Keywords/forThe for loop is a specialized while loop whose syntax is designed for easy iteration through a sequence of numbers. Example:Code section 3.16: A for loop.\n\n\n1 for (int i = 0; i < 100; i++) {\n2   System.out.println(i + \"\\t\" + i * i);\n3 }\n\n\n\n\n\n\n\n\n\nOutput for code listing 3.16 if you compile and run the statement above.\n\n 0      0\n 1      1\n 2      4\n 3      9\n ...\n 99     9801The program prints the numbers 0 to 99 and their squares.The same statement in a while loop:Code section 3.17: An alternative version.\n\n\n1 int i = 0;\n2 while (i < 100) {\n3    System.out.println(i + \"\\t\" + i * i);\n4    i++;\n5 }The foreach loop[edit]The foreach statement allows you to iterate through all the items in a collection, examining each item in turn while still preserving its type. The syntax for the foreach statement is:for (type item : collection) statement;For an example, we'll take an array of Strings denoting days in a week and traverse through the collection, examining one item at a time.Code section 3.18: A foreach loop.\n\n\n1 String[] days = {\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"};\n2 \n3 for (String day : days) {\n4   System.out.println(day);\n5 }\n\n\n\n\n\n\n\n\n\nOutput for code listing 3.18\n\nMonday\nTuesday\nWednesday\nThursday\nFriday\nSaturday\nSundayNotice that the loop automatically exits after the last item in the collection has been examined in the statement block.Although the enhanced for loop can make code much clearer, it can't be used in some common situations.Only access. Elements can not be assigned to, eg, not to increment each element in a collection.\nOnly single structure. It's not possible to traverse two structures at once, eg, to compare two arrays.\nOnly single element. Use only for single element access, eg, not to compare successive elements.\nOnly forward. It's possible to iterate only forward by single steps.\nAt least Java 5. Don't use it if you need compatibility with versions before Java 5.", "title": "Iteration Statements[edit]"}, {"content": "At times, you would like to re-iterate a loop without executing the remaining statement within the loop. The continue statement causes the loop to re-iterate and start over from the top most statement inside the loop.Where there is an ability to re-iterate the loop, there is an ability to exit the loop when required. At any given moment, if you'd like to exit a loop and end all further work within the loop, the break ought to be used.The continue and break statements can be used with a label like follows:Code section 3.19: Using a label.\n\n\n1 String s = \"A test string for the switch!\\nLine two of test string...\";\n2 outer: for (int i = 0; i < s.length(); i++) {\n3   switch (s.charAt(i)) {\n4     case '\\n': break outer;\n5     case ' ': break;\n6     default: System.out.print(s.charAt(i));\n7   }\n8 }\n\n\n\n\n\n\n\n\n\nOutput for code listing 3.19\n\n Ateststringfortheswitch!", "title": "The continue and break statements[edit]"}, {"content": "A throw statement exits from a method and so on and so on or it is caught by a try/catch block. It does not return a variable but an exception:Code section 3.20: A return statement.\n\n\n1     public int getAge() {\n2         throw new NullPointerException();\n3     }Beware not to write statements after a throw statement which would not be executed too! Each throw statement is ended by a semi-colon (;).", "title": "Throw statement[edit]"}], "title": "Statements"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Conditional_blocks", "subdata": [], "title": "Conditional blocks"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Loop_blocks", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsLoops are a handy tool that enables programmers to do repetitive tasks with minimal effort. Say we want a program that can count from 1 to 10, we could write the following program.Code listing 3.4: Count.java\n\n\n 1 class Count {\n 2     public static void main(String[] args) {\n 3         System.out.println(\"1 \");\n 4         System.out.println(\"2 \");\n 5         System.out.println(\"3 \");\n 6         System.out.println(\"4 \");\n 7         System.out.println(\"5 \");\n 8         System.out.println(\"6 \");\n 9         System.out.println(\"7 \");\n10         System.out.println(\"8 \");\n11         System.out.println(\"9 \";\n12         System.out.println(\"10 \");\n13     }\n14 }\n\n\n\n\n\n\n\n\n\nOutput for code listing 3.4\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10The task will be completed just fine, the numbers 1 to 10 will be printed in the output, but there are a few problems with this solution:Flexibility: what if we wanted to change the start number or end number? We would have to go through and change them, adding extra lines of code where they're needed.\nScalability: 10 repeats are trivial, but what if we wanted 100 or even 1000 repeats? The number of lines of code needed would be overwhelming for a large number of iterations.\nMaintenance: where there is a large amount of code, one is more likely to make a mistake.\nFeature: the number of tasks is fixed and doesn't change at each execution.Using loops we can solve all these problems. Once you get you head around them they will be invaluable to solving many problems in programming.Open up your editing program and create a new file saved as Loop.java. Now type or copy the following code:Code listing 3.5: Loop.java\n\n\n1 class Loop {\n2     public static void main(String[] args) {\n3         int i;\n4         for (i = 1; i <= 10; i++) {\n5             System.out.println(i + \" \");\n6         }\n7     }\n8 }\n\n\n\n\n\n\n\n\n\nOutput for code listing 3.5\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10If we run the program, the same result is produced, but looking at the code, we immediately see the advantages of loops. Instead of executing 10 different lines of code, line 5 executes ten times. 10 lines of code have been reduced to just 4. Furthermore, we may change the number 10 to any number we like. Try it yourself, replace the 10 with your own number.While[edit]while loops are the simplest form of loop. The while loop repeats a block of code while the specified condition is true. Here is the structure of a while loop:while (boolean expression1) {\n\nstatement1\nstatement2\n...\nstatementn\n\n}The loop's condition is checked before each iteration of the loop. If the condition is false at the start of the loop, the loop will not be executed at all. The code section 3.28 sets in squareHigherThan200 the smallest integer whose square exceeds 200.Code section 3.28: The smallest integer whose square exceeds 200.\n\n\n1 int squareHigherThan200 = 0;\n2 \n3 while (squareHigherThan200 * squareHigherThan200 < 200) {\n4   squareHigherThan200 = squareHigherThan200 + 1;\n5 }If a loop's condition will never become false, such as if the true constant is used for the condition, said loop is known as an infinite loop. Such a loop will repeat indefinitely unless it is broken out of. Infinite loops can be used to perform tasks that need to be repeated over and over again without a definite stopping point, such as updating a graphics display.Do... while[edit]The do-while loop is functionally similar to the while loop, except the condition is evaluated AFTER the statement executes It is useful when we try to find a data that does the job by randomly browsing an amount of data.do {\n\nstatement1\nstatement2\n...\nstatementn\n\n} while (boolean expression1);For[edit]The for loop is a specialized while loop whose syntax is designed for easy iteration through a sequence of numbers. It consists of the keyword for followed by three extra statements enclosed in parentheses. The first statement is the variable declaration statement, which allows you to declare one or more integer variables. The second is the condition, which is checked the same way as the while loop. Last is the iteration statement, which is used to increment or decrement variables, though any statement is allowed.This is the structure of a for loop:for (variable declarations; condition; iteration statement) {\n\nstatement1\nstatement2\n...\nstatementn\n\n}To clarify how a for loop is used, here is an example:Code section 3.29: A for loop.\n\n\n1 for (int i = 1; i <= 10; i++) {\n2     System.out.println(i);\n3 }\n\n\n\n\n\n\n\n\n\nOutput for code listing 3.29\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10The for loop is like a template version of the while loop. The alternative code using a while loop would be as follows:Code section 3.30: An iteration using a while loop.\n\n\n1 int i = 1;\n2 while (i <= 10) {\n3   System.out.println(i);\n4   i++;\n5 }The code section 3.31 shows how to iterate with the for loop using multiple variables and the code section 3.32 shows how any of the parameters of a for loop can be skipped. Skip them all, and you have an infinitely repeating loop.Code section 3.31: The for loop using multiple variables.\n\n\n1 for (int i = 1, j = 10; i <= 10; i++, j--) {\n2   System.out.print(i + \" \");\n3   System.out.println(j);\n4 }\n\n\n\n\n\n\n\n\n\nCode section 3.32: The for loop without parameter.\n\n\n1 for (;;) {\n2   // Some code\n3 }For-each[edit]Arrays haven't been covered yet, but you'll want to know how to use the enhanced for loop, called the for-each loop. The for-each loop automatically iterates through a list or array and assigns the value of each index to a variable.To understand the structure of a for-each loop, look at the following example:Code section 3.33: A for-each loop.\n\n\n1 String[] sentence = {\"I\", \"am\", \"a\", \"Java\", \"program.\"};\n2 for (String word : sentence) {\n3     System.out.print(word + \" \");\n4 }\n\n\n\n\n\n\n\n\n\nOutput for code section 3.33\n\nI am a Java program.The example iterates through an array of words and prints them out like a sentence. What the loop does is iterate through sentence and assign the value of each index to word, then execute the code block.Here is the general contract of the for-each loop:for (variable declaration: array or list) {\n\nstatement1\nstatement2\n...\nstatementn\n\n}Make sure that the type of the array or list is assignable to the declared variable, or you will get a compilation error. Notice that the loop automatically exits after the last item in the collection has been examined in the statement block.Although the enhanced for loop can make code much clearer, it can't be used in some common situations.Only access. Elements can not be assigned to, eg, not to increment each element in a collection.\nOnly single structure. It's not possible to traverse two structures at once, eg, to compare two arrays.\nOnly single element. Use only for single element access, eg, not to compare successive elements.\nOnly forward. It's possible to iterate only forward by single steps.\nAt least Java 5. Don't use it if you need compatibility with versions before Java 5.", "subdata": [{"content": "The break keyword exits a flow control loop, such as a for loop. It basically breaks the loop.In the code section 3.34, the loop would print out all the numbers from 1 to 10, but we have a check for when i equals 5. When the loop reaches its fifth iteration, it will be cut short by the break statement, at which point it will exit the loop.Code section 3.34: An interrupted for loop.\n\n\n1 for (int i = 1; i <= 10; i++) {\n2     System.out.println(i);\n3     if (i == 5) {\n4        System.out.println(\"STOP!\");\n5        break;\n6     }\n7 }\n\n\n\n\n\n\n\n\n\nOutput for code section 3.34\n\n1\n2\n3\n4\n5\nSTOP!The continue keyword jumps straight to the next iteration of a loop and evaluates the boolean expression controlling the loop. The code section 3.35 is an example of the continue statement in action:Code section 3.35: A for loop with a skipped iteration.\n\n\n1 for (int i = 1; i <= 10; i++) {\n2     if (i == 5) {\n3         System.out.println(\"Caught i == 5\");\n4         continue;\n5     }\n6     System.out.println(i);\n7 }\n\n\n\n\n\n\n\n\n\nOutput for code section 3.35\n\n1\n2\n3\n4\nCaught i == 5\n6\n7\n8\n9\n10As the break and continue statements reduce the readability of the code, it is recommended to reduce their use or replace them with the use of if and while blocks. Some IDE refactoring operations will fail because of such statements.Test your knowledge\n\nQuestion 3.2: Consider the following code:\n\n\n\nQuestion 3.2: Loops and conditions.\n\n\n 1 int numberOfItems = 5;\n 2 int currentItems = 0;\n 3 int currentCandidate = 1;\n 4 \n 5 while (currentItems < numberOfItems) {\n 6   currentCandidate = currentCandidate + 1;\n 7   System.out.println(\"Test with integer: \" + currentCandidate);\n 8  \n 9   boolean found = true;\n10   for (int i = currentCandidate - 1; i > 1; i--) {\n11    \n12     // Test if i is a divisor of currentCandidate\n13     if ((currentCandidate % i) == 0) {\n14       System.out.println(\"Not matching...\");\n15       found = false;\n16       break;\n17     }\n18    \n19   }\n20  \n21   if (found) {\n22     System.out.println(\"Matching!\");\n23     currentItems = currentItems + 1;\n24   }\n25 }\n26 \n27 System.out.println(\"Find the value: \" + currentCandidate);\n\n\n\n\nWhat will be printed in the standard output?\n\nAnswer\n\n\n\n\nOutput for Question 3.2\n\nTest with integer: 2\nMatching!\nTest with integer: 3\nMatching!\nTest with integer: 4\nNot matching...\nTest with integer: 5\nMatching!\nTest with integer: 6\nNot matching...\nTest with integer: 7\nMatching!\nTest with integer: 8\nNot matching...\nTest with integer: 9\nNot matching...\nTest with integer: 10\nNot matching...\nTest with integer: 11\nMatching!\nFind the value: 11\n\n\n\nThe snippet is searching the 5th prime number, that is to say: 11. It iterates on each positive integer from 2 (2, 3, 4, 5, 6, 7, 8, 9, 10, 11...), among them, it counts the prime numbers (2, 3, 5, 7, 11) and it stops at the 5th one.\nSo the snippet first iterates on each positive integer from 2 using the while loop:\n\n\n\nAnswer 3.2.1: while loop.\n\n\n 1 int numberOfItems = 5;\n 2 int currentItems = 0;\n 3 int currentCandidate = 1;\n 4 \n 5 while (currentItems < numberOfItems) {\n 6   currentCandidate = currentCandidate + 1;\n 7   System.out.println(\"Test with integer: \" + currentCandidate);\n 8  \n 9   boolean found = true;\n10   for (int i = currentCandidate - 1; i > 1; i--) {\n11    \n12     // Test if i is a divisor of currentCandidate\n13     if ((currentCandidate % i) == 0) {\n14       System.out.println(\"Not matching...\");\n15       found = false;\n16       break;\n17     }\n18    \n19   }\n20  \n21   if (found) {\n22     System.out.println(\"Matching!\");\n23     currentItems = currentItems + 1;\n24   }\n25 }\n26 \n27 System.out.println(\"Find the value: \" + currentCandidate);\n\n\n\n\nFor each iteration, the current number is either a prime number or not. If it is a prime number, the code at the left will be executed. If it is not a prime number, the code at the right will be executed.\n\n\n\n\n\n\nAnswer 3.2.2: A prime number.\n\n\n 1 int numberOfItems = 5;\n 2 int currentItems = 0;\n 3 int currentCandidate = 1;\n 4 \n 5 while (currentItems < numberOfItems) {\n 6   currentCandidate = currentCandidate + 1;\n 7   System.out.println(\"Test with integer: \" + currentCandidate);\n 8  \n 9   boolean found = true;\n10   for (int i = currentCandidate - 1; i > 1; i--) {\n11    \n12     // Test if i is a divisor of currentCandidate\n13     if ((currentCandidate % i) == 0) {\n14       System.out.println(\"Not matching...\");\n15       found = false;\n16       break;\n17     }\n18    \n19   }\n20  \n21   if (found) {\n22     System.out.println(\"Matching!\");\n23     currentItems = currentItems + 1;\n24   }\n25 }\n26 \n27 System.out.println(\"Find the value: \" + currentCandidate);\n\n\n\n\n\n\n\n\n\nAnswer 3.2.3: Not a prime number.\n\n\n 1 int numberOfItems = 5;\n 2 int currentItems = 0;\n 3 int currentCandidate = 1;\n 4 \n 5 while (currentItems < numberOfItems) {\n 6   currentCandidate = currentCandidate + 1;\n 7   System.out.println(\"Test with integer: \" + currentCandidate);\n 8  \n 9   boolean found = true;\n10   for (int i = currentCandidate - 1; i > 1; i--) {\n11    \n12     // Test if i is a divisor of currentCandidate\n13     if ((currentCandidate % i) == 0) {\n14       System.out.println(\"Not matching...\");\n15       found = false;\n16       break;\n17     }\n18    \n19   }\n20  \n21   if (found) {\n22     System.out.println(\"Matching!\");\n23     currentItems = currentItems + 1;\n24   }\n25 }\n26 \n27 System.out.println(\"Find the value: \" + currentCandidate);\n\n\n\n\n\n\n\nThe prime numbers are counted using currentItems. When currentItems is equal to numberOfItems (5), the program go out of the while loop. currentCandidate contains the last number, that is to say the 5th prime number:\n\n\n\nAnswer 3.2.4: End of the program.\n\n\n 1 int numberOfItems = 5;\n 2 int currentItems = 0;\n 3 int currentCandidate = 1;\n 4 \n 5 while (currentItems < numberOfItems) {\n 6   currentCandidate = currentCandidate + 1;\n 7   System.out.println(\"Test with integer: \" + currentCandidate);\n 8  \n 9   boolean found = true;\n10   for (int i = currentCandidate - 1; i > 1; i--) {\n11    \n12     // Test if i is a divisor of currentCandidate\n13     if ((currentCandidate % i) == 0) {\n14       System.out.println(\"Not matching...\");\n15       found = false;\n16       break;\n17     }\n18    \n19   }\n20  \n21   if (found) {\n22     System.out.println(\"Matching!\");\n23     currentItems = currentItems + 1;\n24   }\n25 }\n26 \n27 System.out.println(\"Find the value: \" + currentCandidate);", "title": "Break and continue keywords[edit]"}, {"content": "Labels can be used to give a name to a loop. The reason to do this is so we can break out of or continue with upper-level loops from a nested loop.Here is how to label a loop:label name:loopTo break out of or continue with a loop, use the break or continue keyword followed by the name of the loop.For example:Code section 3.36: A double for loop.\n\n\n 1 int i, j;\n 2 int[][] nums = {\n 3     {1, 2, 5},\n 4     {6, 9, 7},\n 5     {8, 3, 4}\n 6 };\n 7 \n 8 Outer:\n 9 for (i = 0; i < nums.length; i++) {\n10     for (j = 0; j < nums[i].length; j++) {\n11         if (nums[i][j] == 9) {\n12             System.out.println(\"Found number 9 at (\" + i + \", \" + j + \")\");\n13             break Outer;\n14         }\n15     }\n16 }\n\n\n\n\n\n\n\n\n\nOutput for code section 3.36\n\nFound number 9 at (1, 1)You needn't worry if you don't understand all the code, but look at how the label is used to break out of the outer loop from the inner loop. However, as such a code is hard to read and maintain, it is highly recommended not to use labels.", "title": "Labels[edit]"}, {"content": "See also Throwing and Catching Exceptions.The try-catch blocks are used to catch any exceptions or other throwable objects within the code.Here's what try-catch blocks looks like:try {\n\nstatement1.1\nstatement1.2\n...\nstatement1.n\n\n} catch (exception1) {\n\nstatement2.1\n...\nstatement2.n\n\n}The code listing 3.6 tries to print all the arguments that have been passed to the program. However, if there not enough arguments, it will throw an exception.Code listing 3.6: Attempt.java\n\n\n 1 public class Attempt {\n 2   public static void main(String[] args) {\n 3     try {\n 4       System.out.println(args[0]);\n 5       System.out.println(args[1]);\n 6       System.out.println(args[2]);\n 7       System.out.println(args[3]);\n 8     } catch (ArrayIndexOutOfBoundsException e) {\n 9       System.out.println(\"Not enough arguments\");\n10     }\n11   }\n12 }In addition to the try and catch blocks, a finally block may be present. The finally block is always executed, even if an exception is thrown. It may appear with or without a catch block, but always with a try block.Here is what a finally block looks like:try {\n\nstatement1.1\nstatement1.2\n...\nstatement1.n\n\n} catch (exception1) {\n\nstatement2.1\n...\nstatement2.n\n\n} finally {\n\nstatement3.1\n...\nstatement3.n\n\n}", "title": "Try... catch blocks[edit]"}], "title": "Loop blocks"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Boolean_expressions", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsBoolean values are values that evaluate to either true or false, and are represented by the boolean data type. Boolean expressions are very similar to mathematical expressions, but instead of using mathematical operators such as \"+\" or \"-\", you use comparative or boolean operators such as \"==\" or \"!\".", "subdata": [{"content": "Java has several operators that can be used to compare variables. For example, how would you tell if one variable has a greater value than another? The answer: use the \"greater-than\" operator.Here is a list of the comparative operators in Java:>: Greater than\n<: Less than\n>=: Greater than or equal to\n<=: Less than or equal to\n==: Equal to\n!=: Not equal toTo see how these operators are used, look at this example:Code section 3.37: Comparisons.\n\n\n1 int a = 5, b = 3;\n2 System.out.println(a > b); // Value is true because a is greater than b\n3 System.out.println(a == b); // Value is false because a does not equal b\n4 System.out.println(a != b); // Value is true because a does not equal b\n5 System.out.println(b <= a); // Value is true because b is less than a\n\n\n\n\n\n\n\n\n\nOutput for code section 3.37\n\ntrue\nfalse\ntrue\ntrueComparative operators can be used on any primitive types (except boolean), but only the \"equals\" and \"does not equal\" operators work on objects. This is because the less-than/greater-than operators cannot be applied to objects, but the equivalency operators can.Specifically, the == and != operators test whether both variables point to the same object. Objects will be covered later in the tutorial, in the \"Classes, Objects, and Types\" module.", "title": "Comparative operators[edit]"}], "title": "Boolean expressions"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Variables", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsIn the Java programming language, the words field and variable are both one and the same thing. Variables are devices that are used to store data, such as a number, or a string of character data.", "subdata": [{"content": "Java is considered as a strongly typed programming language. Thus all variables in the Java programming language ought to have a particular data type. This is either declared or inferred and the Java language only allows programs to run if they adhere to type constraints.If you present a numeric type with data that is not numeric, say textual content, then such declarations would violate Javas type system. This gives Java the ability of type safety. Java checks if an expression or data is encountered with an incorrect type or none at all. It then automatically flags this occurrence as an error at compile time. Most type-related errors are caught by the Java compiler, hence making a program more secure and safe once compiled completely and successfully. Some languages (such as C) define an interpretation of such a statement and use that interpretation without any warning; others (such as PL/I) define a conversion for almost all such statements and perform the conversion to complete the assignment. Some type errors can still occur at runtime because Java supports a cast operation which is a way of changing the type of one expression to another. However, Java performs run time type checking when doing such casts, so an incorrect type cast will cause a runtime exception rather than succeeding silently and allowing data corruption.On the other hand, Java is also known as a hybrid language. While supporting object oriented programming (OOP), Java is not a pure OO language like Smalltalk or Ruby. Instead, Java offers both object types and primitive types. Primitive types are used for boolean, character, and numeric values and operations. This allows relatively good performance when manipulating numeric data, at the expense of flexibility. For example, you cannot subclass the primitive types and add new operations to them.", "title": "Variables in Java programming[edit]"}, {"content": "In the Java programming language, there are four kinds of variables.Code listing 3.9: ClassWithVariables.java\n\n\n1 public class ClassWithVariables {\n2     public int id = 0;\n3     public static boolean isClassUsed;\n4 \n5     public void processData(String parameter) {\n6       Object currentValue = null;\n7     }\n8 }In the code listing 3.9, are examples of all four kinds of variables.Instance variables: These are variables that are used to store the state of an object (for example, id). Every object created from a class definition would have its own copy of the variable. It is valid for and occupies storage for as long as the corresponding object is in memory.\nClass variables: These variables are explicitly defined within the class-level scope with a static modifier (for example, isClassUsed). No other variables can have a static modifier attached to them. Because these variables are defined with the static modifier, there would always be a single copy of these variables no matter how many times the class has been instantiated. They live as long as the class is loaded in memory.\nParameters or Arguments: These are variables passed into a method signature (for example, parameter). Recall the usage of the args variable in the main method. They are not attached to modifiers (i.e. public, private, protected or static) and they can be used everywhere in the method. They are in memory during the execution of the method and can't be used after the method returns.\nLocal variables: These variables are defined and used specifically within the method-level scope (for example, currentValue) but not in the method signature. They do not have any modifiers attached to it. They no longer exist after the method has returned.Test your knowledge\n\nQuestion 3.5: Consider the following code:\n\n\n\nQuestion 3.5: SomeClass.java\n\n\n 1 public class SomeClass {\n 2   public static int c = 1;\n 3   public int a = c;\n 4   private int b;\n 5 \n 6   public void someMethod(int d) {\n 7     d = c;\n 8     int e;\n 9   }\n10 }\n\n\n\n\nIn the example above, we created five variables: a, b, c, d and e. All these variables have the same data type int (integer). However, can you tell what kind of variable each one is?\n\nAnswer\n\n\na and b are instance variables;\nc is a class variable;\nd is a parameter or argument; and,\ne is a local variable.", "title": "Kinds of variables[edit]"}, {"content": "A graphical representation of computer memoryVariables and all the information they store are kept in the computer's memory for access. Think of a computer's memory as a table of data  where each cell corresponds to a variable.Upon creating a variable, we basically create a new address space and give it a unique name. Java goes one step further and lets you define what you can place within the variable  in Java parlance you call this a data type. So, you essentially have to do two things in order to create a variable:Create a variable by giving it a unique name; and,\nDefine a data type for the variable.The following code demonstrates how a simple variable can be created. This process is known as variable declaration.Code section 3.40: A simple variable declaration.\n\n\n1 int a;", "title": "Creating variables[edit]"}, {"content": "Because we have provided a data type for the variable, we have a hint as to what the variable can and cannot hold. We know that int (integer) data type supports numbers that are either positive or negative integers. Therefore once a variable is created, we can provide it with any integer value using the following syntax. This process is called an assignment operation.Code section 3.41: Variable declaration and assignment operation (on different lines).\n\n\n1 int a;\n2 a = 10;Java provides programmers with a simpler way of combining both variable declaration and assignment operation in one line. Consider the following code:Code section 3.42: Variable declaration and assignment operation (on the same line).\n\n\n1 int a = 10;", "title": "Assigning values to variables[edit]"}, {"content": "Consider the following code:Code section 3.43: Ungrouped declarations.\n\n\n1 int a;\n2 int b;\n3 String c;\n4 a = 10;\n5 b = 20;\n6 c = \"some text\";There are various ways by which you can streamline the writing of this code. You can group the declarations of similar data types in one statement, for instance:Code section 3.44: Grouped declarations.\n\n\n1 int a, b;\n2 String c;\n3 a = 10;\n4 b = 20;\n5 c = \"some text\";Alternatively, you can further reduce the syntax by doing group declarations and assignments together, as such:Code section 3.45: Grouped declarations and assignments.\n\n\n1 int a = 10, b = 20;\n2 String c = \"some text\";", "title": "Grouping variable declarations and assignment operations[edit]"}, {"content": "Although memory spaces have their own addresses  usually a hash number such as 0xCAD3, etc.  it is much easier to remember a variable's location in the memory if we can give it a recognizable name. Identifiers are the names we give to our variables. You can name your variable anything like aVariable, someVariable, age, someonesImportantData, etcetera. But notice: none of the names we described here has a space within it. Hence, it is pretty obvious that spaces aren't allowed in variable names. In fact, there are a lot of other things that are not allowed in variable names. The things that are allowed are:Characters A to Z and their lower-case counterparts a to z.\nNumbers 0 to 9. However, numbers should not come at the beginning of a variable's name.\nAnd finally, special characters that include only $ (dollar sign) and _ (underscore).Test your knowledge\n\nQuestion 3.6: Which of the ones below are proper variable identifiers?\n\nf_name\nlastname\nsomeones name\n$SomeoneElsesName\n7days\nTheAnswerIs42\n\n\nAnswer\n\nI can tell you that 3 and 5 are not the right way to do things around here, the rest are proper identifiers.Any valid variable names might be correct but they are not always what you should be naming your variables for a few reasons as listed below:The name of the variable should reflect the value within them.\nThe identifier should be named following the naming guidelines or conventions for doing so. We will explain that in a bit.\nThe identifier shouldn't be a nonsense name like lname, you should always name it properly: lastName is the best way of naming a variable.", "title": "Identifiers[edit]"}, {"content": "When naming identifiers, you need to use the following guidelines which ensure that your variables are named accurately. As we discussed earlier, we should always name our variables in a way that tells us what they hold. Consider this example:Code section 3.46: Unknown process.\n\n\n1 int a = 24;\n2 int b = 365;\n3 int c = a * b;Do you know what this program does? Well, it multiplies two values. That much you guessed right. But, do you know what those values are? Exactly, you don't. Now consider this code:Code section 3.47: Time conversion.\n\n\n1 int age = 24;\n2 int daysInYear = 365;\n3 int ageInDays = age * daysInYear;Now you can tell what's happening, can't you? However, before we continue, notice the case of the variables. If a word contains CAPITAL LETTERS, it is in UPPER CASE. If a word has small letters, it is in lower case. Both cases in a word renders it as mIxEd CaSe.The variables we studied so far had a mixed case. When there are two or more words making up the names of a variable, you need to use a special case called the camel-case. Just like the humps of a camel, your words need to stand out. Using this technique, the words first and name could be written as either firstName or FirstName.The first instance, firstName is what we use as the names of variables. Remember though, firstName is not the same as FirstName because Java is case-sensitive. Case-sensitive basically implies that the case in which you wrote one word is the case you have to call that word in when using them later on. Anything other than that is not the same as you intended. You'll know more as you progress. You can hopefully tell now why the variables you were asked to identify weren't proper.", "title": "Naming conventions for identifiers[edit]"}], "title": "Variables"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Primitive_Types", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsPrimitive types are the most basic data types available within the Java language. There are 8: boolean, byte, char, short, int, long, float and double. These types serve as the building blocks of data manipulation in Java. Such types serve only one purpose  containing pure, simple values of a kind. Because these data types are defined into the Java type system by default, they come with a number of operations predefined. You can not define a new operation for such primitive types. In the Java type system, there are three further categories of primitives:Numeric primitives: short, int, long, float and double. These primitive data types hold only numeric data. Operations associated with such data types are those of simple arithmetic (addition, subtraction, etc.) or of comparisons (is greater than, is equal to, etc.)\nTextual primitives: byte and char. These primitive data types hold characters (that can be Unicode alphabets or even numbers). Operations associated with such types are those of textual manipulation (comparing two words, joining characters to make words, etc.). However, byte and char can also support arithmetic operations.\nBoolean and null primitives: boolean and null.All the primitive types have a fixed size. Thus, the primitive types are limited to a range of values. A smaller primitive type (byte) can contain less values than a bigger one (long).Category\nTypes\nSize (bits)\nMinimum Value\nMaximum Value\nPrecision\nExample\n\n\nInteger\nbyte\n8\n-128\n127\nFrom +127 to -128\nbyte b = 65;\n\n\nchar\n16\n0\n216-1\nAll Unicode characters\nchar c = 'A';\nchar c = 65;\n\n\nshort\n16\n-215\n215-1\nFrom +32,767 to -32,768\nshort s = 65;\n\n\nint\n32\n-231\n231-1\nFrom +2,147,483,647 to -2,147,483,648\nint i = 65;\n\n\nlong\n64\n-263\n263-1\nFrom +9,223,372,036,854,775,807 to -9,223,372,036,854,775,808\nlong l = 65L;\n\n\nFloating-point\nfloat\n32\n2-149\n(2-2-23)2127\nFrom 3.402,823,5E+38 to 1.4E-45\nfloat f = 65f;\n\n\ndouble\n64\n2-1074\n(2-2-52)21023\nFrom 1.797,693,134,862,315,7E+308 to 4.9E-324\ndouble d = 65.55;\n\n\nOther\nboolean\n1\n--\n--\nfalse, true\nboolean b = true;\n\n\nvoid\n--\n--\n--\n--\n--Integer primitive types silently overflow:Code section 3.52: Several operators.\n\n\n1 int i = Integer.MAX_VALUE;\n2 System.out.println(i);\n3 i = i + 1;\n4 System.out.println(i);\n5 System.out.println(Integer.MIN_VALUE);\n\n\n\n\n\n\n\n\n\nConsole for Code section 3.52\n\n2147483647\n-2147483648\n-2147483648As Java is strongly typed, you can't assign a floating point number (a number with a decimal point) to an integer variable:Code section 3.53: Setting a floating point number as a value to an int (integer) type.\n\n\n1 int age;\n2 age = 10.5;A primitive type should be set by an appropriate value. The primitive types can be initialized with a literal. Most of the literals are primitive type values, except String Literals, which are instance of the String class.", "subdata": [{"content": "Programming may not be as trivial or boring as just crunching huge numbers any more. However, huge chunks of code written in any programming language today, let alone Java, obsessively deal with numbers, be it churning out huge prime numbers,[1] or just calculating a cost of emission from your scooter. In 1965, Gemini V space mission escaped a near-fatal accident because of a programming error.[2] Again in 1979, a computer program overestimated the ability of five nuclear reactors to withstand earthquakes; the plants shut down temporarily.[3] There is one thing common to both these programming errors: the subject data, being computed at the time the errors occurred, was numeric. Out of past experience, Java came bundled with revised type checking for numeric data and put significant emphasis on correctly identifying different types of it. You must recognise the importance of numeric data when it comes to programming.Numbers are stored in memory using a binary system. The memory is like a grid of cells:Each cell can contain a binary digit (shortened to bit), that is to say, zero or one:0\n1\n1\n0\n0\n1\n0\n1Actually, each cell does contain a binary digit, as one bit is roughly equivalent to 1 and an empty cell in the memory signifies 0. A single binary digit can only hold two possible values: a zero or a one.Memory state\n\nGives\n\n\n\n\n\n\n\n\n\n0\n\n0\n\n\n\n\n\n\n\n\n\n1\n\n1Multiple bits held together can hold multiple permutations  2 bits can hold 4 possible values, 3 can hold 8, and so on. For instance, the maximum number 8 bits can hold (11111111 in binary) is 255 in the decimal system. So, the numbers from 0 to 255 can fit within 8 bits.Memory state\n\nGives\n\n\n0\n0\n0\n0\n0\n0\n0\n0\n\n0\n\n\n0\n0\n0\n0\n0\n0\n0\n1\n\n1\n\n\n0\n0\n0\n0\n0\n0\n1\n0\n\n2\n\n\n0\n0\n0\n0\n0\n0\n1\n1\n\n3\n\n\n\n...\n...\n\n\n1\n1\n1\n1\n1\n1\n1\n1\n\n255It is all good, but this way, we can only host positive numbers (or unsigned integers). They are called unsigned integers. Unsigned integers are whole number values that are all positive and do not attribute to negative values. For this very reason, we would ask one of the 8 bits to hold information about the sign of the number (positive or negative). This leaves us with just 7 bits to actually count out a number. The maximum number that these 7 bits can hold (1111111) is 127 in the decimal system.Positive numbers\nNegative numbers\n\n\n\n\n\nMemory state\n\nGives\n\n\n0\n\n0\n0\n0\n0\n0\n0\n0\n\n0\n\n\n0\n\n0\n0\n0\n0\n0\n0\n1\n\n1\n\n\n0\n\n0\n0\n0\n0\n0\n1\n0\n\n2\n\n\n0\n\n0\n0\n0\n0\n0\n1\n1\n\n3\n\n\n\n...\n\n\n...\n...\n\n\n0\n\n1\n1\n1\n1\n1\n1\n1\n\n127\n\n\n\n\n\n\nMemory state\n\nGives\n\n\n1\n\n0\n0\n0\n0\n0\n0\n0\n\n-128\n\n\n1\n\n0\n0\n0\n0\n0\n0\n1\n\n-127\n\n\n1\n\n0\n0\n0\n0\n0\n1\n0\n\n-126\n\n\n1\n\n0\n0\n0\n0\n0\n1\n1\n\n-125\n\n\n\n...\n\n\n...\n...\n\n\n1\n\n1\n1\n1\n1\n1\n1\n1\n\n-1Altogether, using this method, 8 bits can hold numbers ranging from -128 to 127 (including zero)  a total of 256 numbers. Not a bad pay-off one might presume. The opposite to an unsigned integer is a signed integer that have the capability of holding both positive and negative values.But, what about larger numbers. You would need significantly more bits to hold larger numbers. That's where Java's numeric types come into play. Java has multiple numeric types  their size dependent on the number of bits that are at play.In Java, numbers are dealt with using data types specially formulated to host numeric data. But before we dive into these types, we must first set some concepts in stone. Just like you did in high school (or even primary school), numbers in Java are placed in clearly distinct groups and systems. As you'd already know by now, number systems includes groups like the integer numbers (0, 1, 2 ... ); negative integers (0, -1, -2 ... -) or even real and rational numbers (value of Pi, , 0.333~, etcetera). Java simply tends to place these numbers in two distinct groups, integers (- ... 0 ... ) and floating point numbers (any number with decimal points or fractional representation). For the moment, we would only look into integer values as they are easier to understand and work with.", "title": "Numbers in computer science[edit]"}, {"content": "With what we have learned so far, we will identify the different types of signed integer values that can be created and manipulated in Java. Following is a table of the most basic numeric types: integers. As we have discussed earlier, the data types in Java for integers caters to both positive and negative values and hence are signed numeric types. The size in bits for a numeric type determines what its minimum and maximum value would be. If in doubt, one can always calculate these values.Lets see how this new found knowledge of the basic integer types in Java fits into the picture. Say, you want to numerically manipulate the days in a year  all 365 days. What type would you use? Since the data type byte only goes up to 127, would you risk giving it a value greater than its allowed maximum. Such decisions might save you from dreaded errors that might occur out of the programmed code. A much more sensible choice for such a numeric operation might be a short. Oh, why couldn't they make just one data type to hold all kinds of numbers? Wouldn't you ask that question? Well, let's explore why.When you tell a program you need to use an integer, say even a byte, the Java program allocates a space in the memory. It allocates whole 8 bits of memory. Where it wouldn't seem to matter for today's memory modules that have place for almost a dozen trillion such bits, it matters in other cases. Once allocated that part of the memory gets used and can only be claimed back after the operation is finished. Consider a complicated Java program where the only data type you'd be using would be long integers. What happens when there's no space for more memory allocation jobs? Ever heard of the Stack Overflow errors. That's exactly what happens  your memory gets completely used up and fast. So, choose your data types with extreme caution.Enough talk, let's see how you can create a numeric type. A numeric type begins with the type's name (short, int, etc.) and then provides with a name for the allocated space in the memory. Following is how it's done. Say, we need to create a variable to hold the number of days in a year.Code section 3.54: Days in a year.\n\n\n1 short daysInYear = 365;Here, daysInYear is the name of the variable that holds 365 as it's value, while short is the data type for that particular value. Other uses of integer data types in Java might see you write code such as this given below:Code section 3.55: Integer data types in Java.\n\n\n1 byte maxByte = 127;\n2 short maxShort = 32767;\n3 int maxInt = 2147483647;\n4 long maxLong = 9223372036854775807L;", "title": "Integer types in Java[edit]"}, {"content": "The data types that one can use for integer numbers are byte, short, int and long but when it comes to floating point numbers, we use float or double. Now that we know that, we can modify the code in the code section 3.53 as:Code section 3.56: Correct floating point declaration and assignment.\n\n\n1 double age = 10.5;Why not float, you say? If we'd used a float, we would have to append the number with a f as a suffix, so 10.5 should be 10.5f as in:Code section 3.57: The correct way to define floating point numbers of type float.\n\n\n1 float age = 10.5f;Floating-point math never throws exceptions. Dividing a non-zero value by 0 equals infinity. Dividing a non-infinite value by infinity equals 0.Test your knowledge\n\nQuestion 3.7: Consider the following code:\n\n\n\nQuestion 3.7: Primitive type assignments.\n\n\n 5 ...\n 6 \n 7 a = false;\n 8 b = 3.2;\n 9 c = 35;\n10 d = -93485L;\n11 e = 'q';\n\n\n\n\nThese are five variables. There are a long, a byte, a char, a double and a boolean. Retrieve the type of each one.\n\nAnswer\n\n\n\n\nAnswer 3.7: Primitive type assignments and declarations.\n\n\n 1 boolean a;\n 2 double b;\n 3 byte c;\n 4 long d;\n 5 char e;\n 6 \n 7 a = false;\n 8 b = 3.2;\n 9 c = 35;\n10 d = -93485L;\n11 e = 'q';\n\n\n\n\n\na can only be the boolean because only a boolean can handle boolean values.\ne can only be the char because only a char can contain a character.\nb can only be the double because only a double can contain a decimal number here.\nd is the long because a byte can not contain such a low value.\nc is the remaining one so it is the byte.", "title": "Integer numbers and floating point numbers[edit]"}, {"content": "Data conversion (casting) can happen between two primitive types. There are two kinds of casting:Implicit: casting operation is not required; the magnitude of the numeric value is always preserved. However, precision may be lost when converting from integer to floating point types\nExplicit: casting operation required; the magnitude of the numeric value may not be preservedCode section 3.58: Implicit casting (int is converted to long, casting is not needed).\n\n\n1 int  i = 65;\n2 long l = i;Code section 3.59: Explicit casting (long is converted to int, casting is needed).\n\n\n1 long l = 656666L;\n2 int  i = (int) l;The following table shows the conversions between primitive types, it shows the casting operation for explicit conversions:from byte\nfrom char\nfrom short\nfrom int\nfrom long\nfrom float\nfrom double\nfrom boolean\n\n\nto byte\n-\n(byte)\n(byte)\n(byte)\n(byte)\n(byte)\n(byte)\nN/A\n\n\nto char\n\n-\n(char)\n(char)\n(char)\n(char)\n(char)\nN/A\n\n\nto short\n\n(short)\n-\n(short)\n(short)\n(short)\n(short)\nN/A\n\n\nto int\n\n\n\n-\n(int)\n(int)\n(int)\nN/A\n\n\nto long\n\n\n\n\n-\n(long)\n(long)\nN/A\n\n\nto float\n\n\n\n\n\n-\n(float)\nN/A\n\n\nto double\n\n\n\n\n\n\n-\nN/A\n\n\nto boolean\nN/A\nN/A\nN/A\nN/A\nN/A\nN/A\nN/A\n-Unlike C, C++ and similar languages, Java can't represent false as 0 or null and can't represent true as non-zero. Java can't cast from boolean to a non-boolean primitive data type, or vice versa.For non primitive types:to Integer\nto Float\nto Double\nto String\nto Array\n\n\nInteger\n-\n(float)x\n(double)x\nx.doubleValue()\nx.toString()\nFloat.toString(x)\nnew int[] {x}\n\n\nFloat\njava.text.DecimalFormat(\"#\").format(x)\n-\n(double)x\nx.toString()\nnew float[] {x}\n\n\nDouble\njava.text.DecimalFormat(\"#\").format(x)\njava.text.DecimalFormat(\"#\").format(x)\n-\nx.toString()\nnew double[] {x}\n\n\nString\nInteger.parseInt(x)\nFloat.parseFloat(x)\nDouble.parseDouble(x)\n-\nnew String[] {x}\n\n\nArray\nx[0]\nx[0]\nx[0]\nArrays.toString(x)\n-", "title": "Data conversion (casting)[edit]"}], "title": "Primitive Types"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Arithmetic_expressions", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsIn order to do arithmetic in Java, one must first declare at least one variable. Typically one declares a variable and assigns it a value before any arithmetic is done. Here's an example of declaring an integer variable:Code section 3.59: Variable assignation.\n\n\n1 int x = 5;After creating a variable, one can manipulate its value by using Java's operators: + (addition), - (subtraction), * (multiplication), / (integer division), % (modulo or remainder), ++ (pre- & postincrement by one), -- (pre- & postdecrement by one).Code listing 3.10: Operators.java\n\n\n 1 public class Operators {\n 2   public static void main(String[] args) {\n 3     int x = 5;\n 4     System.out.println(\"x = \" + x);\n 5     System.out.println();\n 6    \n 7     System.out.println(\"--- Addition             ---\");\n 8     x = 5;\n 9     System.out.println(\"x + 2 = \" + (x + 2));\n10     System.out.println(\"x = \" + x);\n11     System.out.println();\n12    \n13     System.out.println(\"--- Subtraction          ---\");\n14     x = 5;\n15     System.out.println(\"x - 4 = \" + (x - 4));\n16     System.out.println(\"x = \" + x);\n17     System.out.println();\n18    \n19     System.out.println(\"--- Multiplication       ---\");\n20     x = 5;\n21     System.out.println(\"x * 3 = \" + (x * 3));\n22     System.out.println(\"x = \" + x);\n23     System.out.println();\n24    \n25     System.out.println(\"--- (Integer) Division   ---\");\n26     x = 5;\n27     System.out.println(\"x / 2 = \" + (x / 2));\n28     System.out.println(\"x = \" + x);\n29     System.out.println();\n30    \n31     System.out.println(\"--- Modulo (Remainder)   ---\");\n32     x = 5;\n33     System.out.println(\"x % 2 = \" + (x % 2));\n34     System.out.println(\"x = \" + x);\n35     System.out.println();\n36    \n37     System.out.println(\"--- Preincrement by one  ---\");\n38     x = 5;\n39     System.out.println(\"++x   = \" + (++x  ));\n40     System.out.println(\"x = \" + x);\n41     System.out.println();\n42    \n43     System.out.println(\"--- Predecrement by one  ---\");\n44     x = 5;\n45     System.out.println(\"--x   = \" + (--x  ));\n46     System.out.println(\"x = \" + x);\n47     System.out.println();\n48    \n49     System.out.println(\"--- Postincrement by one ---\");\n50     x = 5;\n51     System.out.println(\"x++   = \" + (x++  ));\n52     System.out.println(\"x = \" + x);\n53     System.out.println();\n54    \n55     System.out.println(\"--- Postdecrement by one ---\");\n56     x = 5;\n57     System.out.println(\"x--   = \" + (x--  ));\n58     System.out.println(\"x = \" + x);\n59     System.out.println();\n60   }\n61 }\n\n\n\n\n\n\n\n\n\nConsole for Code listing 3.10\n\n\nx = 5\n\n--- Addition             ---\nx + 2 = 7\nx = 5\n\n--- Subtraction          ---\nx - 4 = 1\nx = 5\n\n--- Multiplication       ---\nx * 3 = 15\nx = 5\n\n--- (Integer) Division   ---\nx / 2 = 2\nx = 5\n\n--- Modulo (Remainder)   ---\nx % 2 = 1\nx = 5\n\n--- Preincrement by one  ---\n++x   = 6\nx = 6\n\n--- Predecrement by one  ---\n--x   = 4\nx = 4\n\n--- Postincrement by one ---\nx++   = 5\nx = 6\n\n--- Postdecrement by one ---\nx--   = 5\nx = 4The division operator rounds towards zero: 5/2 is 2, and -5/2 is -2. The remainder operator has the same sign as the left operand; it is defined such that ((a/b)*b) + (a%b) is always equal to a. The preincrement, predecrement, postincrement, and postdecrement operators are special: they also change the value of the variable, by adding or subtracting one. The only difference is that preincrement/decrement returns the new value of the variable; postincrement returns the original value of the variable.Test your knowledge\n\nQuestion 3.8: Consider the following code:\n\n\n\nQuestion 3.8: Question8.java\n\n\n 1 public class Question8 {\n 2   public static void main(String[] args) {\n 3     int x = 10;\n 4     x = x + 10;\n 5     x = 2 * x;\n 6     x = x - 19;\n 7     x = x / 3;\n 8     System.out.println(x);\n 9   }\n10 }\n\n\n\n\nWhat will be printed in the standard output?\n\nAnswer\n\n\n\n\nOutput for Question 3.8\n\n7\n\n\n\nint x = 10; => 10\nx = x + 10; => 20\nx = 2 * x; => 40\nx = x - 19; => 21\nx = x / 3; => 7When using several operators in the same expression, one must consider Java's order of precedence. Java uses the standard PEMDAS (Parenthesis, Exponents, Multiplication and Division, Addition and Subtraction) order. When there are multiple instances of the same precedence, Java reads from left to right. Consider what the output of the following code would be:Code section 3.60: Several operators.\n\n\n1 System.out.println(10*5 + 100/10 - 5 + 7%2);\n\n\n\n\n\n\n\n\n\nConsole for Code section 3.60\n\n56The following chart shows how Java would compute this expression:Figure 3.1: Computation of an arithmetic expression in the Java programming languageBesides performing mathematical functions, there are also operators to assign numbers to variables (each example again uses the variable initialized as x = 5):Code listing 3.11: Assignments.java\n\n\n 1 public class Assignments {\n 2   public static void main(String[] args) {\n 3     int x = 5;\n 4     x = 3;\n 5     System.out.println(\"Assignment                                       (x = 3) : \" + x);\n 6 \n 7     x = 5;\n 8     x += 5;\n 9     System.out.println(\"Assign x plus another integer to itself          (x += 5): \" + x);\n10 \n11     x = 5;\n12     x -= 4;\n13     System.out.println(\"Assign x minus another integer to itself         (x -= 4): \" + x);\n14 \n15     x = 5;\n16     x *= 6;\n17     System.out.println(\"Assign x multiplied by another integer to itself (x *= 6): \" + x);\n18 \n19     x = 5;\n20     x /= 5;\n21     System.out.println(\"Assign x divided by another integer to itself    (x /= 5): \" + x);\n22   }\n23 }\n\n\n\n\n\n\n\n\n\nConsole for Code listing 3.11\n\nAssignment                                       (x = 3) : 3\nAssign x plus another integer to itself          (x += 5): 10\nAssign x minus another integer to itself         (x -= 4): 1\nAssign x multiplied by another integer to itself (x *= 6): 30\nAssign x divided by another integer to itself    (x /= 5): 1", "subdata": [], "title": "Arithmetic expressions"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Literals", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsJava Literals are syntactic representations of boolean, character, numeric, or string data. Literals provide a means of expressing specific values in your program. For example, in the following statement, an integer variable named count is declared and assigned an integer value. The literal 0 represents, naturally enough, the value zero.Code section 3.61: Numeric literal.\n\n\n1 int count = 0;The code section 3.62 contains two number literals followed by two boolean literals at line 1, one string literal followed by one number literal at line 2, and one string literal followed by one real number literal at line 3:Code section 3.62: Literals.\n\n\n1 (2 > 3) ? true : false;\n2 \"text\".substring(2);\n3 System.out.println(\"Display a hard coded float: \" + 37.19f);", "subdata": [{"content": "There are two boolean literalstrue represents a true boolean value\nfalse represents a false boolean valueThere are no other boolean literals, because there are no other boolean values!", "title": "Boolean Literals[edit]"}, {"content": "There are three types of numeric literals in Java.Integer Literals[edit]In Java, you may enter integer numbers in several formats:As decimal numbers such as 1995, 51966. Negative decimal numbers such as -42 are actually expressions consisting of the integer literal with the unary negation operation -.\nAs octal numbers, using a leading 0 (zero) digit and one or more additional octal digits (digits between 0 and 7), such as 077. Octal numbers may evaluate to negative numbers; for example 037777777770 is actually the decimal value -8.\nAs hexadecimal numbers, using the form 0x (or 0X) followed by one or more hexadecimal digits (digits from 0 to 9, a to f or A to F). For example, 0xCAFEBABEL is the long integer 3405691582. Like octal numbers, hexadecimal literals may represent negative numbers.\nStarting in J2SE 7.0, as binary numbers, using the form 0b (or 0B) followed by one or more binary digits (0 or 1). For example, 0b101010 is the integer 42. Like octal and hex numbers, binary literals may represent negative numbers.By default, the integer literal primitive type is int. If you want a long, add a letter el suffix (either the character l or the character L) to the integer literal. This suffix denotes a long integer rather than a standard integer. For example, 3405691582L is a long integer literal. Long integers are 8 bytes in length as opposed to the standard 4 bytes for int. It is best practice to use the suffix L instead of l to avoid confusion with the digit 1 (one) which looks like l in many fonts: 200l  2001. If you want a short integer literal, you have to cast it.Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits.Floating Point Literals[edit]Floating point numbers are expressed as decimal fractions or as exponential notation:Code section 3.63: Floating point literals.\n\n\n1 double decimalNumber = 5.0;\n2 decimalNumber = 5d;\n3 decimalNumber = 0.5;\n4 decimalNumber = 10f;\n5 decimalNumber = 3.14159e0;\n6 decimalNumber = 2.718281828459045D;\n7 decimalNumber = 1.0e-6D;Floating point numbers consist of:an optional leading + or - sign, indicating a positive or negative value; if omitted, the value is positive,\none of the following number formats\n\ninteger digits (must be followed by either an exponent or a suffix or both, to distinguish it from an integer literal)\ninteger digits .\ninteger digits . integer digits\n. integer digits\n\n\nan optional exponent of the form\n\nthe exponent indicator e or E\nan optional exponent sign + or - (the default being a positive exponent)\ninteger digits representing the integer exponent value\n\n\nan optional floating point suffix:\n\neither f or F indicating a single precision (4 bytes) floating point number, or\nd or D indicating the number is a double precision floating point number (by default, thus the double precision (8 bytes) is default).Here, integer digits represents one or more of the digits 0 through 9.Starting in J2SE 7.0, you may insert underscores between digits in a numeric literal. They are ignored but may help readability by allowing the programmer to group digits.Character Literals[edit]Character literals are constant valued character expressions embedded in a Java program. Java characters are sixteen bit Unicode characters, ranging from 0 to 65535. Character literals are expressed in Java as a single quote, the character, and a closing single quote ('a', '7', '$', ''). Character literals have the type char, an unsigned integer primitive type. Character literals may be safely promoted to larger integer types such as int and long. Character literals used where a short or byte is called for must be cast to short or byte since truncation may occur.", "title": "Numeric Literals[edit]"}, {"content": "String literals consist of the double quote character (\") (ASCII 34, hex 0x22), zero or more characters (including Unicode characters), followed by a terminating double quote character (\"), such as: \"Ceci est une string.\"So a string literal follows the following grammar:<STRING :\n        \"\\\"\"\n        (    (~[\"\\\"\",\"\\\\\",\"\\n\",\"\\r\"])\n        |(\"\\\\\"\n            ( [\"n\",\"t\",\"b\",\"r\",\"f\",\"\\\\\",\"'\",\"\\\"\"]\n            |[\"0\"-\"7\"]([\"0\"-\"7\"])?\n            |[\"0\"-\"3\"][\"0\"-\"7\"][\"0\"-\"7\"]\n            )\n        )\n        )*\n        \"\\\"\">Within string and character literals, the backslash character can be used to escape special characters, such as unicode escape sequences, or the following special characters:Name\nCharacter\nASCII\nhex\n\n\nBackspace\n\\b\n8\n0x08\n\n\nTAB\n\\t\n9\n0x09\n\n\nNUL character\n\\0\n0\n0x00\n\n\nnewline\n\\n\n10\n0x0a\n\n\ncarriage control\n\\r\n13\n0xd\n\n\ndouble quote\n\\\"\n34\n0x22\n\n\nsingle quote\n\\'\n39\n0x27\n\n\nbackslash\n\\\\\n92\n0x5cString literals may not contain unescaped newline or linefeed characters. However, the Java compiler will evaluate compile time expressions, so the following String expression results in a string with three lines of text:Code section 3.64: Multi-line string.\n\n\n1 String text = \"This is a String literal\\n\"\n2             + \"which spans not one and not two\\n\"\n3             + \"but three lines of text.\\n\";", "title": "String Literals[edit]"}, {"content": "null is a special Java literal which represents a null value: a value which does not refer to any object. It is an error to attempt to dereference the null value  Java will throw a NullPointerException. null is often used to represent uninitialized state.", "title": "null[edit]"}], "title": "Literals"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Methods", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsMethods are how we communicate with objects. When we invoke or call a method we are asking the object to carry out a task. We can say methods implement the behaviour of objects. For each method we need to give a name, we need to define its input parameters and we need to define its return type. We also need to set its visibility (private, protected or public). If the method throws a checked exception, that needs to be declared as well. It is called a method definition. The syntax of method definition is:1 MyClass {\n2   ...\n3   public ReturnType methodName(ParamOneType parameter1, ParamTwoType parameter2) {\n4       ...\n5       return returnType;\n6   }\n7   ...\n8 }We can declare that the method does not return anything using the void Java keyword. For example:Code section 3.67: Method without returned data.\n\n\n1 private void methodName(String parameter1, String parameter2) {\n2   ...\n3   return;\n4 }When the method returns nothing, the return keyword at the end of the method is optional. When the execution flow reaches the return keyword, the method execution is stopped and the execution flow returns to the caller method. The return keyword can be used anywhere in the method as long as there is a way to execute the instructions below:Code section 3.68: return keyword location.\n\n\n 1 private void aMethod(int a, int b) {\n 2   int c = 0;\n 3   if (a > 0) {\n 4     c = a;\n 5     return;\n 6   }\n 7   int c = c + b;\n 8   return;\n 9   int c = c * 2;\n10 }In the code section 3.68, the return keyword at line 5 is well placed because the instructions below can be reached when a is negative or equal to 0. However, the return keyword at line 8 is badly placed because the instructions below can't be reached.Test your knowledge\n\nQuestion 3.9: Consider the following code:\n\n\n\nQuestion 3.9: Compiler error.\n\n\n1 private int myMethod(int a, int b, boolean c) {\n2   b = b + 2;\n3   if (a > 0) {\n4     a = a + b;\n5     return a;\n6   } else {\n7     a = 0;\n8   }\n9 }\n\n\n\n\nThe code above will return a compiler error. Why?\n\nAnswer\n\n\n\n\nAnswer 3.9: Compiler error.\n\n\n1 private int myMethod(int a, int b, boolean c) {\n2   b = b + 2;\n3   if (a > 0) {\n4     a = a + b;\n5     return a;\n6   } else {\n7     a = 0;\n8   }\n9 }\n\n\n\n\nThe method is supposed to return a int but when a is negative or equal to 0, it returns nothing.", "subdata": [{"content": "We can pass any primitive data types or reference data type to a method.Primitive type parameter[edit]The primitive types are passed in by value. It means that as soon as the primitive type is passed in, there is no more link between the value inside the method and the source variable:Code section 3.69: A method modifying a variable.\n\n\n1 private void modifyValue(int number) {\n2   number += 1;\n3 }Code section 3.70: Passing primitive value to method.\n\n\n1 int i = 0;\n2 modifyValue(i);\n3 System.out.println(i);\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.70\n\n0As you can see in code section 3.70, the modifyValue() method has not modified the value of i.Reference type parameter[edit]The object references are passed by value. It means that:There is no more link between the reference inside the method and the source reference,\nThe source object itself and the object itself inside the method are still the same.You must understand the difference between the reference of an object and the object itself. A object reference is the link between a variable name and an instance of object:Object object  new Object()An object reference is a pointer, an address to the object instance.The object itself is the value of its attributes inside the object instance:object.firstName\n\n\"James\"\n\n\nobject.lastName\n\n\"Gosling\"\n\n\nobject.birthDay\n\n\"May 19\"Take a look at the example above:Code section 3.71: A method modifying an object.\n\n\n1 private void modifyObject(FirstClass anObject) {\n2   anObject.setName(\"Susan\");\n3 }Code section 3.72: Passing reference value to method.\n\n\n1 FirstClass object = new FirstClass();\n2 object.setName(\"Christin\");\n3 \n4 modifyObject(object);\n5 \n6 System.out.println(object.getName());\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.72\n\nSusanThe name has changed because the method has changed the object itself and not the reference. Now take a look at the other example:Code section 3.73: A method modifying an object reference.\n\n\n1 private void modifyObject(FirstClass anObject) {\n2   anObject = new FirstClass();\n3   anObject.setName(\"Susan\");\n4 }Code section 3.74: Passing reference value to method.\n\n\n1 FirstClass object = new FirstClass();\n2 object.setName(\"Christin\");\n3 \n4 modifyObject(object);\n5 \n6 System.out.println(object.getName());\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.74\n\nChristinThe name has not changed because the method has changed the reference and not the object itself. The behavior is the same as if the method was in-lined and the parameters were assigned to new variable names:Code section 3.75: In-lined method.\n\n\n 1 FirstClass object = new FirstClass();\n 2 object.setName(\"Christin\");\n 3 \n 4 // Start of the method\n 5 FirstClass anObject = object;\n 6 anObject = new FirstClass();\n 7 anObject.setName(\"Susan\");\n 8 // End of the method\n 9 \n10 System.out.println(object.getName());\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.75\n\nChristin", "title": "Parameter passing[edit]"}, {"content": "Java SE 5.0 added syntactic support for methods with variable argument list, which simplifies the typesafe usage of methods requiring a variable number of arguments. Less formally, these parameters are called varargs[1]. The type of a variable parameter must be followed with ..., and Java will box all the arguments into an array:Code section 3.76: A method using vararg parameters.\n\n\n1 public void drawPolygon(Point... points) {\n2   //\n3 }When calling the method, a programmer can simply separate the points by commas, without having to explicitly create an array of Point objects. Within the method, the points can be referenced as points[0], points[1], etc. If no points are passed, the array has a length of zero.A method can have both normal parameters and a variable parameter but the variable parameter must always be the last parameter. For instance, if the programmer is required to use a minimum number of parameters, those parameters can be specified before the variable argument:Code section 3.77: Variable arguments.\n\n\n1 // A polygon needs at least three points.\n2 public void drawPolygon(Point p1, Point p2, Point p3, Point... otherPoints) {\n3   //\n4 }", "title": "Variable argument list[edit]"}, {"content": "A method may return a value (which can be a primitive type or an object reference). If the method does not return a value we use the void Java keyword.However, a method can return only one value so what if you want to return more than one value from a method? You can pass in an object reference to the method, and let the method modify the object properties so the modified values can be considered as an output value from the method. You can also create an Object array inside the method, assign the return values and return the array to the caller. However, this gives a problem if you want to mix primitive data types and object references as the output values from the method.There is a better approach, define a special return object with the needed return values. Create that object inside the method, assign the values and return the reference to this object. This special object is \"bound\" to this method and used only for returning values, so do not use a public class. The best way is to use a nested class, see example below:Code listing 3.12: Multiple returned variables.\n\n\n 1 public class MyObject {\n 2   ...\n 3  \n 4   /** Nested object is for return values from getPersonInfoById method */\n 5   private static class ReturnObject {\n 6       private int age;\n 7       private String name;\n 8 \n 9       public void setAge(int age) {\n10           this.age = age;\n11       }\n12  \n13       public int getAge() {\n14           return age;\n15       }\n16 \n17       public void setName(String name) {\n18           name = name;\n19       }\n20  \n21       public String getName() {\n22           return name;\n23       }\n24   } // End of nested class definition\n25 \n26   /** Method using the nested class to return values */\n27   public ReturnObject getPersonInfoById(int id) {\n28     int    age;\n29     String name;\n30     ...\n31     // Get the name and age based on the ID from the database\n32     ...\n33     ReturnObject result = new ReturnObject();\n34     result.setAge(age);\n35     result.setName(name);\n36 \n37     return result;\n38   }\n39 }In the above example the getPersonInfoById method returns an object reference that contains both values of the name and the age. See below how you may use that object:Code section 3.78: Retrieving the values.\n\n\n1 MyObject object = new MyObject();\n2 MyObject.ReturnObject person = object.getPersonInfoById(102);\n3 \n4 System.out.println(\"Person Name=\" + person.getName());\n5 System.out.println(\"Person Age =\" + person.getAge());Test your knowledge\n\nQuestion 3.10: Consider the following code:\n\n\n\nQuestion 3.10: Compiler error.\n\n\n1 private int myMethod(int a, int b, String c) {\n2   if (a > 0) {\n3     c = \"\";\n4     return c;\n5   }\n6   int b = b + 2;\n7   return b;\n8 }\n\n\n\n\nThe code above will return a compiler error. Why?\n\nAnswer\n\n\n\n\nAnswer 3.10: Compiler error.\n\n\n1 private int myMethod(int a, int b, String c) {\n2   if (a > 0) {\n3     c = \"\";\n4     return c;\n5   }\n6   int b = b + 2;\n7   return b;\n8 }\n\n\n\n\nThe method is supposed to return a int but at line 4, it returns c, which is a String.", "title": "Return parameter[edit]"}, {"content": "The constructor is a special method called automatically when an object is created with the new keyword. Constructor does not have a return value and its name is the same as the class name. Each class must have a constructor. If we do not define one, the compiler will create a default so called empty constructor automatically.Code listing 3.13: Automatically created constructor.\n\n\n1 public class MyClass {\n2   /**\n3   * MyClass Empty Constructor\n4   */\n5   public MyClass() {\n6   }\n7 }", "title": "Special method, the constructor[edit]"}], "title": "Methods"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/API/java.lang.String", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsString is a class built into the Java language defined in the java.lang package. It represents character strings. Strings are ubiquitous in Java. Study the String class and its methods carefully. It will serve you well to know how to manipulate them skillfully. String literals in Java programs, such as \"abc\", are implemented as instances of this class like this:Code section 3.81: String example.\n\n\n1 String str = \"This is string literal\";On the right hand side a String object is created represented by the string literal. Its object reference is assigned to the str variable.", "subdata": [{"content": "Strings are immutable; that is, they cannot be modified once created. Whenever it looks as if a String object was modified actually a new String object was created. For instance, the String.trim() method returns the string with leading and trailing whitespace removed. Actually, it creates a new trimmed string and then returns it. Pay attention on what happens in Code section 3.82:Code section 3.82: Immutability.\n\n\n1 String badlyCutText = \"     Java is great.     \";\n2 System.out.println(badlyCutText);\n3 \n4 badlyCutText.trim();\n5 System.out.println(badlyCutText);\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.82\n\n     Java is great.    \n     Java is great.The trim() method call does not modify the object so nothing happens. It creates a new trimmed string and then throws it away.Code section 3.83: Assignment.\n\n\n1 String badlyCutText = \"     Java is great.     \";\n2 System.out.println(badlyCutText);\n3 \n4 badlyCutText = badlyCutText.trim();\n5 System.out.println(badlyCutText);\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.83\n\n     Java is great.    \nJava is great.The returned string is assigned to the variable. It does the job as the trim() method has created a new String instance.", "title": "Immutability[edit]"}, {"content": "The Java language provides special support for the string concatenation with operator +:Code section 3.84: Examples of concatenation.\n\n\n1 System.out.println(\"First part\");\n2 System.out.println(\" second part\");\n3 String str = \"First part\" + \" second part\";\n4 System.out.println(str);\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.84\n\nFirst part\n second part\nFirst part second partThe concatenation is not always processed at the same time. Raw string literals concatenation is done at compile time, hence there is a single string literal in the byte code of the class. Concatenation with at least one object is done at runtime.+ operator can concatenate other objects with strings. For instance, integers will be converted to strings before the concatenation:Code section 3.85: Concatenation of integers.\n\n\n1 System.out.println(\"Age=\" + 25);\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.85\n\nAge=25Each Java object has the String toString() inherited from the Object class. This method provides a way to convert objects into Strings. Most classes override the default behavior to provide more specific (and more useful) data in the returned String:Code section 3.86: Concatenation of objects.\n\n\n1 System.out.println(\"Age=\" + new Integer(31));\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.86\n\nAge=31", "title": "Concatenation[edit]"}, {"content": "Remember that String objects are immutable objects. Once a String is created, it can not be modified, takes up memory until garbage collected. Be careful of writing a method like this:Code section 3.87: Raw concatenation.\n\n\n1 public String convertToString(Collection<String> words) {\n2   String str = \"\";\n3   // Loops through every element in words collection\n4   for (String word : words) {\n5     str = str + word + \" \";\n6   }\n7   return str;\n8 }On the + operation a new String object is created at each iteration. Suppose words contains the elements [\"Foo\", \"Bar\", \"Bam\", \"Baz\"]. At runtime, the method creates thirteen Strings:\"\"\n\"Foo\"\n\" \"\n\"Foo \"\n\"Foo Bar\"\n\" \"\n\"Foo Bar \"\n\"Foo Bar Bam\"\n\" \"\n\"Foo Bar Bam \"\n\"Foo Bar Bam Baz\"\n\" \"\n\"Foo Bar Bam Baz \"Even though only the last one is actually useful.To avoid unnecessary memory use like this, use the StringBuilder class. It provides similar functionality to Strings, but stores its data in a mutable way. Only one StringBuilder object is created. Also because object creation is time consuming, using StringBuilder produces much faster code.Code section 3.88: Concatenation with StringBuilder.\n\n\n1 public String convertToString(Collection<String> words) {\n2   StringBuilder buf = new StringBuilder();\n3   // Loops through every element in words collection\n4   for (String word : words) {\n5     buf.append(word);\n6     buf.append(\" \");\n7   }\n8   return buf.toString();\n9 }As StringBuilder isn't thread safe (see the chapter on Concurrency) you can't use it in more than one thread. For a multi-thread environment, use StringBuffer instead which does the same and is thread safe. However, StringBuffer is slower so only use it when it is required. Moreover, before Java 5 only StringBuffer existed.", "title": "Using StringBuilder/StringBuffer to concatenate strings[edit]"}, {"content": "Comparing strings is not as easy as it may first seem. Be aware of what you are doing when comparing String's using ==:Code section 3.89: Dangerous comparison.\n\n\n1 String greeting = \"Hello World!\";\n2 if (greeting == \"Hello World!\") {\n3     System.out.println(\"Match found.\");\n4 }\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.89\n\nMatch found.The difference between the above and below code is that the above code checks to see if the String's are the same objects in memory which they are. This is as a result of the fact that String's are stored in a place in memory called the String Constant Pool. If the new keyword is not explicitly used when creating the String it checks to see if it already exists in the Pool and uses the existing one. If it does not exist, a new Object is created. This is what allows Strings to be immutable in Java. To test for equality, use the equals(Object) method inherited by every class and defined by String to return true if and only if the object passed in is a String contains the exact same data:Code section 3.90: Right comparison.\n\n\n1 String greeting = \"Hello World!\";\n2 if (greeting.equals(\"Hello World!\")) {\n3     System.out.println(\"Match found.\");\n4 }\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.90\n\nMatch found.Remember that the comparison is case sensitive.Code section 3.91: Comparison with lowercase.\n\n\n1 String greeting = \"Hello World!\";\n2 if (greeting.equals(\"hello world!\")) {\n3     System.out.println(\"Match found.\");\n4 }\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.91To order String objects, use the compareTo() method, which can be accessed wherever we use a String datatype. The compareTo() method returns a negative, zero, or positive number if the parameter is less than, equal to, or greater than the object on which it is called. Let's take a look at an example:Code section 3.92: Order.\n\n\n1 String person1 = \"Peter\";\n2 String person2 = \"John\";\n3 if (person1.compareTo(person2) > 0) {\n4     // Badly ordered\n5     String temp = person1;\n6     person1 = person2;\n7     person2 = temp;\n8 }The code section 3.92 is comparing the String variable person1 to person2. If person1 is different even in the slightest manner, we will get a value above or below 0 depending on the exact difference. The result is negative if this String object lexicographically precedes the argument string. The result is positive if this String object lexicographically follows the argument string. Take a look at the Java API for more details.", "title": "Comparing Strings[edit]"}, {"content": "Sometimes it is useful to split a string into separate strings, based on a regular expressions. The String class has a split() method, since Java 1.4, that will return a String array:Code section 3.93: Order.\n\n\n1 String person = \"Brown, John:100 Yonge Street, Toronto:(416)777-9999\";\n2 ...\n3 String[] personData = person.split(\":\");\n4 ...\n5 String name    = personData[0];\n6 String address = personData[1];\n7 String phone   = personData[2];Another useful application could be to split the String text based on the new line character, so you could process the text line by line.", "title": "Splitting a String[edit]"}, {"content": "It may also be sometimes useful to create substrings, or strings using the order of letters from an existing string. This can be done in two methods.The first method involves creating a substring out of the characters of a string from a given index to the end:Code section 3.94: Truncating string.\n\n\n1 String str = \"coffee\";\n2 System.out.println(str.substring(3));\n\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.94\n\nfeeThe index of the first character in a string is 0.c\no\nf\nf\ne\ne\n\n\n0\n1\n2\n3\n4\n5By counting from there, it is apparent that the character in index 3 is the second \"f\" in \"coffee\". This is known as the beginIndex. All characters from the beginIndex until the end of the string will be copied into the new substring.The second method involves a user-defined beginIndex and endIndex:Code section 3.95: Extraction of string.\n\n\n1 String str = \"supporting\";\n2 System.out.println(str.substring(3, 7));\n\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.95\n\nportThe string returned by substring() would be \"port\".s\nu\np\np\no\nr\nt\ni\nn\ng\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9Please note that the endIndex is not inclusive. This means that the last character will be of the index endIndex-1. Therefore, in this example, every character from index 3 to index 6, inclusive, was copied into the substring.It is easy to mistake the method substring() for subString() (which does not exist and would return with a syntax error on compilation). Substring is considered to be one word. This is why the method name does not seem to follow the common syntax of Java. Just remember that this style only applies to methods or other elements that are made up of more than one word.", "title": "Substrings[edit]"}, {"content": "The String class also allows for the modification of cases. The two methods that make this possible are toLowerCase() and toUpperCase().Code section 3.96: Case modification.\n\n\n1 String str = \"wIkIbOoKs\";\n2 System.out.println(str.toLowerCase());\n3 System.out.println(str.toUpperCase());\n\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.96\n\nwikibooks\nWIKIBOOKSThese methods are useful to do a search which is not case sensitive:Code section 3.97: Text search.\n\n\n 1 String word = \"Integer\";\n 2 String text = \"A number without a decimal part is an integer.\"\n 3   + \" Integers are a list of digits.\";\n 4 \n 5 ...\n 6 \n 7 // Remove the case\n 8 String lowerCaseWord = word.toLowerCase();\n 9 String lowerCaseText = text.toLowerCase();\n10 \n11 // Search\n12 int index = lowerCaseText.indexOf(lowerCaseWord);\n13 while (index != -1) {\n14   System.out.println(word\n15     + \" appears at column \"\n16     + (index + 1)\n17     + \".\");\n18   index = lowerCaseText.indexOf(lowerCaseWord, index + 1);\n19 }\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.97\n\nInteger appears at column 38.\nInteger appears at column 47.Test your knowledge\n\nQuestion 3.12: You have mail addresses in the following form: <firstName>.<lastName>@<companyName>.org\nWrite the String getDisplayName(String) method that receives the mail string as parameter and returns the readable person name like this: LASTNAME Firstname\n\nAnswer\n\n\n\n\nAnswer 3.12: getDisplayName()\n\n\n 1 public static String getDisplayName(String mail) {\n 2   String displayName = null;\n 3  \n 4   if (mail != null) {\n 5     String[] mailParts = mail.split(\"@\");\n 6     String namePart = mailParts[0];\n 7     String[] namesParts = namePart.split(\"\\\\.\");\n 8    \n 9     // The last name\n10     String lastName = namesParts[1];\n11     lastName = lastName.toUpperCase();\n12    \n13     // The first name\n14     String firstName = namesParts[0];\n15    \n16     String firstNameInitial = firstName.substring(0, 1);\n17     firstNameInitial = firstNameInitial.toUpperCase();\n18    \n19     String firstNameEnd = firstName.substring(1);\n20     firstNameEnd = firstNameEnd.toLowerCase();\n21    \n22     // Concatenation\n23     StringBuilder displayNameBuilder = new StringBuilder(lastName).append(\" \").append(firstNameInitial).append(firstNameEnd);\n24     displayName = displayNameBuilder.toString();\n25   }\n26  \n27   return displayName;\n28 }\n\n\n\n\n\nWe only process non null strings,\nWe first split the mail into two parts to separate the personal information from the company information and we keep the name data,\nThen we split the name information to separate the first name from the last name. As the split() method use regular expression and . is a wildcard character, we have to escape it (\\.). However, in a string, the \\ is also a special character, so we need to escape it too (\\\\.),\nThe last name is just capitalized,\nAs the case of all the first name characters will not be the same, we have to cut the first name. Only the first name initial will be capitalized,\nNow we can concatenate all the fragments. We prefer to use a StringBuilder to do that.", "title": "String cases[edit]"}], "title": "String"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Classes,_Objects_and_Types", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsAn object is composed of fields and methods. The fields, also called data members, characteristics, attributes, or properties, describe the state of the object. The methods generally describe the actions associated with a particular object. Think of an object as a noun, its fields as adjectives describing that noun, and its methods as the verbs that can be performed by or on that noun.For example, a sports car is an object. Some of its fields might be its height, weight, acceleration, and speed. An object's fields just hold data about that object. Some of the methods of the sports car could be \"drive\", \"park\", \"race\", etc. The methods really don't mean much unless associated with the sports car, and the same goes for the fields.The blueprint that lets us build our sports car object is called a class. A class doesn't tell us how fast our sports car goes, or what color it is, but it does tell us that our sports car will have a field representing speed and color, and that they will be say, a number and a word (or hex color code), respectively. The class also lays out the methods for us, telling the car how to park and drive, but these methods can't take any action with just the blueprint  they need an object to have an effect.In Java, a class is located in a file similar to its own name. If you want to have a class called SportsCar, its source file needs to be SportsCar.java. The class is created by placing the following in the source file:Code listing 3.13: SportsCar.java\n\n\n1 public class SportsCar {\n2    /* Insert your code here */\n3 }The class doesn't do anything yet, as you will need to add methods and field variables first.The objects are different from the primitive types because:The primitive types are not instantiated.\nIn the memory, for a primitive type only its value is stored. For an object, also a reference to an instance can be stored.\nIn the memory, the allocated space of a primitive type is fixed, whatever their value. The allocated space of an object can vary, for instance either the object is instantiated or not.\nThe primitive types don't have methods callable on them.\nA primitive type can't be inherited.", "subdata": [{"content": "In order to get from class to object, we \"build\" our object by instantiation. Instantiation simply means to create an instance of a class. Instance and object are very similar terms and are sometimes interchangeable, but remember that an instance refers to a specific object, which was created from a class.This instantiation is brought about by one of the class's methods, called a constructor. As its name implies, a constructor builds the object based on the blueprint. Behind the scenes, this means that computer memory is being allocated for the instance, and values are being assigned to the data members.In general there are four constructor types: default, non-default, copy, and cloning.A default constructor will build the most basic instance. Generally, this means assigning all the fields values like null, zero, or an empty string. Nothing would stop you, however, from setting the color of your default sports car color to red, but this is generally bad programming style. Another programmer would be confused if your basic car came out red instead of say, colorless.Code section 3.79: A default constructor.\n\n\n1 SportsCar car = new SportsCar();A non-default constructor is designed to create an object instance with prescribed values for most, if not all, of the object's fields. The car is red, goes from 0-60 in 12 seconds, tops out at 190mph, etc.Code section 3.80: A non-default constructor.\n\n\n1 SportsCar car = new SportsCar(\"red\", 12, 190);A copy constructor is not included in the Java language, however one can easily create a constructor that does the same as a copy constructor. It's important to understand what it is. As the name implies, a copy constructor creates a new instance to be a duplicate of an already existing one. In Java, this can be also accomplished by creating the instance with the default constructor, and then using the assignment operator to equivocate them. This is not possible in all languages though, so just keep the terminology under your belt.Java has the concept of cloning an object, and the end results are similar to the copy constructor. Cloning an object is faster than creation with the new keyword, because all the object memory is copied at once to the destination cloned object. This is possible by implementing the Cloneable interface, which allows the method Object.clone() to perform a field-by-field copy.Code section 3.81: Cloning object.\n\n\n1 SportsCar car = oldCar.clone();", "title": "Instantiation and constructors[edit]"}, {"content": "When an object is created, a reference to the object is also created. The object can not be accessed directly in Java, only through this object reference. This object reference has a type assigned to it. We need this type when passing the object reference to a method as a parameter. Java does strong type checking.Type is basically a list of features/operations, that can be performed through that object reference. The object reference type is basically a contract that guarantees that those operations will be there at run time.When a car is created, it comes with a list of features/operations listed in the user manual that guarantees that those will be there when the car is used.When you create an object from a class by default its type is the same as its class. It means that all the features/operations the class defined are there and available, and can be used. See below:Code section 3.82: Default type.\n\n\n1 (new ClassName()).operations();You can assign this to a variable having the same type as the class:Code section 3.83: A variable having the same type as the class.\n\n\n1 ClassName objRefVariable = new ClassName();\n2 objRefVariable.operations();You can assign the created object reference to the class, super class, or to an interface the class implements:Code section 3.84: Using the super class.\n\n\n1 SuperClass objectRef = new ClassName(); // features/operations list are defined by the SuperClass class\n2 ...\n3 Interface inter = new ClassName(); // features/operations list are defined by the interfaceIn the car analogy, the created car may have different Types of drivers. We create separate user manuals for them, an Average user manual, a Power user manual, a Child user manual, or a Handicapped user manual. Each type of user manual describes only those features/operations appropriate for the type of driver. For instance, the Power driver may have additional gears to switch to higher speeds, that are not available to other type of users...When the car key is passed from an adult to a child we are replacing the user manuals, that is called Type Casting.In Java, casts can occur in three ways:up casting going up in the inheritance tree, until we reach the Object\nup casting to an interface the class implements\ndown casting until we reach the class the object was created from", "title": "Type[edit]"}, {"content": "Autoboxing and unboxing, language features since Java 1.5, make the programmer's life much easier when it comes to working with the primitive wrapper types. Consider this code fragment:Code section 3.85: Traditional object creation.\n\n\n1 int age = 23;\n2 Integer ageObject = new Integer(age);Primitive wrapper objects were Java's way of allowing one to treat primitive data types as though they were objects. Consequently, one was expected to wrap one's primitive data type with the corresponding primitive wrapper object, as shown above.Since Java 1.5, one may write as below and the compiler will automatically create the wrap object. The extra step of wrapping the primitive is no longer required. It has been automatically boxed up on your behalf:Code section 3.86: Autoboxing.\n\n\n1 int age = 23;\n2 Integer ageObject = age;Keep in mind that the compiler still creates the missing wrapper code, so one doesn't really gain anything performance-wise. Consider this feature a programmer convenience, not a performance booster.Each primitive type has a class wrapper:Primitive type\nClass wrapper\n\n\nbyte\njava.lang.Byte\n\n\nchar\njava.lang.Character\n\n\nshort\njava.lang.Short\n\n\nint\njava.lang.Integer\n\n\nlong\njava.lang.Long\n\n\nfloat\njava.lang.Float\n\n\ndouble\njava.lang.Double\n\n\nboolean\njava.lang.Boolean\n\n\nvoid\njava.lang.VoidUnboxing uses the same process in reverse. Study the following code for a moment. The if statement requires a boolean primitive value, yet it was given a Boolean wrapper object. No problem! Java 1.5 will automatically unbox this.Code section 3.87: Unboxing.\n\n\n1 Boolean canMove = new Boolean(true);\n2  \n3 if (canMove) {\n4   System.out.println(\"This code is legal in Java 1.5\");\n5 }Test your knowledge\n\nQuestion 3.11: Consider the following code:\n\n\n\nQuestion 3.11: Autoboxing/unboxing.\n\n\n5 Integer a = 10;\n6 Integer b = a + 2;\n7 System.out.println(b);\n\n\n\n\nHow many autoboxings and unboxings are there in this code?\n\nAnswer\n\n\n\n\nAnswer 3.11: Autoboxing/unboxing.\n\n\n1 Integer a = 10;\n2 Integer b = a + 2;\n3 System.out.println(b);\n\n\n\n\n3\n\n1 autoboxing at line 1 to assign.\n1 unboxing at line 2 to do the addition.\n1 autoboxing at line 2 to assign.\nNo autoboxing nor unboxing at line 3 as println() supports the Integer class as parameter.", "title": "Autoboxing/unboxing[edit]"}], "title": "Classes, Objects and Types"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Packages", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsIf your application becomes quite big, you may have lots of classes. Although you can browse them in their alphabetic order, it becomes confusing. So your application classes can be sorted into packages.A package is a name space that mainly contains classes and interfaces. For instance, the standard class ArrayList is in the package java.util. For this class, java.util.ArrayList is called its fully qualified name because this syntax has no ambiguity. Classes in different packages can have the same name. For example, you have the two classes java.util.Date and java.sql.Date which are not the same. If no package is declared in a class, its package is the default package.", "subdata": [{"content": "In a class, a package is declared at the top of the source code using the keyword package:Code listing 3.14: BusinessClass.java\n\n\n1 package business;\n2 \n3 public class BusinessClass {\n4 }If your class is declared in a package, say business, your class must be placed in a subfolder called business from the root of your application folder. This is how the compiler and the class loader find the Java files on the file system. You can declare your class in a subpackage, say engine. So the full package is business.engine and the class must be placed in a subsubfolder called engine in the subfolder business (not in a folder called business.engine).", "title": "Package declaration[edit]"}, {"content": "The simpliest way to use a class declared in a package is to prefix the class name with its package:Code section 3.88: Package declaration.\n\n\n1 business.BusinessClass myBusinessClass = new business.BusinessClass();If you are using the class from a class in the same package, you don't have to specify the package. If another class with the same name exists in another package, it will use the local class.The syntax above is a bit verbose. You can import the class by using the import Java keyword at the top of the file and then only specify its name:Code listing 3.15: MyClass.java\n\n\n1 import business.BusinessClass;\n2 \n3 public class MyClass {\n4   public static void main(String[] args) {\n5     BusinessClass myBusinessClass = new BusinessClass();\n6   }\n7 }Note that you can't import two classes with the same name in two different packages.The classes Integer and String belongs to the package java.lang but they don't need to be imported as the java.lang package is implicitly imported in all classes.", "title": "Import and class usage[edit]"}, {"content": "It is possible to import an entire package, using an asterisk:Code section 3.89: Wildcard imports.\n\n\n1 import javax.swing.*;While it may seem convenient, it may cause problems if you make a typographical error. For example, if you use the above import to use JFrame, but then type JFraim frame = new JFraim();, the Java compiler will report an error similar to \"Cannot find symbol: JFraim\". Even though it seems as if it was imported, the compiler is giving the error report at the first mention of JFraim, which is half-way through your code, instead of the point where you imported JFrame along with everything else in javax.swing.If you change this to import javax.swing.JFraim; the error will be at the import instead of within your code.Furthermore, if you import javax.swing.*; and import java.util.*;, and javax.swing.Queue is later added in a future version of Java, your code that uses Queue (java.util) will fail to compile. This particular example is fairly unlikely, but if you are working with non-Oracle libraries, it may be more likely to happen.", "title": "Wildcard imports[edit]"}, {"content": "A package name should start with a lower character. This eases to distinguish a package from a class name. In some operating systems, the directory names are not case sensitive. So package names should be lowercase.The Java package needs to be unique across Vendors to avoid name collisions. For that reason Vendors usually use their domain name in reverse order. That is guaranteed to be unique. For example a company called Your Company Inc., would use a package name something like this: com.yourcompany.yourapplicationname.yourmodule.YourClass.", "title": "Package convention[edit]"}, {"content": "If you are importing library packages and classes that reside in a .jar file, you must ensure that the file is in the current classpath (both at compile- and execution-time). Apart from this requirement, importing these packages and classes is the same as if they were in their full, expanded, directory structure.Javac[edit]For example, to compile and run a class from a project's top directory (that contains the two directories /source and /libraries) you could use the following command:Compilation\n\n$ javac -classpath libraries/lib.jar source/MainClass.javaAnd then to run it, similarly:Execution\n\n$ java -classpath libraries/lib.jar source/MainClassThe above is simplified, and demands that MainClass be in the default package, or a package called source, which isn't very desirable.BlueJ[edit]With BlueJ just click on Tools, Preferences, Libraries, and add the .jar one by one.", "title": "Importing packages from .jar files[edit]"}], "title": "Packages"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Arrays", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsAn array is similar to a table of objects or primitive types, keyed by index. You may have noticed the strange parameter of the default main() method (String[] args) since the beginning of the book. It is an array. Let's handle this parameter:Code listing 3.15: The default array parameter.\n\n\n1 public class ArrayExample {\n2   public static void main(String[] args) {\n3     for (int i = 0; i < args.length; ++i) {\n4       System.out.println(\"Argument #\" + (i + 1) + \": \" + args[i]);\n5     }\n6   }\n7 }\n\n\n\n\n\n\n\n\n\nConsole for Code listing 3.15\n\n$ java ArrayExample This is a test\nArgument #1 This\nArgument #2 is\nArgument #3 a\nArgument #4 testIn the code listing 3.15, the array is args. It is an array of String objects (here those objects are the words that have been typed by the user at the program launching). At line 4, One contained object is accessed using its index in the array. You can see that its value is printed on the standard output. Note that the strings have been put in the array with the right order.", "subdata": [{"content": "In Java, an array is an object. This object has a given type for the contained primitive types or objects (int, char, String, ...). An array can be declared in several ways:Code section 3.52: Array declarations.\n\n\n1 int[] array1 = null;\n2 int array2[] = null;Those syntaxes are identical but the first one is recommended. It can also be instantiated in several ways:Code section 3.53: Array instantiations.\n\n\n1 array1 = new int[10];\n2 int[] array0 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //this only works in the declaration\n3 array1 = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};At line 1, we instantiate an array of 10 items that get the default value (which is 0 for int). At lines 2 and 3, we instantiate arrays of 10 given items. It will each be given an index according to its order. We can know the size of the array using the length attribute:Code section 3.54: The array size.\n\n\n1 int nbItems = 10;\n2 Object[] array3 = new Object[nbItems];\n3 System.out.println(array3.length);\n\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.54\n\n10Arrays are allocated at runtime, so the specified size in an array creation expression may be a variable (rather than a constant expression as in C). However, the size of an instantiated array never changes. If you need to change the size, you have to create a new instance. Items can be accessed by their index. Beware! The first index is 0:Code section 3.55: The array indexes.\n\n\n1 char[] array4 = {'a', 'b', 'c', 'd', 'e'};\n2 System.out.println(array4[2]);\n3 array4[4] = 'z';\n4 System.out.println(array4[4]);\n\n\n\n\n\n\n\n\n\n\nOutput for Code section 3.55\n\nc\nzIf you attempt to access to a too high index or negative index, you will get an ArrayIndexOutOfBoundsException.Test your knowledge\n\nQuestion 3.20: Consider the following code:\n\n\n\nQuestion 3.20: Question20.java\n\n\n1 public class Question20 {\n2   public static void main(String[] args) {\n3     String[] listOfWord = {\"beggars\", \"can't\", \"be\", \"choosers\"};\n4     System.out.println(listOfWord[1]);\n5     System.out.println(listOfWord[listOfWord.length-1]);\n6   }\n7 }\n\n\n\n\nWhat will be printed in the standard output?\n\nAnswer\n\n\n\n\nOutput for Question 3.20\n\ncan't\nchoosers\n\n\n\nIndexes start at 0. So the index 1 point at the second string (can't). There are 4 items so the size of the array is 4. Hence the item pointed by the index 3 is the last one (choosers).", "title": "Fundamentals[edit]"}, {"content": "Actually, there are no two-dimensional arrays in Java. However, an array can contain any class of object, including an array:Code section 3.56: Two-dimensional arrays.\n\n\n1 String[][] twoDimArray = {{\"a\", \"b\", \"c\", \"d\", \"e\"},\n2                           {\"f\", \"g\", \"h\", \"i\", \"j\"},\n3                           {\"k\", \"l\", \"m\", \"n\", \"o\"}};\n4 \n5 int[][] twoDimIntArray = {{ 0,  1,  2,  3,  4},\n6                           {10, 11, 12, 13, 14},\n7                           {20, 21, 22, 23, 24}};It's not exactly equivalent to two-dimensional arrays because the size of the sub-arrays may vary. The sub-array reference can even be null. Consider:Code section 3.57: Weird two-dimensional array.\n\n\n1 String[][] weirdTwoDimArray = {{\"10\", \"11\", \"12\"},\n2                                null,\n3                                {\"20\", \"21\", \"22\", \"23\", \"24\"}};Note that the length of a two-dimensional array is the number of one-dimensional arrays it contains. In the above example, weirdTwoDimArray.length is 3, whereas weirdTwoDimArray[2].length is 5.In the code section 3.58, we defined an array that has three elements, each element contains an array having 5 elements. We could create the array having the 5 elements first and use that one in the initialize block.Code section 3.58: Included array.\n\n\n1 String[] oneDimArray = {\"00\", \"01\", \"02\", \"03\", \"04\"};\n2 String[][] twoDimArray = {oneDimArray,\n3                           {\"10\", \"11\", \"12\", \"13\", \"14\"},\n4                           {\"20\", \"21\", \"22\", \"23\", \"24\"}};Test your knowledge\n\nQuestion 3.21: Consider the following code:\n\n\n\nQuestion 3.21: The alphabet.\n\n\n1 String[][] alphabet = {{\"a\", \"b\", \"c\", \"d\", \"e\"},\n2                           {\"f\", \"g\", \"h\", \"i\", \"j\"},\n3                           {\"k\", \"l\", \"m\", \"n\", \"o\"},\n4                           {\"p\", \"q\", \"r\", \"s\", \"t\"},\n5                           {\"u\", \"v\", \"w\", \"x\", \"y\"},\n6                           {\"z\"}};\n\n\n\n\nPrint the whole alphabet in the standard output.\n\nAnswer\n\n\n\n\nQuestion 3.21: Answer21.java\n\n\n 1 public class Answer21 {\n 2   public static void main(String[] args) {\n 3     String[][] alphabet = {{\"a\", \"b\", \"c\", \"d\", \"e\"},\n 4                           {\"f\", \"g\", \"h\", \"i\", \"j\"},\n 5                           {\"k\", \"l\", \"m\", \"n\", \"o\"},\n 6                           {\"p\", \"q\", \"r\", \"s\", \"t\"},\n 7                           {\"u\", \"v\", \"w\", \"x\", \"y\"},\n 8                           {\"z\"}};\n 9 \n10     for (int i = 0; i < alphabet.length; i++) {\n11       for (int j = 0; j < alphabet[i].length; j++) {\n12         System.out.println(alphabet[i][j]);\n13       }\n14     }\n15   }\n16 }\n\n\n\n\ni will be the indexes of the main array and j will be the indexes of all the sub-arrays. We have to first iterate on the main array. We have to read the size of the array. Then we iterate on each sub-array. We have to read the size of each array as it may vary. Doing so, we iterate on all the sub-array items using the indexes. All the items will be read in the right order.", "title": "Two-Dimensional Arrays[edit]"}], "title": "Arrays"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Mathematical_functions", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsThe java.lang.Math class allows the use of many common mathematical functions that can be used while creating programs.Since it is in the java.lang package, the Math class does not need to be imported. However, in programs extensively utilizing these functions, a static import can be used.", "subdata": [{"content": "There are two constants in the Math class that are fairly accurate approximations of irrational mathematical numbers.Math.E[edit]The Math.E constant represents the value of Euler's number (e), the base of the natural logarithm.Code section 3.20: Math.E\n\n\n1 public static final double E = 2.718281828459045;Math.PI[edit]The Math.PI constant represents the value of pi, the ratio of a circle's circumference to its diameter.Code section 3.21: Math.PI\n\n\n1 public static final double PI = 3.141592653589793;", "title": "Math constants[edit]"}, {"content": "Exponential methods[edit]There are several methods in the Math class that deal with exponential functions.Exponentiation[edit]The power method, double Math.pow(double, double), returns the first parameter to the power of the second parameter. For example, a call to Math.pow(2, 10) will return a value of 1024 (210).The Math.exp(double) method, a special case of pow, returns e to the power of the parameter. In addition, double Math.expm1(double) returns (ex - 1). Both of these methods are more accurate and convenient in these special cases.Java also provides special cases of the pow function for square roots and cube roots of doubles, double Math.sqrt(double) and double Math.cbrt(double).Logarithms[edit]Java has no general logarithm function; when needed this can be simulated using the change-of-base theorem.double Math.log(double) returns the natural logarithm of the parameter (not the common logarithm, as its name suggests!).double Math.log10(double) returns the common (base-10) logarithm of the parameter.double Math.log1p(double) returns ln(parameter+1). It is recommended for small values.Trigonometric and hyperbolic methods[edit]The trigonometric methods of the Math class allow users to easily deal with trigonometric functions in programs. All accept only doubles. Please note that all values using these methods are initially passed and returned in radians, not degrees. However, conversions are possible.Trigonometric functions[edit]The three main trigonometric methods are Math.sin(x), Math.cos(x), and Math.tan(x), which are used to find the sine, cosine, and tangent, respectively, of any given number. So, for example, a call to Math.sin(Math.PI/2) would return a value of about 1. Although methods for finding the cosecant, secant, and cotangent are not available, these values can be found by taking the reciprocal of the sine, cosine, and tangent, respectively. For example, the cosecant of pi/2 could be found using 1/Math.sin(Math.PI/2).Inverse trigonometric functions[edit]Java provides inverse counterparts to the trigonometric functions: Math.asin(x), and Math.acos(x), Math.atan(x).Hyperbolic functions[edit]In addition, hyperbolic functions are available: Math.sinh(x), Math.cosh(x), and Math.tanh(x).Radian/degree conversion[edit]To convert between degree and radian measures of angles, two methods are available, Math.toRadians(x) and Math.toDegrees(x). While using Math.toRadians(x), a degrees value must be passed in, and that value in radians (the degree value multiplied by pi/180) will be returned. The Math.toDegrees(x) method takes in a value in radians and the value in degrees (the radian value multiplied by 180/pi) is returned.Absolute value: Math.abs[edit]The absolute value method of the Math class is compatible with the int, long, float, and double types. The data returned is the absolute value of parameter (how far away it is from zero) in the same data type. For example:Code section 3.22: Math.abs\n\n\n1 int result = Math.abs(-3);In this example, result will contain a value of 3.Maximum and minimum values[edit]These methods are very simple comparing functions. Instead of using if...else statements, one can use the Math.max(x1, x2) and Math.min(x1, x2) methods. The Math.max(x1, x2) simply returns the greater of the two values, while the Math.min(x1, x2) returns the lesser of the two. Acceptable types for these methods include int, long, float, and double.", "title": "Math methods[edit]"}, {"content": "Java 1.5 and 1.6 introduced several non-mathematical functions specific to the computer floating-point representation of numbers.Math.ulp(double) and Math.ulp(float) return an ulp, the smallest value which, when added to the argument, would be recognized as larger than the argument.Math.copySign returns the value of the first argument with the sign of the second argument. It can be used to determine the sign of a zero value.Math.getExponent returns (as an int) the exponent used to scale the floating-point argument in computer representation.", "title": "Functions dealing with floating-point representation[edit]"}], "title": "Mathematical functions"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Large_numbers", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsThe integer primitive type with the largest range of value is the long, from -263 to 263-1. If you need greater or lesser values, you have to use the BigInteger class in the package java.math. A BigInteger object can represent any integer (as large as the RAM on the computer can hold) as it is not mapped on a primitive type. Respectively, you need to use the BigDecimal class for great decimal numbers.However, as these perform much slower than primitive types, it is recommended to use primitive types when it is possible.", "subdata": [{"content": "The BigInteger class represents integers of almost any size. As with other objects, they need to be constructed. Unlike regular numbers, the BigInteger represents an immutable object - methods in use by the BigInteger class will return a new copy of a BigInteger.To instantiate a BigInteger, you can create it from either byte array, or from a string. For example:Code section 3.23: 1 quintillion, or 10^18. Too large to fit in a long.\n\n\n1 BigInteger i = new BigInteger(\"1000000000000000000\");BigInteger cannot use the normal Java operators. They use the methods provided by the class.Code section 3.24: Multiplications and an addition.\n\n\n1 BigInteger a = new BigInteger(\"3\");\n2 BigInteger b = new BigInteger(\"4\");\n3 \n4 // c = a^2 + b^2\n5 BigInteger c = a.multiply(a).add(b.multiply(b));It is possible to convert to a long, but the long may not be large enough.Code section 3.25: Conversion.\n\n\n1 BigInteger aBigInteger = new BigInteger(\"3\");\n2 long aLong = aBigInteger.longValue();", "title": "BigInteger[edit]"}], "title": "Large numbers"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Random_numbers", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsTo generate random numbers the Math.random() method can be used, which returns a double, greater than or equal to 0.0 and less than 1.0.The following code returns a random integer between n and m (where n <= randomNumber < m):Code section 3.30: A random integer.\n\n\n1   int randomNumber = n + (int)(Math.random() * ( m - n ));Alternatively, the java.util.Random class provides methods for generating random booleans, bytes, floats, ints, longs and 'Gaussians' (doubles from a normal distribution with mean 0.0 and standard deviation 1.0). For example, the following code is equivalent to that above:Code section 3.31: A random integer with Gaussian.\n\n\n1   Random random = new Random();\n2   int randomNumber = n + random.nextInt(m - n);As an example using random numbers, we can make a program that uses a Random object to simulate flipping a coin 20 times:Code listing 3.25: CoinFlipper.java\n\n\n 1 import java.util.Random;\n 2 \n 3 public class CoinFlipper {\n 4 \n 5   public static void main(String[] args) {\n 6     // The number of times to flip the coin\n 7     final int TIMES_TO_FLIP = 20;\n 8     int heads = 0;\n 9     int tails = 0;\n10     // Create a Random object\n11     Random random = new Random();\n12     for (int i = 0; i < TIMES_TO_FLIP; i++) {\n13       // 0 or 1\n14       int result = random.nextInt(2);\n15       if (result == 1) {\n16         System.out.println(\"Heads\");\n17         heads++;\n18       } else {\n19         System.out.println(\"Tails\");\n20         tails++;\n21       }\n22     }\n23     System.out.println(\"There were \"\n24             + heads\n25             + \" heads and \"\n26             + tails\n27             + \" tails\");\n28   }\n29 }\n\n\n\n\n\n\n\n\n\nPossible output for code listing 3.25\n\nHeads\nTails\nTails\nTails\nHeads\nTails\nHeads\nHeads\nHeads\nHeads\nHeads\nHeads\nTails\nTails\nTails\nTails\nHeads\nTails\nTails\nTails\nThere were 9 heads and 11 tailsOf course, if you run the program you will probably get different results.", "subdata": [], "title": "Random numbers"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Unicode", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsMost Java program text consists of ASCII characters, but any Unicode character can be used as part of identifier names, in comments, and in character and string literals. For example,  (which is the Greek Lowercase Letter pi) is a valid Java identifier:Code section 3.100: Pi.\n\n\n1 double  = Math.PI;and in a string literal:Code section 3.101: Pi literal.\n\n\n1 String pi = \"\";", "subdata": [{"content": "Unicode characters can also be expressed through Unicode Escape Sequences. Unicode escape sequences may appear anywhere in a Java source file (including inside identifiers, comments, and string literals).Unicode escape sequences consist ofa backslash '\\' (ASCII character 92, hex 0x5c),\na 'u' (ASCII 117, hex 0x75)\noptionally one or more additional 'u' characters, and\nfour hexadecimal digits (the characters '0' through '9' or 'a' through 'f' or 'A' through 'F').Such sequences represent the UTF-16 encoding of a Unicode character. For example, 'a' is equivalent to '\\u0061'. This escape method does not support characters beyond U+FFFF or you have to make use of surrogate pairs.[1]Any and all characters in a program may be expressed in Unicode escape characters, but such programs are not very readable, except by the Java compiler - in addition, they are not very compact.One can find a full list of the characters here.may also be represented in Java as the Unicode escape sequence \\u03C0. Thus, the following is a valid, but not very readable, declaration and assignment:Code section 3.102: Unicode escape sequences for Pi.\n\n\n1 double \\u03C0 = Math.PI;The following demonstrates the use of Unicode escape sequences in other Java syntax:Code section 3.103: Unicode escape sequences in a string literal.\n\n\n1 // Declare Strings pi and quote which contain \\u03C0 and \\u0027 respectively:\n2 String pi = \"\\u03C0\";\n3 String quote = \"\\u0027\";Note that a Unicode escape sequence functions just like any other character in the source code. E.g., \\u0022 (double quote, \") needs to be quoted in a string just like \".Code section 3.104: Double quote.\n\n\n1 // Declare Strings doubleQuote1 and doubleQuote2 which both contain \" (double quote):\n2 String doubleQuote1 = \"\\\"\";\n3 String doubleQuote2 = \"\\\\u0022\"; // \"\\u0022\" doesn't work since \"\"\" doesn't work.", "title": "Unicode escape sequences[edit]"}, {"content": "The language distinguishes between bytes and characters. Characters are stored internally using UCS-2, although as of J2SE 5.0, the language also supports using UTF-16 and its surrogates. Java program source may therefore contain any Unicode character.The following is thus perfectly valid Java code; it contains Chinese characters in the class and variable names as well as in a string literal:Code listing 3.50: .java\n\n\n1 public class  {\n2     private String  = \"\";\n3 }", "title": "International language support[edit]"}], "title": "Unicode"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Comments", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsA comment allows to insert text that will not be compiled nor interpreted. It can appear anywhere in the source code where whitespaces are allowed.It is useful for explaining what the source code does by:explaining the adopted technical choice: why this given algorithm and not another, why calling this given method...\nexplaining what should be done in the next steps (the TODO list): improvement, issue to fix...\ngiving the required explanation to understand the code and be able to update it yourself later or by other developers.It can also be used to make the compiler ignore a portion of code: temporary code for debugging, code under development...", "subdata": [{"content": "The comments in Java use the same syntax as in C++.An end-of-line comment starts with two slashes and ends with the end of the line. This syntax can be used on a single line too.Code section 3.105: Slash-slash comment.\n\n\n1 // A comment to give an example\n2 \n3 int n = 10; // 10 articlesA comment on several lines is framed with '/' + '*' and '*' + '/'.Code section 3.106: Slash-star comment in multiple lines.\n\n\n 1 /*\n 2  * This is a comment\n 3  * on several lines.\n 4  */\n 5 \n 6 /* This also works; slash-star comments may be on a single line. */\n 7 \n 8 /*\n 9 Disable debugging code:\n10 \n11 int a = 10;\n12 while (a-- > 0) System.out.println(\"DEBUG: tab[\"+a+\"]=\" + tab[a]);\n13 */By convention, subsequent lines of slash-star comments begin with a star aligned under the star in the open comment sequence, but this is not required. Never nest a slash-star comment in another slash-star comment. If you accidentally nest such comments, you will probably get a syntax error from the compiler soon after the first star-slash sequence.Code section 3.107: Nested slash-star comment.\n\n\n1 /* This comment appears to contain /* a nested comment. */\n2  * The comment ends after the first star-slash and\n3  * everything after the star-slash sequence is parsed\n4  * as non-comment source.\n5  */If you need to have the sequence */ inside a comment you can use html numeric entities: *&#47;.Slash-star comments may also be placed between any Java tokens, though not recommended:Code section 3.108: Inline slash-star comment.\n\n\n1 int i = /* maximum integer */ Integer.MAX_VALUE;However, comments are not parsed as comments when they occur in string literals.Code section 3.109: String literal.\n\n\n1 String text = \"/* This is not a comment. */\";It results in a 33 character string.Test your knowledge\n\nQuestion 3.26: Consider the following code:\n\n\n\nQuestion 3.26: Commented code.\n\nint a = 0;\n// a = a + 1;\na = a + 1;\n/*\na = a + 1;\n*/\na = a + 1;\n// /*\na = a + 1;\n// */\na = a /*+ 1*/;\na = a + 1; // a = a + 1;\nSystem.out.println(\"a=\" + a);\n\n\n\nWhat is printed in the standard output?\n\nAnswer\n\n\n\n\nOutput for Answer 3.26\n\na=4\n\n\n\n\n\n\nAnswer 3.26: Commented code.\n\n\n 1 int a = 0;\n 2 // a = a + 1;\n 3 a = a + 1;\n 4 /*\n 5 a = a + 1;\n 6 */\n 7 a = a + 1;\n 8 // /*\n 9 a = a + 1;\n10 // */\n11 a = a /*+ 1*/;\n12 a = a + 1; // a = a + 1;\n13 System.out.println(\"a=\" + a);\n\n\n\n\n\nThe highlighted lines are code lines but line 11 does nothing and only the first part of line 12 is code.", "title": "Syntax[edit]"}, {"content": "Be aware that Java still interprets Unicode sequences within comments. For example, the Unicode sequence \\u002a\\u002f (whose codepoints correspond to */) is processed early in the Java compiler's lexical scanning of the source file, even before comments are processed, so this is a valid star-slash comment in Java:Code section 3.110: Unicode sequence interruption.\n\n\n1 /* This is a comment. \\u002a\\u002f\n2 String statement = \"This is not a comment.\";and is lexically equivalent toCode section 3.111: Unicode sequence interruption effect.\n\n\n1 /* This is a comment. */\n2 String statement = \"This is not a comment.\";(The '*' character is Unicode 002A and the '/' character is Unicode 002F.)Similar caveats apply to newline characters in slash-slash comments.For example:Code section 3.112: New line.\n\n\n1 // This is a single line comment \\u000a This is codeThat is because \\u000a is Unicode for a new line, making the compiler think that you have added a new line when you haven't.", "title": "Comments and unicode[edit]"}], "title": "Comments"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Keywords", "content": "Navigate Language Fundamentals topic: (vde)\n\n Statements\n Conditional blocks\n Loop blocks\n Boolean expressions\n Variables\n Primitive Types\n Arithmetic expressions\n Literals\n Methods\n String\n Objects\n Packages\n Arrays\n Mathematical functions\n Large numbers\n Random numbers\n Unicode\n Comments\n Keywords\n Coding conventionsKeywords are special tokens in the language which have reserved use in the language. Keywords may not be used as identifiers in Java  you cannot declare a field whose name is a keyword, for instance.Examples of keywords are the primitive types, int and boolean; the control flow statements for and if; access modifiers such as public, and special words which mark the declaration and definition of Java classes, packages, and interfaces: class, package, interface.Below are all the Java language keywords:abstract\nassert (since Java 1.4)\nboolean\nbreak\nbyte\ncase\ncatch\nchar\nclass\nconst (not used)\ncontinue\ndefault\ndo\ndouble\nelse\nenum (since Java 5.0)\nextends\nfinal\nfinally\nfloat\nfor\ngoto (not used)\nif\nimplements\nimport\ninstanceof\nint\ninterface\nlong\nnative\nnew\npackage\nprivate\nprotected\npublic\nreturn\nshort\nstatic\nstrictfp (since Java 1.2)\nsuper\nswitch\nsynchronized\nthis\nthrow\nthrows\ntransient\ntry\nvoid\nvolatile\nwhileContents\n\n\n1 abstract\n2 assert\n3 boolean\n4 break\n5 byte\n6 case\n7 catch\n8 char\n9 class\n10 const\n11 continue\n12 See also\n13 default\n14 do\n15 double\n16 else\n17 enum\n18 extends\n19 final\n20 For a variable\n21 For a class\n22 For a method\n23 Interest\n24 finally\n25 float\n26 for\n27 goto\n28 if\n29 implements\n30 import\n31 instanceof\n32 int\n33 interface\n34 long\n35 native\n36 See also\n37 new\n38 package\n39 private\n40 protected\n41 public\n42 return\n43 short\n44 static\n45 Interest\n46 strictfp\n47 super\n48 switch\n49 synchronized\n50 Singleton example\n51 this\n52 throw\n53 See also\n54 throws\n55 transient\n56 try\n57 void\n58 volatile\n59 whileIn addition, the identifiers null, true, and false denote literal values and may not be used to create identifiers.", "subdata": [{"content": "abstract is a Java keyword. It can be applied to a class and methods. An abstract class cannot be directly instantiated. It must be placed before the variable type or the method return type. It is recommended to place it after the access modifier and after the static keyword. A non-abstract class is a concrete class. An abstract class cannot be final.Only an abstract class can have abstract methods. An abstract method is only declared, not implemented:Code listing 1: AbstractClass.java\n\n\n1 public abstract class AbstractClass {\n2     // This method does not have a body; it is abstract.\n3     public abstract void abstractMethod();\n4  \n5     // This method does have a body; it is implemented in the abstract class and gives a default behavior.\n6     public void concreteMethod() {\n7         System.out.println(\"Already coded.\");\n8     }\n9 }An abstract method cannot be final, static nor native. Either you instantiate a concrete sub-class, either you instantiate the abstract class by implementing its abstract methods alongside a new statement:Code section 1: Abstract class use.\n\n\n1 AbstractClass myInstance = new AbstractClass() {\n2     public void abstractMethod() {\n3         System.out.println(\"Implementation.\");\n4     }\n5 };A private method cannot be abstract.", "title": "abstract[edit]"}, {"content": "assert is a Java keyword used to define an assert statement. An assert statement is used to declare an expected boolean condition in a program. If the program is running with assertions enabled, then the condition is checked at runtime. If the condition is false, the Java runtime system throws an AssertionError.Assertions may be declared using the following syntax:assert expression1 [: expression2];expression1 is a boolean that will throw the assertion if it is false. When it is thrown, the assertion error exception is created with the parameter expression2 (if applicable).An example:assert list != null && list.size() > 0 : \"list variable is null or empty\";\nObject value = list.get(0);Assertions are usually used as a debugging aid. They should not be used instead of validating arguments to public methods, or in place of a more precise runtime error exception.Assertions are enabled with the Java -ea or -enableassertions runtime option. See your Java environment documentation for additional options for controlling assertions.", "title": "assert[edit]"}, {"content": "boolean is a keyword which designates the boolean primitive type. There are only two possible boolean values: true and false. The default value for boolean fields is false.The following is a declaration of a private boolean field named initialized, and its use in a method named synchronizeConnection.Code section 1: Connection synchronization.\n\n\n1 private boolean initialized = false;\n2 \n3 public void synchronizeConnection() {\n4    if (!initialized) {\n5       connection = connect();\n6       initialized = true;\n7    }\n8 }The previous code only creates a connection once (at the first method call). Note that there is no automatic conversion between integer types (such as int) to boolean as is possible in some languages like C. Instead, one must use an equivalent expression such as (i!= 0) which evaluates to true if i is not zero.", "title": "boolean[edit]"}, {"content": "break is a Java keyword.Jumps (breaks) out from a loop. Also used at switch statement.For example:for ( int i=0; i < maxLoopIter; i++ ) {\n   System.out.println(\"Iter=\" +i);\n   if ( i == 5 ) {\n      break;  // -- 5 iteration is enough --\n   }\n}See also:Java Programming/Keywords/switch", "title": "break[edit]"}, {"content": "byte is a keyword which designates the 8 bit signed integer primitive type.The java.lang.Byte class is the nominal wrapper class when you need to store a byte value but an object reference is required.Syntax:byte <variable-name> = <integer-value>;For example:byte b = 65;orbyte b = 'A'The number 65 is the code for 'A' in ASCII.See also:Java Programming/Primitive Types", "title": "byte[edit]"}, {"content": "case is a Java keyword.This is part of the switch statement, to find if the value passed to the switch statement matches a value followed by case.For example:int i = 3;\nswitch(i) {\ncase 1:\n   System.out.println(\"The number is 1.\");\n   break;\ncase 2:\n   System.out.println(\"The number is 2.\");\n   break;\ncase 3:\n   System.out.println(\"The number is 3.\"); // this line will print\n   break;\ncase 4:\n   System.out.println(\"The number is 4.\");\n   break;\ncase 5:\n   System.out.println(\"The number is 5.\");\n   break;\ndefault:\n  System.out.println(\"The number is not 1, 2, 3, 4, or 5.\");\n}", "title": "case[edit]"}, {"content": "catch is a keyword.It's part of a try block. If an exception is thrown inside a try block, the exception will be compared to any of the catch part of the block. If the exception match with one of the exception in the catch part, the exception will be handled there.For example:try {\n   //...\n     throw new MyException_1();\n   //...\n} catch ( MyException_1 e ) {\n   // --- Handle the Exception_1 here --\n} catch ( MyException_2 e ) {\n   // --- Handle the Exception_2 here --\n}See also:Java Programming/Keywords/try", "title": "catch[edit]"}, {"content": "char is a keyword. It defines a character primitive type. char can be created from character literals and numeric representation. Character literals consist of a single quote character (') (ASCII 39, hex 0x27), a single character, and a close quote ('), such as 'w'. Instead of a character, you can also use unicode escape sequences, but there must be exactly one.Syntax:char variable name1 = 'character1';Code section 1: Three examples.\n\n\n1 char oneChar1 = 'A';\n2 char oneChar2 = 65;\n3 char oneChar3 = '\\u0041';\n4 System.out.println(oneChar1);\n5 System.out.println(oneChar2);\n6 System.out.println(oneChar3);\n\n\n\n\n\n\n\n\n\nOutput for Code section 1\n\nA\nA\nA65 is the numeric representation of character 'A' , or its ASCII code.The nominal wrapper class is the java.lang.Character class when you need to store a char value but an object reference is required.Code section 2: char wrapping.\n\n\n1 char aCharPrimitiveType = 'A';\n2 Character aCharacterObject = aCharPrimitiveType;See also:Java Programming/Primitive Types", "title": "char[edit]"}, {"content": "class is a Java keyword which begins the declaration and definition of a class.The general syntax of a class declaration, using Extended Backus-Naur Form, isclass-declaration ::= [access-modifiers] class identifier\n                      [extends-clause] [implements-clause] \n                      class-body\n\nextends-clause ::= extends class-name\nimplements-clause ::= implements interface-names \ninterface-names ::= interface-name [, interface-names]\nclass-body ::= { [member-declarations] }\nmember-declarations = member-declaration [member-declarations]\nmember-declaration = field-declaration \n                     | initializer \n                     | constructor \n                     | method-declaration\n                     | class-declarationThe extends word is optional. If omitted, the class extends the Object class, as all Java classes inherit from it.See also:Java Programming/Keywords/new", "title": "class[edit]"}, {"content": "const is a reserved keyword, presently not being used.In other programming languages, such as C, const is often used to declare a constant. However, in Java, final is used instead.", "title": "const[edit]"}, {"content": "continue is a Java keyword. It skips the remainder of the loop and continues with the next iteration.For example:int maxLoopIter = 7;\n\nfor (int i = 0; i < maxLoopIter; i++ ) {\n   if (i == 5) {\n      continue;  // -- 5 iteration is skipped --\n   }\n   System.println(\"Iteration = \" + i);\n}results in0\n1\n2\n3\n4\n6\n7", "title": "continue[edit]"}, {"content": "Java Programming/Statements", "title": "See also[edit]"}, {"content": "default is a Java keyword.This is an optional part of the switch statement, which only executes if none of the above cases are matched.See also:Java Programming/Keywords/switch", "title": "default[edit]"}, {"content": "do is a Java keyword.It starts a do-while looping block. The do-while loop is functionally similar to the while loop, except the condition is evaluated after the statements executeSyntax:do {\n    //statements;\n} while (condition);For example:do {\n    i++;\n} while ( i < maxLoopIter );See also:Java Programming/Statements\nJava Programming/Keywords/for\nJava Programming/Keywords/while", "title": "do[edit]"}, {"content": "double is a keyword which designates the 64 bit float primitive type.The java.lang.Double class is the nominal wrapper class when you need to store a double value but an object reference is required.Syntax:double <variable-name> = <float-value>;For example:double d = 65.55;See also:Java Programming/Primitive Types", "title": "double[edit]"}, {"content": "else is a Java keyword. It is an optional part of a branching statement. It starts the 'false' statement block.The general syntax of a if, using Extended Backus-Naur Form, isbranching-statement ::= if condition-clause \n                                    single-statement | block-statement\n                       [ else \n                                    single-statement | block-statement ]\n \ncondition-clause    ::= ( Boolean Expression )\nsingle-statement    ::= Statement\nblock-statement     ::= { Statement [ Statement ] }For example:if ( expression ) {\n   System.out.println(\"'True' statement block\");\n} else {\n   System.out.println(\"'False' statement block\");\n}See also:Java Programming/Keywords/if", "title": "else[edit]"}, {"content": "/** Grades of courses */\n  enum Grade { A, B, C, D, F };\n  // ...\n  private Grade gradeA = Grade.A;This enumeration constant then can be passed in to methods:student.assignGrade(gradeA);\n  /**\n   * Assigns the grade for this course to the student\n   * @param GRADE  Grade to be assigned\n   */\n  public void assignGrade(final Grade GRADE) {\n    grade = GRADE;\n  }An enumeration may also have parameters:public enum DayOfWeek {\n  /** Enumeration constants */\n  MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(0);\n\n  /** Code for the days of the week */\n  private byte dayCode = 0;\n\n  /**\n   * Private constructor\n   * @param VALUE  Value that stands for a day of the week.\n   */\n  private DayOfWeek(final byte VALUE) {\n    dayCode = java.lang.Math.abs(VALUE%7);\n  }\n \n  /**\n   * Gets the day code\n   * @return  The day code\n   */\n  public byte getDayCode() {\n    return dayCode;\n  }\n}It is also possible to let an enumeration implement interfaces other than java.lang.Comparable and java.io.Serializable, which are already implicitly implemented by each enumeration:public enum DayOfWeek implements Runnable {\n  MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;\n \n  /**\n   * Run method prints all elements\n   */\n  public void run() {\n    System.out.println(\"name() = \" + name() +\n      \", toString() = \\\"\" + toString() + \"\\\"\");\n  }\n}", "title": "enum[edit]"}, {"content": "extends is a Java keyword.Used in class and interface definition to declare the class or interface that is to be extended.Syntax:public class MyClass extends SuperClass \n{\n  //...\n}\n \npublic interface MyInterface extends SuperInterface\n{\n  //...\n}In Java 1.5 and later, the \"extends\" keyword is also used to specify an upper bound on a type parameter in Generics.class Foo<T extends Number> { /*...*/ }See also:Java Programming/Creating Objects\nJava Programming/Keywords/class", "title": "extends[edit]"}, {"content": "final is a keyword. Beware! It has distinct meanings depending whether it is used for a class, a method, or for a variable. It must be placed before the variable type or the method return type. It is recommended to place it after the access modifier and after the static keyword.Code section 1: Keyword order.\n\n\n1 private static final long serialVersionUID = -5437975414336623381L;", "title": "final[edit]"}, {"content": "The final keyword only allows a single assignment for the variable. That is to say, once the variable has been assigned, its value is in read-only. If the variable is a primitive type, its value will no longer change. If it is an object, only its reference will no longer change. Keep in mind that its value can still be changed.Code section 2: Forbidden double assignment.\n\n\n1 final int a = 1;\n2 a = 2;Code section 3: Only modify the value of the object.\n\n\n1 final ArrayList list = new ArrayList();\n2 System.out.println(list.size());\n3 list.add(\"One item\");\n4 System.out.println(list.size());\n\n\n\n\n\n\n\n\n\nConsole for Code section 3\n\n0\n1A final variable is often used for universal constants, such as pi:Code section 4: Pi constant.\n\n\n1 static final double PI = 3.1415926;The final keyword can also be used for method parameters:Code section 5: Final method parameter.\n\n\n1 public int method(final int inputInteger) {\n2    int outputInteger = inputInteger + 1;\n3    return outputInteger;\n4 }It is useful for methods that use side effects to update some objects. Such methods modify the content of an object passed in parameter. The method caller will recieve the object update. This will fail if the object parameter has been reassigned in the method. Another object will be updated instead. Final method parameter can also be used to keep the code clean.The final keyword is similar to const in other languages and the readonly keyword in C#. A final variable cannot be volatile.", "title": "For a variable[edit]"}, {"content": "The final keyword forbids the creation of a subclass. It is the case of the Integer or String class.Code listing 1: SealedClass.java\n\n\n1 public final class SealedClass {\n2   public static void main(String[] args) {\n3   }\n4 }A final class cannot be abstract. The final keyword is similar to sealed keyword in C#.", "title": "For a class[edit]"}, {"content": "The final keyword forbids to overwrite the method in a subclass. It is useless if the class is already final and a private method is implicitly final. A final method cannot be abstract.Code listing 2: NoOverwriting.java\n\n\n1 public class NoOverwriting {\n2   public final void sealedMethod() {\n3   }\n4 }", "title": "For a method[edit]"}, {"content": "The final keyword is mostly used to guarantee a good usage of the code. For instance (non-static) methods, this allows the compiler to expand the method (similar to an inline function) if the method is small enough. Sometimes it is required to use it. For instance, a nested class can only access the members of the top-level class if they are final.See also Access Modifiers.", "title": "Interest[edit]"}, {"content": "finally is a keyword which is an optional ending part of the try block.Code section 1: try block.\n\n\n1 try {\n2   // ...\n3 } catch (MyException1 e) {\n4   // Handle the Exception1 here\n5 } catch (MyException2 e) {\n6   // Handle the Exception2 here\n7 } finally {\n8   // This will always be executed no matter what happens\n9 }The code inside the finally block will always be executed. This is also true for cases when there is an exception or even executed return statement in the try block.Three things can happen in a try block. First, no exception is thrown:Code section 2: No exception is thrown.\n\n\n 1 System.out.println(\"Before the try block\");\n 2 try {\n 3   System.out.println(\"Inside the try block\");\n 4 } catch (MyException1 e) {\n 5   System.out.println(\"Handle the Exception1\");\n 6 } catch (MyException2 e) {\n 7   System.out.println(\"Handle the Exception2\");\n 8 } finally {\n 9   System.out.println(\"Execute the finally block\");\n10 }\n11 System.out.println(\"Continue\");\n\n\n\n\n\n\n\n\n\n\nConsole for Code section 2\n\nBefore the try block\nInside the try block\nExecute the finally block\nContinueYou can see that we have passed in the try block, then we have executed the finally block and we have continued the execution. Now, a caught exception is thrown:Code section 3: A caught exception is thrown.\n\n\n 1 System.out.println(\"Before the try block\");\n 2 try {\n 3   System.out.println(\"Enter inside the try block\");\n 4   throw new MyException1();\n 5   System.out.println(\"Terminate the try block\");\n 6 } catch (MyException1 e) {\n 7   System.out.println(\"Handle the Exception1\");\n 8 } catch (MyException2 e) {\n 9   System.out.println(\"Handle the Exception2\");\n10 } finally {\n11   System.out.println(\"Execute the finally block\");\n12 }\n13 System.out.println(\"Continue\");\n\n\n\n\n\n\n\n\n\n\nConsole for Code section 3\n\nBefore the try block\nEnter inside the try block\nHandle the Exception1\nExecute the finally block\nContinueWe have passed in the try block until where the exception occurred, then we have executed the matching catch block, the finally block and we have continued the execution. Now, an uncaught exception is thrown:Code section 4: An uncaught exception is thrown.\n\n\n 1 System.out.println(\"Before the try block\");\n 2 try {\n 3   System.out.println(\"Enter inside the try block\");\n 4   throw new Exception();\n 5   System.out.println(\"Terminate the try block\");\n 6 } catch (MyException1 e) {\n 7   System.out.println(\"Handle the Exception1\");\n 8 } catch (MyException2 e) {\n 9   System.out.println(\"Handle the Exception2\");\n10 } finally {\n11   System.out.println(\"Execute the finally block\");\n12 }\n13 System.out.println(\"Continue\");\n\n\n\n\n\n\n\n\n\nConsole for Code section 4\n\nBefore the try block\nEnter inside the try block\nExecute the finally blockWe have passed in the try block until where the exception occurred and we have executed the finally block. NO CODE after the try-catch block has been executed. If there is an exception that happens before the try-catch block, the finally block is not executed.If return statement is used inside finally, it overrides the return statement in the try-catch block. For instance, the constructCode section 5: Return statement.\n\n\n1  try {\n2    return 11;\n3  }  finally {\n4    return 12;\n5  }will return 12, not 11. Professional code almost never contains statements that alter execution order (like return, break, continue) inside the finally block, as such code is more difficult to read and maintain.", "title": "finally[edit]"}, {"content": "float is a keyword which designates the 32 bit float primitive type.The java.lang.Float class is the nominal wrapper class when you need to store a float value but an object reference is required.Syntax:float <variable-name> = <float-value>;For example:float price = 49.95;See also:Java Programming/Primitive Types", "title": "float[edit]"}, {"content": "for is a Java keyword.It starts a looping block.The general syntax of a for, using Extended Backus-Naur Form, isfor-looping-statement ::= for condition-clause \n                                    single-statement | block-statement\n \ncondition-clause    ::= ( before-statement;  Boolean Expression ; after-statement )\nsingle-statement    ::= Statement\nblock-statement     ::= { Statement [ Statement ] }For example:for ( int i=0; i < maxLoopIter; i++ ) {\n    System.println(\"Iter: \" +i);\n}See also:Java Programming/Keywords/while\nJava Programming/Keywords/do", "title": "for[edit]"}, {"content": "goto is a reserved keyword, presently not being used.", "title": "goto[edit]"}, {"content": "if is a Java keyword. It starts a branching statement.The general syntax of a if, using Extended Backus-Naur Form, isbranching-statement ::= if condition-clause \n                                    single-statement | block-statement\n                       [ else \n                                    single-statement | block-statement ]\n \ncondition-clause    ::= ( Boolean Expression )\nsingle-statement    ::= Statement\nblock-statement     ::= { Statement [ Statements ] }For example:if ( boolean Expression )\n{\n   System.out.println(\"'True' statement block\");\n}\nelse\n{\n   System.out.println(\"'False' statement block\");\n}See also:Java Programming/Keywords/else", "title": "if[edit]"}, {"content": "implements is a Java keyword.Used in class definition to declare the Interfaces that are to be implemented by the class.Syntax:public class MyClass implements MyInterface1, MyInterface2\n {\n   ...\n }See also:Java Programming/Creating Objects\nJava Programming/Keywords/class\nJava Programming/Keywords/interface", "title": "implements[edit]"}, {"content": "import is a Java keyword.It declares a Java class to use in the code below the import statement. Once a Java class is declared, then the class name can be used in the code without specifying the package the class belongs to.Use the '*' character to declare all the classes belonging to the package.Syntax:import package.JavaClass;\nimport package.*;The static import construct allows unqualified access to static members without inheriting from the type containing the static members:import static java.lang.Math.PI;Once the static members have been imported, they may be used without qualification:double r = cos(PI * theta);Caveat: use static import very sparingly to avoid polluting the program's namespace!See also:Java Programming/Packages", "title": "import[edit]"}, {"content": "instanceof is a keyword.It checks if an object reference is an instance of a type, and returns a boolean value;The <object-reference> instanceof Object will return true for all non-null object references, since all Java objects are inherited from Object. instanceof will always return false if <object-reference> is null.Syntax:<object-reference> instanceof TypeNameFor example:class Fruit\n {\n  //...\t\n } \n class Apple extends Fruit\n {\n  //...\n }\n class Orange extends Fruit\n {\n  //...\n }\n public class Test \n {\n    public static void main(String[] args) \n    {\n       Collection<Object> coll = new ArrayList<Object>();\n \n       Apple app1 = new Apple();\n       Apple app2 = new Apple();\n       coll.add(app1);\n       coll.add(app2);\n \n       Orange or1 = new Orange();\n       Orange or2 = new Orange();\n       coll.add(or1);\n       coll.add(or2);\n \n       printColl(coll);\n    }\n \n    private static String printColl( Collection<?> coll )\n    {\n       for (Object obj : coll)\n       {\n          if ( obj instanceof Object )\n          {\n             System.out.print(\"It is a Java Object and\");\n          }\n          if ( obj instanceof Fruit )\n          {\n             System.out.print(\"It is a Fruit and\");\n          }\n          if ( obj instanceof Apple )\n          {\n             System.out.println(\"it is an Apple\");\n          } \n          if ( obj instanceof Orange )\n          {\n             System.out.println(\"it is an Orange\");\n          }\n       }\n    }\n }Run the program:java TestThe output:\"It is a Java Object and It is a Fruit and it is an Apple\"\n\"It is a Java Object and It is a Fruit and it is an Apple\"\n\"It is a Java Object and It is a Fruit and it is an Orange\"\n\"It is a Java Object and It is a Fruit and it is an Orange\"Note that the instanceof operator can also be applied to interfaces. For example, if the example above was enhanced with the interfaceinterface Edible \n{\n //...\n}and the classes modified such that they implemented this interfaceclass Orange extends Fruit implements Edible\n {\n  ...\n }we could ask if our object were edible.if ( obj instanceof Edible )\n {\n   System.out.println(\"it is edible\");\n }", "title": "instanceof[edit]"}, {"content": "int is a keyword which designates the 32 bit signed integer primitive type.The java.lang.Integer class is the nominal wrapper class when you need to store an int value but an object reference is required.Syntax:int <variable-name> = <integer-value>;For example:int i = 65;See also:Java Programming/Primitive Types", "title": "int[edit]"}, {"content": "interface is a Java keyword. It starts the declaration of a Java Interface.For example:public interface SampleInterface\n{\n   public void method1();\n   //...\n}See also:Java Programming/Keywords/new", "title": "interface[edit]"}, {"content": "long is a keyword which designates the 64 bit signed integer primitive type.The java.lang.Long class is the nominal wrapper class when you need to store a long value but an object reference is required.Syntax:long <variable-name> = <integer-value>;For example:long timestamp = 1269898201;See also:Java Programming/Primitive Types", "title": "long[edit]"}, {"content": "native is a java keyword. It marks a method, that it will be implemented in other languages, not in Java. The method is declared without a body and cannot be abstract. It works together with JNI (Java Native Interface).Syntax:[public|protected|private] native method();Native methods were used in the past to write performance critical sections but with java getting faster this is now less common. Native methods are currently needed whenYou need to call from java a library, written in another language.\nYou need to access system or hardware resources that are only reachable from the other language (typically C). Actually, many system functions that interact with real computer (disk and network IO, for instance) can only do this because they call native code.To complete writing native method, you need to process your class with javah tool that will generate a header code in C. You then need to provide implementation of the header code, produce dynamically loadable library (.so under Linux, .dll under Windows) and load it (in the simplest case with System.load(library_file_name) . The code completion is trivial if only primitive types like integers are passed but gets more complex if it is needed to exchange strings or objects from the C code. In general, everything can be on C level, including creation of the new objects and calling back methods, written in java.To call the code in some other language (including C++), you need to write a bridge from C to that language. This is usually trivial as most of languages are callable from C.", "title": "native[edit]"}, {"content": "[1] - JNI programming tutorial.\n[2] - JNI specification.", "title": "See also[edit]"}, {"content": "new is a Java keyword. It creates a Java object and allocates memory for it on the heap. new is also used for array creation, as arrays are also objects.Syntax:<JavaType> <variable> = new <JavaObject>();For example:LinkedList list = new LinkedList();\nint[] intArray = new int[10];\nString[][] stringMatrix = new String[5][10];See also:Java Programming/Creating Objects", "title": "new[edit]"}, {"content": "package is a Java keyword. It declares a 'name space' for the Java class. It must be put at the top of the Java file, it should be the first Java statement line.To ensure that the package name will be unique across vendors, usually the company url is used starting in backword.Syntax:package package;For example:package com.mycompany.myapplication.mymodule;See also:Java Programming/Packages\nJava Programming/Keywords/import", "title": "package[edit]"}, {"content": "private is a Java keyword which declares a member's access as private. That is, the member is only visible within the class, not from any other class (including subclasses). The visibility of private members extends to nested classes.Please note: Because access modifiers are not handled at instance level but at class level, private members of an object are visible from other instances of the same class!Syntax:private void method();See also:Java Programming/Access Modifiers", "title": "private[edit]"}, {"content": "protected is a Java keyword.This keyword is an access modifier, used before a method or other class member to signify that the method or variable can only be accessed by elements residing in its own class or classes in the same package (as it would be for the default visibility level) but moreover from subclasses of its own class, including subclasses in foreign packages (if the access is made on an expression, whose type is the type of this subclass).Syntax:protected <returnType> <methodName>(<parameters>);For example:protected int getAge();\n\nprotected void setYearOfBirth(int year);See also:Java Programming/Scope#Access modifiers", "title": "protected[edit]"}, {"content": "public is a Java keyword which declares a member's access as public. Public members are visible to all other classes. This means that any other class can access a public field or method. Further, other classes can modify public fields unless the field is declared as final.A best practice is to give fields private access and reserve public access to only the set of methods and final fields that define the class' public constants. This helps with encapsulation and information hiding, since it allows you to change the implementation of a class without affecting the consumers who use only the public API of the class.Below is an example of an immutable public class named Length which maintains private instance fields named units and magnitude but provides a public constructor and two public accessor methods.Code listing: Length.java\n\n\n 1 package org.wikibooks.java;\n 2 \n 3 public class Length {\n 4    private double magnitude;\n 5    private String units;\n 6 \n 7    public Length(double magnitude, String units) {\n 8       if ((units == null) || (units.trim().length() == 0)) {\n 9           throw new IllegalArgumentException(\"non-null, non-empty units required.\");\n10       }\n11 \n12       this.magnitude = magnitude;\n13       this.units = units;\n14    }\n15 \n16    public double getMagnitude() {\n17       return magnitude;\n18    }\n19 \n20    public String getUnits() {\n21       return units;\n22    }\n23 }", "title": "public[edit]"}, {"content": "return is a Java keyword.Returns a primitive value, or an object reference, or nothing(void). It does not return object values, only object references.Syntax:return variable;  // --- Returns variable\nor\nreturn;           // --- Returns nothing", "title": "return[edit]"}, {"content": "short is a keyword. It defines a 16 bit signed integer primitive type.Syntax:short <variable-name> = <integer-value>;For example:short age = 65;See also:Java Programming/Primitive Types", "title": "short[edit]"}, {"content": "static is a Java keyword. It can be applied to a field, a method or an inner class. A static field, method or class has a single instance for the whole class that defines it, even if there is no instance of this class in the program. For instance, a Java entry point (main()) has to be static. A static method cannot be abstract. It must be placed before the variable type or the method return type. It is recommended to place it after the access modifier and before the final keyword:Code section 1: Static field and method.\n\n\n1 public static final double pi = 3.1415900;\n2 \n3 public static void main(String[] args) {\n4    //...\n5 }The static items can be called on an instantiated object or directly on the class:Code section 2: Static item calls.\n\n\n1 double aNumber = MyClass.pi;\n2 MyClass.main(new String[0]);Static methods cannot call non static methods. The this current object reference is also not available in static methods.", "title": "static[edit]"}, {"content": "Static variables can be used as data sharing amongst objects of the same class. For example to implement a counter that stores the number of objects created at a given time can be defined as so:Code listing 1: CountedObject.java\n\n\n 1 public CountedObject {\n 2    private static int counter;\n 3    ...\n 4    public AClass() {\n 5       ...\n 6       counter += 1;\n 7    }\n 8    ...\n 9    public int getNumberOfObjectsCreated() {\n10       return counter;\n11    }\n12 }The counter variable is incremented each time an object is created.Public static variable should not be used, as these become global variables that can be accessed from everywhere in the program. Global constants can be used, however. See below:Code section 3: Constant definition.\n\n\n1 public static final String CONSTANT_VAR = \"Const\";Static methods can be used for utility functions or for functions that do not belong to any particular object. For example:Code listing 2: ArithmeticToolbox.java\n\n\n1 public ArithmeticToolbox {\n2    ...\n3    public static int addTwoNumbers(int firstNumber, int secondNumber) {\n4         return firstNumber + secondNumber;\n5    }\n6 }See also Static methods", "title": "Interest[edit]"}, {"content": "strictfp is a java keyword, since Java 1.2 .It makes sure that floating point calculations result precisely the same regardless of the underlying operating system and hardware platform, even if more precision could be obtained. This is compatible with the earlier version of Java 1.1 . If you need that use it.Syntax for classes:public strictfp class MyClass \n{ \n  //...\n}Syntax for methods:public strictfp void method() \n{ \n  ...\n}See also:http://en.wikipedia.org/wiki/Strictfp", "title": "strictfp[edit]"}, {"content": "super is a keyword.It is used inside a sub-class method definition to call a method defined in the super class. Private methods of the super-class cannot be called. Only public and protected methods can be called by the super keyword.\nIt is also used by class constructors to invoke constructors of its parent class.Syntax:super.<method-name>([zero or more arguments]);or:super([zero or more arguments]);For example:Code listing 1: SuperClass.java\n\n\n1 public class SuperClass {\n2    public void printHello() {\n3       System.out.println(\"Hello from SuperClass\");\n4       return;\n5    }\n6 }Code listing 2: SubClass.java\n\n\n 1 public class SubClass extends SuperClass {\n 2    public void printHello() {\n 3       super.printHello();\n 4       System.out.println(\"Hello from SubClass\");\n 5       return;\n 6    }\n 7    public static main(String[] args) {\n 8       SubClass obj = new SubClass();\n 9       obj.printHello();\n10    }\n11 }Running the above program:Command for Code listing 2\n\n$Java SubClassOutput of Code listing 2\n\nHello from SuperClass\nHello from SubClassIn Java 1.5 and later, the \"super\" keyword is also used to specify a lower bound on a wildcard type parameter in Generics.Code section 1: A lower bound on a wildcard type parameter.\n\n\n1 public void sort(Comparator<? super T> comp) {\n2   ...\n3 }See also:extends", "title": "super[edit]"}, {"content": "switch is a Java keyword.It is a branching operation, based on a number. The 'number' must be either char, byte, short, or int primitive type.Syntax:switch ( <integer-var> )\n{\n   case <label1>: <statements>;\n   case <label2>: <statements>;\n   ...\n   case <labeln>: <statements>;\n   default: <statements>;\n}When the <integer-var> value match one of the <label>, then: The statements after the matched label will be executed including the following label's statements, until the end of the switch block, or until a break keyword is reached.For example:int var = 3;\nswitch ( var )\n{\n   case 1: \n      System.out.println( \"Case: 1\" );\n      System.out.println( \"Execute until break\" );\n      break;\t\t  \t\n   case 2: \n      System.out.println( \"Case: 2\" );\n      System.out.println( \"Execute until break\" );\n      break;\n   case 3:\n      System.out.println( \"Case: 3\" );\n      System.out.println( \"Execute until break\" );\n      break;  \t\n   case 4:\n      System.out.println( \"Case: 4\" );\n      System.out.println( \"Execute until break\" );\n      break;      \n   default:\n      System.out.println( \"Case: default\" );\n      System.out.println( \"Execute until break\" );\n      break;\t      \n}The output from the above code is:Case: 3\nExecute until breakThe same code can be written with if-else blocks\":int var = 3;\nif ( var == 1 ) {\n   System.out.println( \"Case: 1\" );\n   System.out.println( \"Execute until break\" );\n} else if ( var == 2 ) {\n   System.out.println( \"Case: 2\" );\n   System.out.println( \"Execute until break\" );\n} else if ( var == 3 ) {\n   System.out.println( \"Case: 3\" );\n   System.out.println( \"Execute until break\" );\n} else if ( var == 4 ) {\n   System.out.println( \"Case: 4\" );\n   System.out.println( \"Execute until break\" );\n} else {\n   // -- This is the default part -- \n   System.out.println( \"Case: default\" );\n   System.out.println( \"Execute until break\" );\n}See also:Java Programming/Keywords/if", "title": "switch[edit]"}, {"content": "synchronized is a keyword.It marks a critical section. A critical section is where one and only one thread is executing. So to enter into the marked code the threads are synchronized, only one can enter, the others have to wait. For more information see Synchronizing Threads Methods or [3].The synchronized keyword can be used in two ways:Create a synchronized block\nMark a method synchronizedA synchronized block is marked as:Code section 1: Synchronized block.\n\n\n1 synchronized(<object_reference>) {\n2    // Thread.currentThread() has a lock on object_reference. All other threads trying to access it will\n3    // be blocked until the current thread releases the lock.\n4 }The syntax to mark a method synchronized is:Code section 2: Synchronized method.\n\n\n1 public synchronized void method() {\n2    // Thread.currentThread() has a lock on this object, i.e. a synchronized method is the same as\n3    // calling { synchronized(this) {} }.\n4 }The synchronization is always associated to an object. If the method is static, the associated object is the class. If the method is non-static, the associated object is the instance. While it is allowed to declare an abstract method as synchronized, it is meaningless to do so since synchronization is an aspect of the implementation, not the declaration, and abstract methods do not have an implementation.", "title": "synchronized[edit]"}, {"content": "As an example, we can show a thread-safe version of a singleton:Code listing 1: Singleton.java\n\n\n 1 /**\n 2  * The singleton class that can be instantiated only once with lazy instantiation\n 3  */\n 4 public class Singleton {\n 5     /** Static class instance */\n 6     private volatile static Singleton instance = null;\n 7 \n 8     /**\n 9      * Standard private constructor\n10      */\n11     private Singleton() {\n12         // Some initialisation\n13     }\n14    \n15     /**\n16      * Getter of the singleton instance\n17      * @return The only instance\n18      */\n19     public static Singleton getInstance() {\n20         if (instance == null) {\n21             // If the instance does not exist, go in time-consuming\n22             // section:\n23             synchronized (Singleton.class) {\n24                 if (instance == null) {\n25                     instance = new Singleton();\n26                 }\n27             }\n28         }\n29 \n30         return instance;\n31     }\n32  }", "title": "Singleton example[edit]"}, {"content": "this is a Java keyword. It contains the current object reference.Solves ambiguity between instance variables and parameters .\nUsed to pass current object as a parameter to another method .Syntax:this.method();\nor\nthis.variable;Example #1 for case 1:public class MyClass\n { \n    //...\n    private String value;\n    //...\n    public void setMemberVar( String value )\n    {\n        this.value= value;\n    }\n }Example #2 for case 1:public class MyClass\n { \n    MyClass(int a, int b) {\n        System.out.println(\"int a: \" + a);\n        System.out.println(\"int b: \" + b);\n    }\n    MyClass(int a) {\n        this(a, 0);\n    }\n    //...\n    public static void main(String[] args) {\n        new MyClass(1, 2);\n        new MyClass(5);\n    }\n }", "title": "this[edit]"}, {"content": "throw is a keyword; it 'throws' an exception. In a throw statement, the three types of objects that can be thrown are: Exception, java:Throwable, and java:ErrorSyntax:throw <Exception Ref>;For example:public Customer findCustomer( String name ) throws '''CustomerNotFoundException'''\n {\n    Customer custRet = null;\n \n    Iterator iter = _customerList.iterator();\n    while ( iter.hasNext() )\n    {\n        Customer cust = (Customer) iter.next();\n        if ( cust.getName().equals( name ) )\n        {\n           // --- Customer find --\n           custRet = cust;\n           break;\n        }\n     }\n     if ( custRet == null )\n     {\n        // --- Customer not found ---\n        throw new '''CustomerNotFoundException'''( \"Customer \"+ name + \" was not found\" );\n     }\n \n    return custRet\n  }", "title": "throw[edit]"}, {"content": "Java Programming/Keywords/throws", "title": "See also[edit]"}, {"content": "throws is a Java keyword. It is used in a method definition to declare the Exceptions to be thrown by the method.Syntax:public myMethod() throws MyException1, MyException2\n{MyException1\n  ...\n}Example:class MyDefinedException extends Exception\n {\n  public MyDefinedException(String str) \n  {\n     super(str);\n  }   \n }\n\n public class MyClass\n {\n    public static void showMyName(String str) throws MyDefinedException\n    {\n          if(str.equals(\"What is your Name?\"))\n                throw new MyDefinedException(\"My name is Blah Blah\");\n    }\n    public static void main(String a[])\n    {\n       try\n       {\n          showMyName(\"What is your Name?\");\n       }\n       catch(MyDefinedException mde)\n       {\n          mde.printStackTrace();\n       }\n     }\n }", "title": "throws[edit]"}, {"content": "transient is a Java keyword which marks a member variable not to be serialized when it is persisted to streams of bytes. When an object is transferred through the network, the object needs to be 'serialized'. Serialization converts the object state to serial bytes. Those bytes are sent over the network and the object is recreated from those bytes. Member variables marked by the java transient keyword are not transferred; they are lost intentionally.Syntax:private transient <member-variable>;\nor \ntransient private <member-variable>;For example:public class Foo implements Serializable\n {\n   private String saveMe;\n   private transient String dontSaveMe;\n   private transient String password;\n   //...\n }See also:Java language specification reference: jls\nSerializable Interface. Serializable", "title": "transient[edit]"}, {"content": "try is a keyword.It starts a try block. If an Exception is thrown inside a try block, the Exception will be compared any of the catch part of the block. If the Exception match with one of the Exception in the catch part, the exception will be handled there.Three things can happen in a try block:No exception is thrown:\n\nthe code in the try block\nplus the code in the finally block will be executed\nplus the code after the try-catch block is executed\n\n\nAn exception is thrown and a match is found among the catch blocks:\n\nthe code in the try block until the exception occurred is executed\nplus the matched catch block is executed\nplus the finally block is executed\nplus the code after the try-catch block is executed\n\n\nAn exception is thrown and no match found among the catch blocks:\n\nthe code in the try block until the exception occurred is executed\nplus the finally block is executed\nNO CODE after the try-catch block is executedFor example:public void method() throws NoMatchedException\n {\n   try {\n     //...\n     throw new '''MyException_1'''();\n     //...\n   } catch ( MyException_1 e ) {\n     // --- '''Handle the Exception_1 here''' --\n   } catch ( MyException_2 e ) {\n     // --- Handle the Exception_2 here --\n   } finally {\n     // --- This will always be executed no matter what --\n   }\n   // --- Code after the try-catch block\n }How the catch-blocks are evaluated see Catching RuleSee also:Java Programming/Keywords/catch\nJava Programming/Keywords/finally\nJava Programming/Throwing and Catching Exceptions#Catching Rule", "title": "try[edit]"}, {"content": "void is a Java keyword.Used at method declaration and definition to specify that the method does not return any type, the method returns void. It is not a type and there is no void references/pointers as in C/C++.For example:public void method()\n {\n   //...\n   return;   // -- In this case the return is optional\n }See also:Java Programming/Keywords/return", "title": "void[edit]"}, {"content": "volatile is a keyword.When member variables are marked with this keyword, it changes the runtime behavior in a way that is noticeable when multiple threads access these variables. Without the volatile keyword, one thread could observe another thread update member variables in an order that is not consistent with what is specified in sourcecode. Unlike the synchronized keyword, concurrent access to a volatile field is allowed.Syntax:private volatile <member-variable>;\nor \nvolatile private <member-variable>;For example:private volatile changingVar;See also:Java Programming/Keywords/synchronized", "title": "volatile[edit]"}], "title": "Keywords"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Coding_conventions", "subdata": [], "title": "Coding conventions"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Classes_and_Objects", "content": "Navigate Classes and Objects topic: (vde)\n\n Defining classes\n Inheritance\n Interfaces\n Overloading methods and constructors\n Object Lifecycle\n Scope\n Nested classes\n GenericsTopics:\n\nPreface\nGetting started\nLanguage fundamentals\nClasses and objects\nAggregate\nExceptions\nConcurrent Programming\nJavadoc & Annotations\nDesigning user interfaces\nAdvanced topics", "subdata": [], "title": "Classes and Objects"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Defining_Classes", "content": "Navigate Classes and Objects topic: (vde)\n\n Defining classes\n Inheritance\n Interfaces\n Overloading methods and constructors\n Object Lifecycle\n Scope\n Nested classes\n Generics", "subdata": [{"content": "Every class in Java can be composed of the following elements:fields, member variables or instance variables  Fields are variables that hold data specific to each object. For example, an employee might have an ID number. There is one field for each object of a class.\nmember methods or instance methods  Member methods perform operations on an object. For example, an employee might have a method to issue his paycheck or to access his name.\nstatic fields or class fields  Static fields are common to any object of the same class. For example, a static field within the Employee class could keep track of the last ID number issued. Each static field exists only once in the class, regardless of how many objects are created for that class.\nstatic methods or class methods  Static methods are methods that do not affect a specific object.\ninner classes  Sometimes it is useful to contain a class within another one if it is useless outside of the class or should not be accessed outside the class.\nConstructors  A special method that generates a new object.\nParameterized types  Since 1.5, parameterized types can be assigned to a class during definition. The parameterized types will be substituted with the types specified at the class's instantiation. It is done by the compiler. It is similar to the C language macro '#define' statement, where a preprocessor evaluates the macros.Code listing 4.1: Employee.java\n\n\n 1 public class Employee {              // This defines the Employee class.\n 2                                      // The public modifier indicates that\n 3                                      // it can be accessed by any other class\n 4 \n 5     private static int nextID;       // Define a static field. Only one copy of this will exist,\n 6                                      // no matter how many Employees are created.\n 7 \n 8     private int myID;                // Define fields that will be stored  \n 9     private String myName;           // for each Employee. The private modifier indicates that\n10                                      // only code inside the Employee class can access it.\n11  \n12     public Employee(String name) {   // This is a constructor. You can pass a name to the constructor\n13                                      // and it will give you a newly created Employee object.\n14         myName = name;\n15         myID = nextID;               // Automatically assign an ID to the object\n16         nextID++;                    // Increment the ID counter\n17     }\n18  \n19     public String getName() {        // This is a member method that returns the\n20                                      // Employee object's name.\n21         return myName;               // Note how it can access the private field myName.\n22     }\n23  \n24     public int getID() {             // This is another member method.\n25    \n26         return myID;  \n27     }\n28  \n29     public static int getNextID() {  // This is a static method that returns the next ID\n30                                      // that will be assigned if another Employee is created.\n31         return nextID;\n32     }\n33 }The following Java code would produce this output:Code listing 4.2: EmployeeList.java\n\n\n 1 public class EmployeeList {\n 2     public static void main(String[] args) {\n 3 \n 4         System.out.println(Employee.getNextID());\n 5  \n 6         Employee a = new Employee(\"John Doe\");\n 7         Employee b = new Employee(\"Jane Smith\");\n 8         Employee c = new Employee(\"Sally Brown\");\n 9  \n10         System.out.println(Employee.getNextID());\n11  \n12         System.out.println(a.getID() + \": \" + a.getName());\n13         System.out.println(b.getID() + \": \" + b.getName());\n14         System.out.println(c.getID() + \": \" + c.getName());\n15     }\n16 }\n\n\n\n\n\n\n\n\n\nConsole for Code listing 4.2\n\n0\n3\n0: John Doe\n1: Jane Smith\n2: Sally Brown", "title": "Fundamentals[edit]"}, {"content": "A constructor is called to initialize an object immediately after the object has been allocated:Code listing 4.3: Cheese.java\n\n\n1 public class Cheese {\n2   // This is a constructor\n3   public Cheese() {\n4     System.out.println(\"Construct an instance\");\n5   }\n6 }Typically, a constructor is invoked using the new keyword:Code section 4.1: A constructor call.\n\n\n1 Cheese cheese = new Cheese();The constructor syntax is close to the method syntax. However, the constructor has the same name as the name of the class (with the same case) and the constructor has no return type. The second point is the most important difference as a method can also have the same name as the class, which is not recommended:Code listing 4.4: Cheese.java\n\n\n1 public class Cheese {\n2   // This is a method with the same name as the class\n3   public void Cheese() {\n4     System.out.println(\"A method execution.\");\n5   }\n6 }The returned object is always a valid, meaningful object, as opposed to relying on a separate initialization method. A constructor cannot be abstract, final, native, static, strictfp nor synchronized. However, a constructor, like methods, can be overloaded and take parameters.Code listing 4.5: Cheese.java\n\n\n 1 public class Cheese {\n 2      // This is a constructor\n 3      public Cheese() {\n 4           doStuff();\n 5      }\n 6 \n 7      // This is another constructor\n 8      public Cheese(int weight) {\n 9           doStuff();\n10      }\n11 \n12      // This is yet another constructor\n13      public Cheese(String type, int weight) {\n14           doStuff();\n15      }\n16 }By convention, a constructor that accepts an object of its own type as a parameter and copies the data members is called a copy constructor. One interesting feature of constructors is that if and only if you do not specify a constructor in your class, the compiler will create one for you. This default constructor, if written out would look like:Code listing 4.6: Cheese.java\n\n\n1 public class Cheese {\n2      public Cheese() {\n3            super();\n4      }\n5 }The super() command calls the constructor of the superclass. If there is no explicit call to super(...) or this(...), then the default superclass constructor super(); is called before the body of the constructor is executed. That said, there are instances where you need to add in the call manually. For example, if you write even one constructor, no matter what parameters it takes, the compiler will not add a default constructor. The code listing 4.8 results in a runtime error:Code listing 4.7: Cheese.java\n\n\n1 public class Cheese {\n2      public Cheese(int weight, String type) {\n3           doStuff();\n4      }\n5 }Code listing 4.8: Mouse.java\n\n\n1 public class Mouse {\n2      public void eatCheese() {\n3              Cheese c = new Cheese(); // Oops, compile time error!\n4      }\n5 }This is something to keep in mind when extending existing classes. Either make a default constructor, or make sure every class that inherits your class uses the correct constructor.", "title": "Constructors[edit]"}], "title": "Defining Classes"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Inheritance", "content": "Navigate Classes and Objects topic: (vde)\n\n Defining classes\n Inheritance\n Interfaces\n Overloading methods and constructors\n Object Lifecycle\n Scope\n Nested classes\n GenericsThe inheritance is one of the most powerful mechanism of the Object Oriented Programming. It allows the reuse of the members of a class (called the superclass or the mother class) in another class (called subclass, child class or the derived class) that inherits from it. This way, classes can be built by successive inheritance.In Java, this mechanism is enabled by the extends keyword. Example:Code listing 4.9: Vehicle.java\n\n\n1 public class Vehicle {\n2     public int speed;\n3     public int numberOfSeats;\n4 }Code listing 4.10: Car.java\n\n\n1 public class Car extends Vehicle {\n2     public Car() {\n3         this.speed = 90;\n4         this.numberOfSeats = 5;\n5     }\n6 }In the Code listing 4.10, the class Car inherits from Vehicle, which means that the attributes speed and numberOfSeats are present in the class Car, whereas they are defined in the class Vehicle. Also, the constructor defined in the class Car allows to initialize those attributes. In Java, the inheritance mechanism allows to define a class hierarchy with all the classes. Without explicit inheritance, a class implicitly inherits from the Object class. This Object class is the root of the class hierarchy.Some classes can't be inherited. Those classes are defined with the final keyword. For instance, the Integer class can't have subclasses. It is called a final class.", "subdata": [{"content": "At the instantiating, the child class receives the features inherited from its superclass, which also has received the features inherited from its own superclass and so on to the Object class. This mechanism allows to define reusable global classes, whose user details the behavior in the derived more specific classes.In Java, a class can only inherit from one class. Java does not allow you to create a subclass from two classes, as that would require creating complicated rules to disambiguate fields and methods inherited from multiple superclasses. If there is a need for Java to inherit from multiple sources, the best option is through interfaces, described in the next chapter.", "title": "The Object class[edit]"}], "title": "Inheritance"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Interfaces", "content": "Navigate Classes and Objects topic: (vde)\n\n Defining classes\n Inheritance\n Interfaces\n Overloading methods and constructors\n Object Lifecycle\n Scope\n Nested classes\n GenericsAn interface is an abstraction of class with no implementation details. For example, java.lang.Comparable is a standard interface in Java. You cannot instantiate an interface. An interface is not a class but it is written the same way. The first difference is that you do not use the class keyword but the interface keyword to define it. Then, there are fields and methods you cannot define here:A field is always a constant: it is always public, static and final, even if you do not mention it.\nA method must be public and abstract, but it is not required to write the public and abstract keywords.\nConstructors are forbidden.An interface represents a contract:Code listing 4.14: SimpleInterface.java\n\n\n1 public interface SimpleInterface {\n2     public static final int CONSTANT1 = 1;\n3     int method1(String parameter);\n4 }You can see that the method1() method is abstract (unimplemented). To use an interface, you have to define a class that implements it, using the implements keyword:Code listing 4.15: ClassWithInterface.java\n\n\n1 public class ClassWithInterface implements SimpleInterface {\n2     int method1(String parameter) {\n3         return 0;\n4     }\n5 }A class can implement several interface, separated by a comma. Java interfaces behave much like the concept of the Objective-C protocol. It is recommended to name an interface <verb>able, to mean the type of action this interface would enable on a class. However, it is not recommended to start the name of an interface by I as in C++. It is useless. Your IDE will help you instead.", "subdata": [{"content": "If you have objects from different classes that do not have a common superclass, you can't call the same method in those classes, even if the two classes implement a method with the same signature.Code listing 4.16: OneClass.java\n\n\n1 public class OneClass {\n2     public int method1(String parameter) {\n3         return 1;\n4     }\n5 }Code listing 4.17: AnotherClass.java\n\n\n1 public class AnotherClass {\n2     public int method1(String parameter) {\n3         return 2;\n4     }\n5 }Code section 4.16: Impossible call.\n\n\n1 public static void main(String[] args) {\n2     doAction(new OneClass());\n3     doAction(new AnotherClass());\n4 }\n5 \n6 public void doAction(Object anObject) {\n7     anObject.method1(\"Hello!\");\n8 }The solution is to write an interface that defines the method that should be implemented in the two classes as the SimpleInterface in the Code listing 4.14 and then the both classes can implement the interface as in the Code listing 4.15.Code section 4.17: Interface use.\n\n\n1 public static void main(String[] args) {\n2     doAction(new ClassWithInterface());\n3     doAction(new AnotherClassWithInterface());\n4 }\n5 \n6 public void doAction(SimpleInterface anObject) {\n7     anObject.method1(\"Hello!\");\n8 }You can also implement this using a common super class but a class can only inherit from one super class whereas it can implement several interfaces.Java does not support full orthogonal multiple inheritance (i.e. Java does not allow you to create a subclass from two classes). Multiple inheritance in C++ has complicated rules to disambiguate fields and methods inherited from multiple superclasses and types that are inherited multiple times. By separating interface from implementation, interfaces offer much of the benefit of multiple inheritance with less complexity and ambiguity. The price of no multiple inheritance is some code redundancy; since interfaces only define the signature of a class but cannot contain any implementation, every class inheriting an interface must provide the implementation of the defined methods, unlike in pure multiple inheritance, where the implementation is also inherited. The major benefit of that is that all Java objects can have a common ancestor (a class called Object).When overriding methods defined in interfaces there are several rules to be followed:Checked exceptions should not be declared on implementation methods other than the ones declared by the interface method or subclasses of those declared by the interface method.\nThe signature of the interface method and the same return type or subtype should be maintained when implementing the methods.\nAll the methods of the interface need to be defined in the class, unless the class that implements the interface is abstract.", "title": "Interest[edit]"}], "title": "Interfaces"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Overloading_Methods_and_Constructors", "content": "Navigate Classes and Objects topic: (vde)\n\n Defining classes\n Inheritance\n Interfaces\n Overloading methods and constructors\n Object Lifecycle\n Scope\n Nested classes\n Generics", "subdata": [{"content": "In a class, there can be several methods with the same name. However they must have a different signature. The signature of a method is comprised of its name, its parameter types and the order of its parameters. The signature of a method is not comprised of its return type nor its visibility nor the exceptions it may throw. The practice of defining two or more methods within the same class that share the same name but have different parameters is called overloading methods.Methods with the same name in a class are called overloaded methods. Overloading methods offers no specific benefit to the JVM but it is useful to the programmer to have several methods do the same things but with different parameters. For example, we may have the operation runAroundThe represented as two methods with the same name, but different input parameter types:Code section 4.22: Method overloading.\n\n\n1 public void runAroundThe(Building block) {\n2   ...\n3 }\n4 \n5 public void runAroundThe(Park park) {\n6   ...\n7 }One type can be the subclass of the other:Code listing 4.11: ClassName.java\n\n\n 1 public class ClassName {\n 2 \n 3   public static void sayClassName(Object aObject) {\n 4     System.out.println(\"Object\");\n 5   }\n 6 \n 7   public static void sayClassName(String aString) {\n 8     System.out.println(\"String\");\n 9   }\n10 \n11   public static void main(String[] args) {\n12     String aString = new String();\n13     sayClassName(aString);\n14 \n15     Object aObject = new String();\n16     sayClassName(aObject);\n17   }\n18 }\n\n\n\n\n\n\n\n\n\nConsole for Code listing 4.11\n\nString\nObjectAlthough both methods would be fit to call the method with the String parameter, it is the method with the nearest type that will be called instead. To be more accurate, it will call the method whose parameter type is a subclass of the parameter type of the other method. So, aObject will output Object. Beware! The parameter type is defined by the declared type of an object, not its instantiated type!The following two method definitions are validCode section 4.23: Method overloading with the type order.\n\n\n1 public void logIt(String param, Error err) {\n2   ...\n3 }\n4 \n5 public void logIt(Error err, String param) {\n6   ...\n7 }because the type order is different. If both input parameters were type String, that would be a problem since the compiler would not be able to distinguish between the two:Code section 4.24: Bad method overloading.\n\n\n1 public void logIt(String param, String err) {\n2   ...\n3 }\n4 \n5 public void logIt(String err, String param) {\n6   ...\n7 }The compiler would give an error for the following method definitions as well:Code section 4.25: Another bad method overloading.\n\n\n1 public void logIt(String param) {\n2   ...\n3 }\n4 \n5 public String logIt(String param) {\n6   String retValue;\n7   ...\n8   return retValue;\n9 }Note, the return type is not part of the unique signature. Why not? The reason is that a method can be called without assigning its return value to a variable. This feature came from C and C++. So for the call:Code section 4.26: Ambiguous method call.\n\n\n1 logIt(msg);the compiler would not know which method to call. It is also the case for the thrown exceptions.Test your knowledge\n\nQuestion 4.6: Which methods of the Question6 class will cause compile errors?\n\n\n\nQuestion6.java\n\n\n 1 public class Question6 {\n 2  \n 3   public void example1() {\n 4   }\n 5 \n 6   public int example1() {\n 7   }\n 8 \n 9   public void example2(int x) {\n10   }\n11 \n12   public void example2(int y) {\n13   }\n14 \n15   private void example3() {\n16   }\n17 \n18   public void example3() {\n19   }\n20 \n21   public String example4(int x) {\n22     return null;\n23   }\n24 \n25   public String example4() {\n26     return null;\n27   }\n28 }\n\n\n\n\n\nAnswer\n\n\n\n\nQuestion6.java\n\n\n 1 public class Question6 {\n 2  \n 3   public void example1() {\n 4   }\n 5 \n 6   public int example1() {\n 7   }\n 8 \n 9   public void example2(int x) {\n10   }\n11 \n12   public void example2(int y) {\n13   }\n14 \n15   private void example3() {\n16   }\n17 \n18   public void example3() {\n19   }\n20 \n21   public String example4(int x) {\n22     return null;\n23   }\n24 \n25   public String example4() {\n26     return null;\n27   }\n28 }\n\n\n\n\nThe example1, example2 and example3 methods will cause compile errors. The example1 methods cannot co-exist because they have the same signature (remember, return type is not part of the signature). The example2 methods cannot co-exist because the names of the parameters are not part of the signature. The example3 methods cannot co-exist because the visibility of the methods are not part of the signature. The example4 methods can co-exist, because they have different method signatures.", "title": "Method overloading[edit]"}, {"content": "Instead of overloading, you can use a dynamic number of arguments. After the last parameter, you can pass optional unlimited parameters of the same type. These parameters are defined by adding a last parameter and adding ... after its type. The dynamic arguments will be received as an array:Code section 4.27: Variable argument.\n\n\n 1   public void registerPersonInAgenda(String firstName, String lastName, Date... meeting) {\n 2     String[] person = {firstName, lastName};\n 3     lastPosition = lastPosition + 1;\n 4     contactArray[lastPosition] = person;\n 5 \n 6     if (meeting.length > 0) {\n 7       Date[] temporaryMeetings = registeredMeetings.length + meeting.length;\n 8       for (i = 0; i < registeredMeetings.length; i++) {\n 9         temporaryMeetings[i] = registeredMeetings[i];\n10       }\n11       for (i = 0; i < meeting.length; i++) {\n12         temporaryMeetings[registeredMeetings.length + i] = meeting[i];\n13       }\n14       registeredMeetings = temporaryMeetings;\n15     }\n16   }The above method can be called with a dynamic number of arguments, for example:Code section 4.27: Constructor calls.\n\n\n1 registerPersonInAgenda(\"John\", \"Doe\");\n2 registerPersonInAgenda(\"Mark\", \"Lee\", new Date(), new Date());This feature was not available before Java 1.5 .", "title": "Variable Argument[edit]"}, {"content": "The constructor can be overloaded. You can define more than one constructor with different parameters. For example:Code listing 4.12: Constructors.\n\n\n 1 public class MyClass {\n 2 \n 3   private String memberField;\n 4  \n 5   /**\n 6    * MyClass Constructor, there is no input parameter\n 7    */\n 8   public MyClass() {\n 9      ...\n10   }\n11  \n12   /**\n13    * MyClass Constructor, there is one input parameter\n14    */\n15    public MyClass(String param1) {\n16      memberField = param1;\n17      ...\n18   }\n19 }In the code listing 4.12, we defined two constructors, one with no input parameter, and one with one input parameter. You may ask which constructor will be called. Its depends how the object is created with the new keyword. See below:Code section 4.29: Constructor calls.\n\n\n1 // The constructor with no input parameter will be called\n2 MyClass obj1 = new MyClass();\n3 \n4 // The constructor with one input param. will be called\n5 MyClass obj2 = new MyClass(\"Init Value\");In the code section 4.29, we created two objects from the same class, or we can also say that obj1 and obj2 both have the same type. The difference between the two is that in the first one the memberField field is not initialized, in the second one that is initialized to \"Init Value\". A constructor may also be called from another constructor, see below:Code listing 4.13: Constructor pooling.\n\n\n 1 public class MyClass {\n 2 \n 3   private String memberField;\n 4  \n 5   /**\n 6    * MyClass Constructor, there is no input parameter\n 7    */\n 8   public MyClass() {\n 9     MyClass(\"Default Value\");\n10   }\n11  \n12   /**\n13    * MyClass Constructor, there is one input parameter\n14    */\n15   public MyClass(String param1) {\n16     memberField = param1;\n17     ...\n18   }\n19 }In the code listing 4.13, the constructor with no input parameter calls the other constructor with the default initial value. This call must be the first instruction of a constructor or else a compiler error will occur. The code gives an option to the user, to create the object with the default value or create the object with a specified value. The first constructor could have been written using the this keyword as well:Code section 4.30: Another constructor pooling.\n\n\n1   public MyClass() {\n2     this(\"Default Value\");\n3   }Such a call reduces the code repetition.", "title": "Constructor overloading[edit]"}], "title": "Overloading Methods and Constructors"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Object_Lifecycle", "content": "Navigate Classes and Objects topic: (vde)\n\n Defining classes\n Inheritance\n Interfaces\n Overloading methods and constructors\n Object Lifecycle\n Scope\n Nested classes\n GenericsBefore a Java object can be created the class byte code must be loaded from the file system (with .class extension) to memory. This process of locating the byte code for a given class name and converting that code into a Java class instance is known as class loading. There is one class created for each type of Java class.All objects in Java programs are created on heap memory. An object is created based on its class. You can consider a class as a blueprint, template, or a description how to create an object. When an object is created, memory is allocated to hold the object properties. An object reference pointing to that memory location is also created. To use the object in the future, that object reference has to be stored as a local variable or as an object member variable.The Java Virtual Machine (JVM) keeps track of the usage of object references. If there are no more reference to the object, the object can not be used any more and becomes garbage. After a while the heap memory will be full of unused objects. The JVM collects those garbage objects and frees the memory they allocated, so the memory can be reused again when a new object is created. See below a simple example:Code section 4.30: Object creation.\n\n\n1 {\n2   // Create an object\n3   MyObject obj = new MyObject();\n4 \n5   // Use the object\n6   obj.printMyValues();\n7 }The obj variable contains the object reference pointing to an object created from the MyObject class. The obj object reference is in scope inside the { }. After the } the object becomes garbage. Object references can be passed in to methods and can be returned from methods.", "subdata": [{"content": "99% of new objects are created using the new keyword.Code listing 4.13: MyProgram.java\n\n\n1 public class MyProgram {\n2 \n3   public static void main(String[] args) {\n4     // Create an 'MyObject' for the first time the application started\n5     MyObject obj = new MyObject();\n6   }\n7 }When an object from the MyObject class is created for the first time, the JVM searches the file system for the definition of the class, that is the Java byte code. The file has the extension of *.class. The CLASSPATH environment variable contains locations where Java classes are stored. The JVM is looking for the MyObject.class file. Depending on which package the class belongs to, the package name will be translated to a directory path.When the MyObject.class file is found, the JVM's class loader loads the class in memory, and creates a java.lang.Class object. The JVM stores the code in memory, allocates memory for the static variables, and executes any static initialize block. Memory is not allocated for the object member variables at this point, memory will be allocated for them when an instance of the class, an object, is created.There is no limit on how many objects from the same class can be created. Code and static variables are stored only once, no matter how many objects are created. Memory is allocated for the object member variables when the object is created. Thus, the size of an object is determined not by its code's size but by the memory it needs for its member variables to be stored.", "title": "Creating object with the new keyword[edit]"}, {"content": "Cloning is not automatically available to classes. There is some help though, as all Java objects inherit the protected Object clone() method. This base method would allocate the memory and do the bit by bit copying of the object's states.You may ask why we need this clone method. Can't we create a constructor, pass in the same object and do the copying variable by variable? An example would be (note that accessing the private memberVar variable of obj is legal as this is in the same class):Code listing 4.14: MyObject.java\n\n\n1 public class MyObject {\n2    private int memberVar;\n3 ...\n4    MyObject(MyObject obj) {\n5       this.memberVar = obj.memberVar;\n6     ...\n7    }\n8 ...\n9 }This method works but object creation with the new keyword is time-consuming. The clone() method copies the whole object's memory in one operation and this is much faster than using the new keyword and copying each variable so if you need to create lots of objects with the same type, performance will be better if you create one object and clone new ones from it. See below a factory method that will return a new object using cloning.Code section 4.31: Object cloning.\n\n\n 1 HashTable cacheTemplate = new HashTable();\n 2 ...\n 3 /** Clone Customer object for performance reason */\n 4 public Customer createCustomerObject() {\n 5    // See if a template object exists in our cache\n 6    Customer template = cacheTemplate.get(\"Customer\");\n 7    if (template == null) {\n 8       // Create template\n 9       template = new Customer();\n10       cacheTemplate.put(\"Customer\", template);\n11    }\n12    return template.clone();\n13 }Now, let's see how to make the Customer object cloneable.First the Customer class needs to implement the Cloneable Interface.\nOverride and make the clone() method public, as that is protected in the Object class.\nCall the super.clone()method at the beginning of your clone method.\nOverride the clone() method in all the subclasses of Customer.Code listing 4.15: Customer.java\n\n\n1 public class Customer implements Cloneable {\n2  ...\n3     public Object clone() throws CloneNotSupportedException {\n4        Object obj = super.clone();\n5 \n6        return obj;\n7     }\n8 }In the code listing 4.15 we used cloning for speed up object creation. Another use of cloning could be to take a snapshot of an object that can change in time. Let's say we want to store Customer objects in a collection, but we want to disassociate them from the 'live' objects. So before adding the object, we clone them, so if the original object changes from that point forward, the added object won't. Also let's say that the Customer object has a reference to an Activity object that contains the customer activities. Now we are facing a problem, it is not enough to clone the Customer object, we also need to clone the referenced objects. The solution:Make the Activity class also cloneable\nMake sure that if the Activity class has other 'changeable' object references, those have to be cloned as well, as seen below\nChange the Customer class clone() method as follows:Code listing 4.16: Customer.java\n\n\n 1 public class Customer implements Cloneable {\n 2   Activity activity;\n 3   ...\n 4     public Customer clone() throws CloneNotSupportedException {\n 5       Customer clonedCustomer = (Customer) super.clone();\n 6 \n 7       // Clone the object referenced objects\n 8       if (activity != null) {\n 9          clonedCustomer.setActivity((Activity) activity.clone());\n10       }\n11       return clonedCustomer;\n12    }\n13 }Note that only mutable objects need to be cloned. References to unchangeable objects such as a String can be used in the cloned object without worry.", "title": "Creating object by cloning an object[edit]"}, {"content": "When an object is sent through a network, the object needs to be re-created at the receiving host.Object Serialization\nThe term Object Serialization refers to the act of converting the object to a byte stream. The byte stream can be stored on the file system or can be sent through a network.\nAt a later time the object can be re-created from that stream of bytes. The only requirement is that the same class has to be available both times, when the object is serialized and also when the object is re-created. If that happens on different servers, then the same class must be available on both servers. Same class means that exactly the same version of the class must be available, otherwise the object won't be able to be re-created. This is a maintenance problem for those applications where java serialization is used to make objects persistent or to sent the object through the network.\nWhen a class is modified, there could be a problem re-creating those objects that were serialized using an earlier version of the class.Java has built-in support for serialization, using the Serializable interface; however, a class must first implement the Serializable interface.By default, a class will have all of its fields serialized when converted into a data stream (with transient fields being skipped). If additional handling is required beyond the default of writing all fields, you need to provide an implementation for the following three methods:private void writeObject(java.io.ObjectOutputStream out) throws IOException;private void readObject(java.io.ObjectInputStream in) throws IOException, ClassNotFoundException;private void readObjectNoData() throws ObjectStreamException;If the object needs to write or provide a replacement object during serialization, it needs to implement the following two methods, with any access specifier:Object writeReplace() throws ObjectStreamException;Object readResolve() throws ObjectStreamException;Normally, a minor change to the class can cause the serialization to fail. You can still allow the class to be loaded by defining the serialization version id:Code section 4.32: Serialization version id.\n\n\n1 private static final long serialVersionUID = 42L;", "title": "Re-creating an object received from a remote source[edit]"}, {"content": "Unlike in many other object-oriented programming languages, Java performs automatic garbage collection  any unreferenced objects are automatically erased from memory  and prohibits the user from manually destroying objects.finalize()[edit]When an object is garbage-collected, the programmer may want to manually perform cleanup, such as closing any open input/output streams. To accomplish this, the finalize() method is used. Note that finalize() should never be manually called, except to call a super class' finalize method from a derived class' finalize method. Also, we can not rely on when the finalize() method will be called. If the java application exits before the object is garbage-collected, the finalize() method may never be called.Code section 4.33: Finalization.\n\n\n1 protected void finalize() throws Throwable {\n2   try {\n3     doCleanup();        // Perform some cleanup.  If it fails for some reason, it is ignored.\n4   } finally {\n5     super.finalize(); // Call finalize on the parent object\n6   }\n7 }The garbage-collector thread runs in a lower priority than the other threads. If the application creates objects faster than the garbage-collector can claim back memory, the program can run out of memory.The finalize method is required only if there are resources beyond the direct control of the Java Virtual Machine that needs to be cleaned up. In particular, there is no need to explicitly close an OutputStream, since the OutputStream will close itself when it gets finalized. Instead, the finalize method is used to release either native or remote resources controlled by the class.", "title": "Destroying objects[edit]"}], "title": "Object Lifecycle"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Scope", "content": "Navigate Classes and Objects topic: (vde)\n\n Defining classes\n Inheritance\n Interfaces\n Overloading methods and constructors\n Object Lifecycle\n Scope\n Nested classes\n Generics", "subdata": [{"content": "The scope of a class, a variable or a method is its visibility and its accessibility. The visibility or accessibility means that you can use the item from a given place.Scope of method parameters[edit]A method parameter is visible inside of the entire method but not visible outside the method.Code listing 3.14: Scope.java\n\n\n 1 public class Scope {\n 2 \n 3     public void method1(int i) {\n 4         i = i++;\n 5         method2();\n 6         int j = i * 2;\n 7     }\n 8 \n 9     public void method2() {\n10         int k = 20;\n11     }\n12 \n13     public static void main(String[] args) {\n14         method1(10);\n15     }\n16 }In code listing 3.14, i is visible within the entire method1 method but not in the method2 and the main methods.Scope of local variables[edit]A local variable is visible after its declaration until the end of the block in which the local variable has been created.Code section 3.50: Local variables.\n\n\n 1 {\n 2 ...\n 3      // myNumber is NOT visible\n 4   {\n 5      // myNumber is NOT visible\n 6      int myNumber;\n 7      // myNumber is visible\n 8     {\n 9       ...\n10        // myNumber is visible\n11     }\n12        // myNumber is visible\n13   }\n14      // myNumber is NOT visible\n15 ...\n16 }", "title": "Scope[edit]"}, {"content": "You surely would have noticed by now, the words public, protected and private at the beginning of class's method declarations used in this book. These keywords are called the access modifiers in the Java language syntax, and they define the scope of a given item.For a class[edit]If a class has public visibility, the class can be referenced by anywhere in the program.\nIf a class has package visibility, the class can be referenced only in the package where the class is defined.\nIf a class has private visibility, (it can happen only if the class is defined nested in an other class) the class can be accessed only in the outer class.For a variable[edit]If a variable is defined in a public class and it has public visibility, the variable can be referenced anywhere in the application through the class it is defined in.\nIf a variable has protected visibility, the variable can be referenced only in the sub-classes and in the same package through the class it is defined in.\nIf a variable has package visibility, the variable can be referenced only in the same package through the class it is defined in.\nIf a variable has private visibility, the variable can be accessed only in the class it is defined in.For a method[edit]If a method is defined in a public class and it has public visibility, the method can be called anywhere in the application through the class it is defined in.\nIf a method has protected visibility, the method can be called only in the sub-classes and in the same package through the class it is defined in.\nIf a method has package visibility, the method can be called only in the same package through the class it is defined in.\nIf a method has private visibility, the method can be called only in the class it is defined in.For an interface[edit]The interface methods and interfaces are always public. You do not need to specify the access modifier. It will default to public. For clarity it is considered a good practice to put the public keyword.The same way all member variables defined in the Interface by default will become static final once inherited in a class.Summary[edit]Class\nNested class\nMethod, or Member variable\nInterface\nInterface method signature\n\n\npublic\nvisible from anywhere\nsame as its class\nsame as its class\nvisible from anywhere\nvisible from anywhere\n\n\nprotected\nN/A\nits class and its subclass\nits class and its subclass, and from its package\nN/A\nN/A\n\n\npackage\nonly from its package\nonly from its package\nonly from its package\nN/A\nN/A\n\n\nprivate\nN/A\nonly from its class\nonly from its class\nN/A\nN/AThe cases in bold are the default.", "title": "Access modifiers[edit]"}, {"content": "A general guideline for visibilities is to only make a member as visible as it needs to be. Don't make a member public if it only needs to be private.Doing so, you can rewrite a class and change all the private members without making compilation errors, even you don't know all the classes that will use your class as long as you do not change the signature of the public members.", "title": "Utility[edit]"}], "title": "Scope"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Nested_Classes", "content": "Navigate Classes and Objects topic: (vde)\n\n Defining classes\n Inheritance\n Interfaces\n Overloading methods and constructors\n Object Lifecycle\n Scope\n Nested classes\n GenericsIn Java you can define a class inside an other class. A class can be nested inside another class or inside a method. A class that is not nested is called a top-level class and a class defining a nested class is an outer class.", "subdata": [{"content": "Nesting a class inside a class[edit]When a class is declared inside another class, the nested class' access modifier can be public, private, protected or package(default).Code listing 4.10: OuterClass.java\n\n\n1 public class OuterClass {\n2    private String outerInstanceVar;\n3 \n4    public class InnerClass {\n5       public void printVars() {\n6          System.out.println(\"Print Outer Class Instance Var.:\" + outerInstanceVar);\n7       }\n8    }\n9 }The inner class has access to the enclosing class instance's variables and methods, even private ones, as seen above. This makes it very different from the nested class in C++, which are equivalent to the \"static\" inner classes, see below.An inner object has a reference to the outer object. In other words, all inner objects are tied to the outer object. The inner object can only be created through a reference to the 'outer' object. See below.Code section 4.20: Outer class call.\n\n\n1 public void testInner() {\n2     ...\n3     OuterClass outer = new OuterClass();\n4     OuterClass.InnerClass inner = outer.new InnerClass();  \n5     ...\n6 }Note that inner objects, because they are tied to the outer object, cannot contain static variables or methods.When in a non-static method of the outer class, you can directly use new InnerClass(), since the class instance is implied to be this.You can directly access the reference to the outer object from within an inner class with the syntax OuterClass.this; although this is usually unnecessary because you already have access to its fields and methods.Inner classes compile to separate \".class\" bytecode files, with the name of the enclosing class, followed by a \"$\", followed by the name of the inner class. So for example, the above inner class would be compiled to a file named \"OuterClass$InnerClass.class\".Static nested classes[edit]A nested class can be declared static. These classes are not bound to an instance of the outer defining class. A static nested class has no enclosing instance, and therefore cannot access instance variables and methods of the outer class. You do not specify an instance when creating a static inner class. This is equivalent to the inner classes in C++.Nesting a class inside a method[edit]These inner classes, also called local classes, cannot have access modifiers, like local variables, since the class is 'private' to the method. The inner class can be only abstract or final.Code listing 4.11: OuterClass.java\n\n\n1 public class OuterClass {\n2    public void method() {\n3       class InnerClass {\n4  \n5       }\n6    }\n7 }In addition to instance variables of the enclosing class, local classes can also access local variables of the enclosing method, but only ones that are declared final. This is because the local class instance might outlive the invocation of the method, and so needs its own copy of the variable. To avoid problems with having two different copies of a mutable variable with the same name in the same scope, it is required to be final, so it cannot be changed.", "title": "Inner classes[edit]"}], "title": "Nested Classes"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Generics", "content": "Navigate Classes and Objects topic: (vde)\n\n Defining classes\n Inheritance\n Interfaces\n Overloading methods and constructors\n Object Lifecycle\n Scope\n Nested classes\n GenericsJava is a strongly typed language, so a field in a class may be typed like this:Code listing 4.34: Repository.java\n\n\n 1 public class Repository {\n 2 \n 3    public Integer item;\n 4 \n 5    public Integer getItem() {\n 6       return item;\n 7    }\n 8 \n 9    public void setItem(Integer newItem) {\n10       item = newItem;\n11    }\n12 }This ensures that, only Integer objects can be put in the field and a ClassCastException can't occur at runtime, only compile-time error can occur. Unfortunately, it can be used only with Integer objects. If you want to use the same class in another context with Strings, you have to generalize the type like this:Code listing 4.35: Repository.java\n\n\n 1 public class Repository {\n 2 \n 3    public Object item;\n 4 \n 5    public Object getItem() {\n 6       return item;\n 7    }\n 8 \n 9    public void setItem(Integer newItem) {\n10       item = newItem;\n11    }\n12 \n13    public void setItem(String newItem) {\n14       item = newItem;\n15    }\n16 }But you will have ClassCastException at runtime again and you can't easily use your field. The solution is to use Generics.", "subdata": [{"content": "A generic class does not hard code the type of a field, a return value or a parameter. The class only indicates that a generic type should be the same, for a given object instance. The generic type is not specified in the class definition. It is specified during object instantiation. This allows the generic type to be different from an instance to another. So we should write our class this way:Code listing 4.36: Repository.java\n\n\n 1 public class Repository<T> {\n 2 \n 3    public T item;\n 4 \n 5    public T getItem() {\n 6       return item;\n 7    }\n 8 \n 9    public void setItem(T newItem) {\n10       item = newItem;\n11    }\n12 }Here, the generic type is defined after the name of the class. Any new identifier can be chosen. Here, we have chosen T, which is the most common choice. The actual type is defined at the object instantiation:Code section 4.35: Instantiation.\n\n\n1 Repository<Integer> arithmeticRepository = new Repository<Integer>();\n2 arithmeticRepository.setItem(new Integer(1));\n3 Integer number = arithmeticRepository.getItem();\n4 \n5 Repository<String> textualRepository = new Repository<String>();\n6 textualRepository.setItem(\"Hello!\");\n7 String message = textualRepository.getItem();Although each object instance has its own type, each object instance is still strongly typed:Code section 4.36: Compile error.\n\n\n1 Repository<Integer> arithmeticRepository = new Repository<Integer>();\n2 arithmeticRepository.setItem(\"Hello!\");A class can define as many generic types as you like. Choose a different identifier for each generic type and separate them by a comma:Code listing 4.37: Repository.java\n\n\n 1 public class Repository<T, U> {\n 2 \n 3    public T item;\n 4 \n 5    public U anotherItem;\n 6 \n 7    public T getItem() {\n 8       return item;\n 9    }\n10 \n11    public void setItem(T newItem) {\n12       item = newItem;\n13    }\n14 \n15    public U getAnotherItem() {\n16       return anotherItem;\n17    }\n18 \n19    public void setAnotherItem(U newItem) {\n20       anotherItem = newItem;\n21    }\n22 }When a type that is defined with generic (for example, Collection<T>) is not used with generics (for example, Collection) is called a raw type.", "title": "Generic class[edit]"}, {"content": "A generic type can be defined for just a method:Code section 4.37: Generic method.\n\n\n1 public <D> D assign(Collection<D> generic, D obj) {\n2   generic.add(obj);\n3   return obj;\n4 }Here a new identifier (D) has been chosen at the beginning of the method declaration. The type is specific to a method call and different types can be used for the same object instance:Code section 4.38: Generic method call.\n\n\n1 Collection<Integer> numbers = new ArrayList<Integer>();\n2 Integer number = assign(numbers, new Integer(1));\n3 Collection<String> texts = new ArrayList<String>();\n4 String text = assign(texts, \"Store it.\");The actual type will be defined by the type of the method parameter. Hence, the generic type can't be defined only for the return value as it wouldn't be resolved. See the Class<T> section for a solution.Test your knowledge\n\nQuestion 4.8: Consider the following class.\n\n\n\nQuestion 4.8: Question8.java\n\n\n 1 public class Question8<T> {\n 2   public T item;\n 3  \n 4   public T getItem() {\n 5     return item;\n 6   }\n 7  \n 8   public void setItem(T newItem) {\n 9     item = newItem;\n10   }\n11 \n12   public static void main(String[] args) {\n13     Question8<String> aQuestion = new Question8<String>();\n14     aQuestion.setItem(\"Open your mind.\");\n15     aQuestion.display(aQuestion.getItem());\n16   }\n17 \n18   public void display(String parameter) {\n19     System.out.println(\"Here is the text: \" + parameter);\n20   }\n21 \n22   public void display(Integer parameter) {\n23     System.out.println(\"Here is the number: \" + parameter);\n24   }\n25 \n26   public void display(Object parameter) {\n27     System.out.println(\"Here is the object: \" + parameter);\n28   }\n29 }\n\n\n\n\nWhat will be displayed on the console?\n\nAnswer\n\n\n\n\nConsole for Answer 4.8\n\nHere is the text: Open your mind.\n\n\n\naQuestion.getItem() is typed as a string.", "title": "Generic method[edit]"}, {"content": "As we have seen above, generics give the impression that a new container type is created with each different type parameter. We have also seen that in addition to the normal type checking, the type parameter has to match as well when we assign generics variables. In some cases this is too restrictive. What if we would like to relax this additional checking? What if we would like to define a collection variable that can hold any generic collection, regardless of the parameter type it holds? The wildcard type is represented by the character <?>, and pronounced Unknown, or Any-Type. Any-Type can be expressed also by <? extends Object>. Any-Type includes Interfaces, not only Classes. So now we can define a collection whose element type matches anything. See below:Code section 4.39: Wildcard type.\n\n\n1 Collection<?> collUnknown;Upper bounded wildcards[edit]You can specify a restriction on the types of classes that may be used. For example, <? extends ClassName> only allows objects of class ClassName or a subclass. For example, to create a collection that may only contain \"Serializable\" objects, specify:Code section 4.40: Collection of serializable subobjects.\n\n\n1 Collection<String> textColl = new ArrayList<String>();\n2 \n3 Collection<? extends Serializable> serColl = textColl;The above code is valid because the String class is serializable. Use of a class that is not serializable would cause a compilation error. The added items can be retrieved as Serializable object. You can call methods of the Serializable interface or cast it to String. The following collection can only contain objects that extend the class Animal.Code listing 4.38: Dog.java\n\n\n1 class Dog extends Animal {\n2 }Code section 4.41: Example of subclass.\n\n\n1 // Create \"Animal Collection\" variable\n2 Collection<? extends Animal> animalColl = new ArrayList<Dog>();Lower bounded wildcards[edit]<? super ClassName> specifies a restriction on the types of classes that may be used. For example, to declare a Comparator that can compare Dogs, you use:Code section 4.42: Superclass.\n\n\n1 Comparator<? super Dog> myComparator;Now suppose you define a comparator that can compare Animals:Code section 4.43: Comparator.\n\n\n1 class AnimalComparator implements Comparator<Animal> {\n2   int compare(Animal a, Animal b) {\n3    //...\n4   }\n5 }Since Dogs are Animals, you can use this comparator to compare Dogs also. Comparators for any superclass of Dog can also compare Dog; but comparators for any strict subclass cannot.Code section 4.44: Generic comparator.\n\n\n1 Comparator<Animal> myAnimalComparator = new AnimalComparator();\n2 \n3 static int compareTwoDogs(Comparator<? super Dog> comp, Dog dog1, Dog dog2) {\n4   return comp.compare(dog1, dog2);\n5 }The above code is valid because the Animal class is a supertype of the Dog class. Use of a class that is not a supertype would cause a compilation error.Unbounded wildcard[edit]The advantage of the unbounded wildcard (i.e. <?>) compared to a raw type (i.e. without generic) is to explicitly say that the parameterized type is unknown, not any type. That way, all the operations that implies to know the type are forbidden to avoid unsafe operation. Consider the following code:Code section 4.45: Unsafe operation.\n\n\n1 public void addAtBottom(Collection anyCollection) {\n2   anyCollection.add(new Integer(1));\n3 }This code will compile but this code may corrupt the collection if the collection only contains strings:Code section 4.46: Corruption of list.\n\n\n1 List<String> col = new ArrayList<String>();\n2 addAtBottom(col);\n3 col.get(0).endsWith(\".\");\n\n\n\n\n\n\n\n\n\n\nConsole for Code section 4.46\n\nException in thread \"main\" java.lang.ClassCastException: java.lang.Integer incompatible with java.lang.String\nat Example.main(Example.java:17)This situation could have been avoided if the addAtBottom(Collection) method was defined with an unbounded wildcard: addAtBottom(Collection<?>). With this signature, it is impossible to compile a code that is dependent of the parameterized type. Only independent methods of a collection (clear(), isEmpty(), iterator(), remove(Object o), size(), ...) can be called. For instance, addAtBottom(Collection<?>) could contain the following code:Code section 4.47: Safe operation.\n\n\n1 public void addAtBottom(Collection<?> anyCollection) {\n2    Iterator<?> iterator = anyCollection.iterator();\n3    while (iterator.hasNext()) {\n4       System.out.print(iterator.next());\n5    }\n6 }", "title": "Wildcard Types[edit]"}, {"content": "Since Java 1.5, the class java.lang.Class is generic. It is an interesting example of using generics for something other than a container class. For example, the type of String.class is Class<String>, and the type of Serializable.class is Class<Serializable>. This can be used to improve the type safety of your reflection code. In particular, since the newInstance() method in Class now returns T, you can get more precise types when creating objects reflectively. Now we can use the newInstance() method to return a new object with exact type, without casting. An example with generics:Code section 4.48: Automatic cast.\n\n\n 1 Customer cust = Utility.createAnyObject(Customer.class);  // No casting\n 2 ...\n 3 public static <T> T createAnyObject(Class<T> cls) {\n 4     T ret = null;\n 5     try {\n 6         ret = cls.newInstance();\n 7     } catch (Exception e) {\n 8         // Exception Handling\n 9     }\n10     return ret;\n11 }The same code without generics:Code section 4.49: Former version.\n\n\n 1 Customer cust = (Customer) Utility.createAnyObject(Customer.class);  // Casting is needed\n 2 ...\n 3 public static Object createAnyObject(Class cls) {\n 4     Object ret = null;\n 5     try {\n 6         ret = cls.newInstance();\n 7     } catch (Exception e) {\n 8         // Exception Handling\n 9     }\n10     return ret;\n11 }", "title": "Class<T>[edit]"}, {"content": "Java was long criticized for the need to explicitly type-cast an element when it was taken out of a \"container/collection\" class. There was no way to enforce that a \"collection\" class contains only one type of object (e.g., to forbid at compile time that an Integer object is added to a Collection that should only contain Strings). This is possible since Java 1.5. In the first couple of years of Java evolution, Java did not have a real competitor. This has changed by the appearance of Microsoft C#. With Generics Java is better suited to compete against C#. Similar constructs to Java Generics exist in other languages, see Generic programming for more information. Generics were added to the Java language syntax in version 1.5. This means that code using Generics will not compile with Java 1.4 and less. Use of generics is optional. For backwards compatibility with pre-Generics code, it is okay to use generic classes without the generics type specification (<T>). In such a case, when you retrieve an object reference from a generic object, you will have to manually cast it from type Object to the correct type.", "title": "Motivation[edit]"}], "title": "Generics"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Aggregate", "content": "Navigate Aggregate topic: (vde)\n\n Collection\n ArrayList\n Map\n Comparing ObjectsTopics:\n\nPreface\nGetting started\nLanguage fundamentals\nClasses and objects\nAggregate\nExceptions\nConcurrent Programming\nJavadoc & Annotations\nDesigning user interfaces\nAdvanced topicsIn the previous chapters, we have discovered the array. An array stores a group of primitive types. To group objects, or to reference a group of objects, we can use Java aggregate classes. There are two main interfaces, those are java.util.Collection and java.util.Map . Implementations for those interfaces are not interchangeable.", "subdata": [{"content": "The implementations of java.util.Collection interface are used for grouping simple java objects.Example\nWe can group together all patients in a Hospital to a \"patient\" collection.", "title": "Collection[edit]"}, {"content": "The implementations of java.util.Map interface are used to represent mapping between \"key\" and \"value\" objects. A Map represents a group of \"key\" objects, where each \"key\" object is mapped to a \"value\" object.Example\nFor each patient, there is one and only one main nurse assigned to. That association can be represented by a \"patient-nurse\" Map.", "title": "Map[edit]"}], "title": "Aggregate"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Collection", "content": "Navigate Aggregate topic: (vde)\n\n Collection\n ArrayList\n Map\n Comparing ObjectsThe most basic collection interface is called Collection. This interface gives the user the generic usage of a collection. All collections need to have the same basic operations. Those are:Adding element(s) to the collection\nRemoving element(s) from the collection\nObtaining the number of elements in the collection\nListing the contents of the collection, (Iterating through the collection)Code listing 5.1: CollectionProgram.java\n\n\n 1 import java.util.Collection;   // Interface\n 2 import java.util.ArrayList;    // Implementation\n 3 \n 4 public class CollectionProgram {\n 5 \n 6   public static void main(String[] args) {\n 7     Collection myCollection = new ArrayList();\n 8     myCollection.add(\"1\");\n 9     myCollection.add(\"2\");\n10     myCollection.add(\"3\");\n11     System.out.println(\"The collection contains \" + myCollection.size() + \" item(s).\");\n12 \n13     myCollection.clear();\n14     if (myCollection.isEmpty()) {\n15       System.out.println(\"The collection is empty.\");\n16     } else {\n17       System.out.println(\"The collection is not empty.\");\n18     }\n19   }\n20 }\n\n\n\n\n\n\n\n\n\nConsole for Code listing 5.1\n\nThe collection contains 3 item(s).\nThe collection is empty.When you put an object in a collection, this object is not actually in the collection. Only its object reference is added to the collection. This means that if an object is changed after it was put in an collection, the object in the collection also changes. The code listing 5.2 computes the seven next days from tomorrow and stores each date in a list to read it afterwards. See what happens:Code listing 5.2: SevenNextDays.java\n\n\n 1 import java.util.ArrayList;\n 2 import java.util.Calendar;\n 3 import java.util.Collection;\n 4 import java.util.Date;\n 5 import java.util.GregorianCalendar;\n 6 \n 7 public class SevenNextDays {\n 8 \n 9   public static void main(String[] args) {\n10    \n11     // The calendar is set at the current date: today\n12     Calendar calendar = new GregorianCalendar();\n13 \n14     Collection collectionOfDays = new ArrayList();\n15     Date currentDate = new Date();\n16     for (int i = 0; i < 7; ++i) {\n17       // The calendar is now set to the next day\n18       calendar.add(Calendar.DATE, 1);\n19       currentDate.setTime(calendar.getTimeInMillis());\n20 \n21       collectionOfDays.add(currentDate);\n22     }\n23 \n24     for (Object oneDay : collectionOfDays) {\n25       System.out.println(\"The next day is: \" + oneDay);\n26     }\n27   }\n28 }\n\n\n\n\n\n\n\n\n\nConsole for Code listing 5.2\n\nThe next day is: Thu Nov 2 14:10:20 UTC 2017\nThe next day is: Thu Nov 2 14:10:20 UTC 2017\nThe next day is: Thu Nov 2 14:10:20 UTC 2017\nThe next day is: Thu Nov 2 14:10:20 UTC 2017\nThe next day is: Thu Nov 2 14:10:20 UTC 2017\nThe next day is: Thu Nov 2 14:10:20 UTC 2017\nThe next day is: Thu Nov 2 14:10:20 UTC 2017All collection items were meant to be updated to a different date but they all have been updated to the last one. This means that each update has updated all the collection items. The currentDate has been used to fill all the collection items. The collection didn't keep trace of the added values (one of the seven dates) but the added object references (currentDate). So the collection contains the same object seven times! To avoid this issue, we should have coded it this way:Code listing 5.3: ActualSevenNextDays.java\n\n\n 1 import java.util.ArrayList;\n 2 import java.util.Calendar;\n 3 import java.util.Collection;\n 4 import java.util.Date;\n 5 import java.util.GregorianCalendar;\n 6 \n 7 public class ActualSevenNextDays {\n 8 \n 9   public static void main(String[] args) {\n10    \n11     // The calendar is set at the current date: today\n12     Calendar calendar = new GregorianCalendar();\n13 \n14     Collection collectionOfDays = new ArrayList();\n15     for (int i = 0; i < 7; ++i) {\n16       Date currentDate = new Date();\n17       // The calendar is now set to the next day\n18       calendar.add(Calendar.DATE, 1);\n19       currentDate.setTime(calendar.getTimeInMillis());\n20 \n21       collectionOfDays.add(currentDate);\n22     }\n23 \n24     for (Object oneDay : collectionOfDays) {\n25       System.out.println(\"The next day is: \" + oneDay);\n26     }\n27   }\n28 }\n\n\n\n\n\n\n\n\n\nConsole for Code listing 5.3\n\nThe next day is: Fri Oct 27 14:10:20 UTC 2017\nThe next day is: Sat Oct 28 14:10:20 UTC 2017\nThe next day is: Sun Oct 29 14:10:20 UTC 2017\nThe next day is: Mon Oct 30 14:10:20 UTC 2017\nThe next day is: Tue Oct 31 14:10:20 UTC 2017\nThe next day is: Wed Nov 1 14:10:20 UTC 2017\nThe next day is: Thu Nov 2 14:10:20 UTC 2017Now each time we add an item to the collection, it is a different instance. All the items evolve separately. To add an object in a collection and avoid this item being changed each time the source object is changed, you have to copy or clone the object before you add it to the collection.", "subdata": [{"content": "Objects put into a collection are upcasted to the Object class. This means that you need to cast the object reference back when you get an element out of the collection. It also means that you need to know the type of the object when you take it out. If a collection contains different types of objects, we will have difficulty finding out the type of the objects obtained from a collection at run time. For example. let's use this collection with two objects in it:Code section 5.1: Collection feeding.\n\n\n1 Collection ageList = new ArrayList();\n2 ageList.add(new Integer(46));\n3 ageList.add(\"50\");Code section 5.2: Collection reading.\n\n\n1 Integer sum = new Integer(0);\n2 for (Object age : ageList) {\n3     sum = sum.add((Integer) age);\n4 }\n5 \n6 if (!ageList.isEmpty()) {\n7     System.out.println(\"The average age is \" + sum / ageList.size());\n8 }\n\n\n\n\n\n\n\n\n\nConsole for Code section 5.2\n\nClassCastException.This error could have been found earlier, at compile time, by using generic types. The Generics have been added since JDK version 1.5. It is an enhancement to the type system of the Java language. All collection implementations since 1.5 now have a parameterized type <E>. The E refers to an Element type. When a collection is created, the actual Element type will replace the E. In the collection, the objects are now upcasted to E class.Code section 5.3: Collection with generics.\n\n\n1 Collection<Integer> ageList = new ArrayList<Integer>();\n2 ageList.add(new Integer(46));     // Integer can be added\n3 ageList.add(\"50\");                // Compilation error, ageList can have only Integers insideageList is a collection that can contain only Integer objects as elements. No casting is required when we take out an element.Code section 5.4: Item reading.\n\n\n1 Integer age = ageList.get(0);Generics are not mandatory but are is often used with the collection classes.", "title": "Generics[edit]"}, {"content": "There is no direct implementation for the java.util.Collection interface. The Collection interface has five sub interfaces.Figure 1: The five sub interfaces of the java.util.Collection interface.Set[edit]A set collection contains unique elements, so duplicates are not allowed. It is similar to a mathematical Set. When adding a new item to a set, the set calls the method int hashCode() of the item and compares its result to the hash code of all the already inserted items. If the hash code is not found, the item is added. If the hash code is found, the set calls the boolean equals(Object obj); method for all the set items with the same hashcode as the new item. If all equal-calls return false, the new item is inserted in the set. If an equal-call returns true, the new item is not inserted in the set.Figure 2: Set class diagram.java.util.HashSet<E>\nThis is the basic implementation of the Set interface. Not synchronized. Allows the null elements\njava.util.TreeSet<E>\nElements are sorted, not synchronized. null not allowed\njava.util.CopyOnWriteArraySet<E>\nThread safe, a fresh copy is created during modification operation. Add, update, delete are expensive.\njava.util.EnumSet<E extends Enum<E>>\nAll of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created. Enum sets are represented internally as bit vectors.\njava.util.LinkedHashSet<E>\nSame as HashSet, plus defines the iteration ordering, which is the order in which elements were inserted into the set.Detecting duplicate objects in Sets[edit]Set cannot have duplicates in it. You may wonder how duplicates are detected when we are adding an object to the Set. We have to see if that object exists in the Set or not. It is not enough to check the object references, the objects' values have to be checked as well.To do that, fortunately, each java object has the boolean equals(Object obj), method available inherited from Object. You need to override it. That method will be called by the Set implementation to compare the two objects to see if they are equal or not.There is a problem, though. What if I put two different type of objects to the Set. I put an Apple and an Orange. They can not be compared. Calling the equals() method would cause a ClassCastException. There are two solutions to this:Solution one: Override the int hashCode() method and return the same values for the same type of objects and return different values for different type of objects. The equals() method is used to compare objects only with the same value of hashCode. So before an object is added, the Set implementation needs to:\n\nfind all the objects in the Set that have the same hashCode as the candidate object hashCode\nand for those, call the equals() methods passing in the candidate object\nif any of them returns true, the object is not added to the Set.Solution two: Create a super class for the Apple and Orange, let's call it Fruit class. Put Fruits in the Set. You need to do the following:\n\nDo not override the equals() and hashCode() methods in the Apple and Orange classes\nCreate appleEquals() method in the Apple class, and create orangeEquals() method in the Orange class\nOverride the hashCode() method in the Fruit class and return the same value, so the equals() is called by the Set implementation\nOverride the equals() method in the Fruit class for something like this.Code section 5.5: equals method implementation.\n\n\n 1 public boolean equals(Object obj) {\n 2     boolean ret = false;\n 3     if (this instanceof Apple &&\n 4           obj instanceof Apple) {\n 5         ret = this.appleEquals(obj);\n 6     } else if (this instanceof Orange &&\n 7               obj  instanceof Orange) {\n 8         ret = this.orangeEquals(obj);  \n 9     } else {\n10         // Can not compare Orange to Apple\n11        ret = false;\n12     }\n13     return ret;\n14 }Note:Only the objects that have the same hashCode will be compared.\nYou are responsible to override the equals() and hashCode() methods. The default implementations in Object won't work.\nOnly override the hashCode() method if you want to eliminate value duplicates.\nDo not override the hashCode() method if you know that the values of your objects are different, or if you only want to prevent adding the exactly same object.\nBeware that the hashCode() may be used in other collection implementations, like in a Hashtable to find an object fast. Overriding the default hashCode() method may affect performance there.\nThe default hashCodes are unique for each object created, so if you decide not to override the hashCode() method, there is no point overriding the equals() method, as it won't be called.SortedSet[edit]The SortedSet interface is the same as the Set interface plus the elements in the SortedSet are sorted. It extends the Set Interface. All elements in the SortedSet must implement the Comparable Interface, furthermore all elements must be mutually comparable.Note that the ordering maintained by a sorted set must be consistent with equals if the sorted set is to correctly implement the Set interface. This is so because the Set interface is defined in terms of the equals operation, but a sorted set performs all element comparisons using its compare method, so two elements that are deemed equal by this method are, from the standpoint of the sorted set, equal.The SortedSet interface has additional methods due to the sorted nature of the 'Set'. Those are:E first();\nreturns the first element\n\n\nE last();\nreturns the last element\n\n\nSortedSet headSet(E toElement);\nreturns from the first, to the exclusive toElement\n\n\nSortedSet tailSet(E fromElement);\nreturns from the inclusive fromElement to the end\n\n\nSortedSet subSet(E fromElement, E toElement);\nreturns elements range from fromElement, inclusive, to toElement, exclusive. (If fromElement and toElement are equal, the returned sorted set is empty.)List[edit]In a list collection, the elements are put in a certain order, and can be accessed by an index. Duplicates are allowed, the same element can be added twice to a list. It has the following implementations:Figure 3: List class diagram.java.util.Vector<E>\nSynchronized, use in multiple thread access, otherwise use ArrayList.\njava.util.Stack<E>\nIt extends class Vector with five operations that allow a vector to be treated as a stack. It represents a last-in-first-out (LIFO) stack of objects.\njava.util.ArrayList<E>\nThe basic implementation of the List interface is the ArrayList. The ArrayList is not synchronized, not thread safe. Vector is synchronized, and thread safe. Vector is slower, because of the extra overhead to make it thread safe. When only one thread is accessing the list, use the ArrayList. Whenever you insert or remove an element from the list, there are extra overhead to reindex the list. When you have a large list, and you have lots of insert and remove, consider using the LinkedList.\njava.util.LinkedList<E>\nNon-synchronized, update operation is faster than other lists, easy to use for stacks, queues, double-ended queues. The name LinkedList implies a special data structure where the elements/nodes are connected by pointers.Head               Node 1                   Node 2                     Node n\n  ______\n | Size |          _________________        _______________            _____________\n |______|         |      | point   |       |      | point  |          |      |      |  \n | First|-------->| Data | to next |------>| Data | to next|-- ... -->| Data | null |\n | elem |         |______|_________|       |______|________|          |______|______|\n |______|                                                                 ^\n | Last |                                                                 |\n | elem |-----------------------------------------------------------------\n |______|Each node is related to an item of the linked list. To remove an element from the linked list the pointers need to be rearranged. After removing Node 2:Head               Node 1                   Node 2                     Node n\n  ______                                 _____________________\n | Size |          _________________    |   _______________   |       ______________\n |_- 1__|         |      | point   |    |  |      | point  |  |       |      |      |  \n | First|-------->| Data | to next |----   | Data | to next|   -...-->| Data | null |\n | elem |         |______|_________|       |______|________|          |______|______|\n |______|                                                                 ^\n | Last |                                                                 |\n | elem |-----------------------------------------------------------------\n |______|javax.management.AtributeList<E>\nRepresents a list of values for attributes of an MBean. The methods used for the insertion of Attribute objects in the AttributeList overrides the corresponding methods in the superclass ArrayList. This is needed in order to insure that the objects contained in the AttributeList are only Attribute objects.\njavax.management.relation.RoleList<E>\nA RoleList represents a list of roles (Role objects). It is used as parameter when creating a relation, and when trying to set several roles in a relation (via 'setRoles()' method). It is returned as part of a RoleResult, to provide roles successfully retrieved.\njavax.management.relation.RoleUnresolvedList<E>\nA RoleUnresolvedList represents a list of RoleUnresolved objects, representing roles not retrieved from a relation due to a problem encountered when trying to access (read or write to roles).", "title": "Collection classes[edit]"}, {"content": "The Queue interface provides additional insertion, extraction, and inspection operations. There are FIFO (first in, first out) and LIFO (last in, first out) queues. This interface adds the following operations to the Collection interface:E element()\nRetrieves, but does not remove, the head of this queue. This method differs from the peek method only in that it throws an exception if this queue is empty\n\n\nboolean offer(E o)\nInserts the specified element into this queue, if possible.\n\n\nE peek()\nRetrieves, but does not remove, the head of this queue, returning null if this queue is empty\n\n\nE poll()\nRetrieves and removes the head of this queue, or null if this queue is empty\n\n\nE remove()\nRetrieves and removes the head of this queue. This method differs from the poll method in that it throws an exception if this queue is empty.Figure 4: Queue class diagram.java.util.BlockingQueue<E>\nwaits for the queue to become non-empty when retrieving an element, and waits for space to become available in the queue when storing an element. Best used for producer-consumer queues.\njava.util.PriorityQueue<E>\norders elements according to an order/priority specified at construction time, null element is not allowed.\njava.util.concurrent.ArrayBlockingQueue<E>\norders elements FIFO; synchronized, thread safe.\njava.util.concurrent.SynchronousQueue<E>\neach put must wait for a take, and vice versa, does not have any internal capacity, not even a capacity of one, an element is only present when you try to take it; you cannot add an element (using any method) unless another thread is trying to remove it.", "title": "Queue[edit]"}, {"content": "Figure 5: UML class diagram of the Collection interfaces and their implementations.", "title": "Complete UML class diagram[edit]"}, {"content": "Synchronization is important when you are running several threads. Beware, synchronization does not mean that your collection is thread-safe. A thread-safe collection is also called a concurrent collection. Most of the popular collection classes have implementations for both single thread and multiple thread environments. The non-synchronized implementations are always faster. You can use the non-synchronized implementations in multiple thread environments, when you make sure that only one thread updates the collection at any given time.A new Java JDK package was introduced at Java 1.5, that is java.util.concurrent. This package supplies a few Collection implementations designed for use in multi-threaded environments.The following table lists all the synchronized collection classes:synchronized\nnon-synchronized\n\n\nList\njava.util.Vector\njava.util.ArrayList\n\n\njava.util.Stack\n\n\n\n\njava.util.LinkedList\n\n\njava.util.concurrent.CopyOnWriteArrayList\n\n\n\nSet\n\njava.util.TreeSet\n\n\n\njava.util.HashSet\n\n\n\njava.util.LinkHashSet\n\n\njava.util.concurrent.CopyOnWriteArraySet", "title": "Synchronization[edit]"}], "title": "Collection"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/ArrayList", "content": "Navigate Aggregate topic: (vde)\n\n Collection\n ArrayList\n Map\n Comparing ObjectsThe ArrayList class extends AbstractList and implements the List interface. ArrayList supports dynamic arrays that can grow as needed.Standard Java arrays are of a fixed length. After arrays are created, they cannot grow or shrink, which means that you must know in advance how many elements an array will hold.Array lists are created with an initial size. When this size is exceeded, the collection is automatically enlarged. When objects are removed, the array may be shrunk.", "subdata": [{"content": "The ArrayList class supports three constructors. The first constructor builds an empty array list.:ArrayList( )The following constructor builds an array list that is initialized with the elements of the collection c.ArrayList(Collection c)The following constructor builds an array list that has the specified initial capacity. The capacity is the size of the underlying array that is used to store the elements.The capacity grows automatically as elements are added to an array list.ArrayList(int capacity)", "title": "Initializing[edit]"}], "title": "ArrayList"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Map", "content": "Navigate Aggregate topic: (vde)\n\n Collection\n ArrayList\n Map\n Comparing ObjectsAside from the java.util.Collection interface, the Java JDK has the java.util.Map interface as well. It is sometimes also called an Associated Array or a Dictionary. A map defines key value mappings. Implementations of the Map interface do not contain collections of objects. Instead they contain collections of key->value mappings. It can be thought of as an array where the index doesn't need to be an integer.Code section 5.17: Use of a map.\n\n\n1 import java.util.Map;\n2 import java.util.Hashtable;\n3 ...\n4 Map map = new Hashtable();\n5 ...\n6 map.put(key, value);Use the Map interface if you need to keep related objects together in a Map where you can:Access an element by a key object\nMap one object to otherFigure 5.6: Map Interfaces.java.util.Map<K,V>\nmaps keys to values. A map cannot contain duplicate keys; each key can map to at most one value. The Map interface provides three collection views, which allow a map's contents to be viewed as a set of keys, collection of values, or set of key-value mappings. The key is usually a non-mutable object. The value object however can be a mutable object.\njava.util.SortedMap<K,V>\nsame as the Map interface, plus the keys in the Map are sorted.In the above example, the same operations are made with two different map implementations:Code listing 5.4: MapImplementations.java\n\n\n 1 import java.util.LinkedHashMap;\n 2 import java.util.Map;\n 3 import java.util.TreeMap;\n 4 \n 5 /**\n 6  * Compare the map implementations.\n 7  *\n 8  * @author xxx\n 9  */\n10 public class MapImplementations {\n11 \n12   /**\n13    * Compare the map implementations.\n14    * @param args The execution parameters.\n15    */\n16   public static void main(String[] args) {\n17     processMap(new LinkedHashMap<String, Integer>());\n18 \n19     processMap(new TreeMap<String, Integer>());\n20   }\n21 \n22   /**\n23    * Use a map:\n24    * 1. Fill the map with key-> value.\n25    * 2. Print all the keys.\n26    *\n27    * @param map The used map.\n28    */\n29   public static void processMap(Map<String, Integer> map) {\n30     System.out.println(\"Process the map\");\n31     map.put(\"3\", new Integer(3));\n32     map.put(\"2\", new Integer(2));\n33     map.put(\"1\", new Integer(1));\n34 \n35     for (String key : map.keySet()) {\n36       System.out.println(key);\n37     }\n38   }\n39 }\n\n\n\n\n\n\n\n\n\nConsole for Code listing 5.4\n\nProcess the map\n3\n2\n1\nProcess the map\n1\n2\n3We see that only the TreeMap has sorted the keys. Beware of the generics. The Map interface is tricky. The methods get() and remove() are not generic. This means that you must be careful of the type of the key:Code section 5.18: Tricky generics.\n\n\n 1 Map<Integer, String> map = new TreeMap<Integer, String>();\n 2 \n 3 map.put(new Integer(1), \"Watch\");\n 4 map.put(new Integer(2), \"out\");\n 5 map.put(new Integer(3), \"!\");\n 6 \n 7 map.remove(\"2\");\n 8 \n 9 for (String value : map.values()) {\n10   System.out.println(value);\n11 }\n\n\n\n\n\n\n\n\n\nConsole for Code section 5.18\n\nWatch\nout\n!The remove() call has done nothing because \"2\" is a String, not an Integer so no key and value has been found and removed.Map Classes[edit]The Map interface has the following implementations:Figure 5.7: Map class diagram.java.util.TreeMap<E>\nguarantees that the map will be in ascending key order, sorted according to the natural order for the key's class, not-synchronized.\njava.util.Hashtable<E>\nSynchronized, null can not be used as key\njava.util.HashMap<E>\nis roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls\njava.util.concurrent.ConcurrentHashMap\nsame as Hashtable, plus retrieval operations (including get) generally do not block, so may overlap with update operations (including put and remove).\njava.util.WeakHashMap<E>\nentry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use. Non-synchronized.\njava.util.LinkedHashMap<E>\nThis linked list defines the iteration ordering, which is normally the order in which keys were first inserted into the map (first insertion-order). Note that insertion order is not affected if a key is re-inserted into the map.\njava.util.IdentityHashMap\nThis class implements the Map interface with a hash table, using reference-equality in place of object-equality when comparing keys (and values). In other words, in an IdentityHashMap, two keys k1 and k2 are considered equal if and only if (k1==k2). (In normal Map implementations (like HashMap) two keys k1 and k2 are considered equal if and only if (k1==null? k2==null: k1.equals(k2)).) Not-synchronized.\njava.util.EnumMap\nAll of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. Enum maps are represented internally as arrays. This representation is extremely compact and efficient. Not-synchronized.", "subdata": [], "title": "Map"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Comparing_Objects", "content": "Navigate Aggregate topic: (vde)\n\n Collection\n ArrayList\n Map\n Comparing ObjectsIn Java, we can distinguish two kinds of equality.Object reference equality: when two object references point to the same object.\nObject value equality: when two separate objects happen to have the same values/state.If two objects are equal in reference, they are equal in value too.", "subdata": [{"content": "The == operator can be used to check if two object references point to the same object.Code section 5.19: Reference equality.\n\n\n1 if (objRef1 == objRef2) {\n2     // The two object references point to the same object\n3 }", "title": "Comparing for reference equality[edit]"}, {"content": "To be able to compare two Java objects of the same class the boolean equals(Object obj) method must be overriden and implemented by the class.The implementor decides which values must be equal to consider two objects to be equal. For example in the below class, the name and the address must be equal but not the description.Code listing 5.5: Customer.java\n\n\n 1 public class Customer {\n 2     private String name;\n 3     private String address;\n 4     private String description;\n 5     // ...\n 6     public boolean equals(Object obj) {\n 7         if (this == obj) {\n 8             return true;\n 9         } else if (obj == null) {\n10             return false;\n11         } else if (obj instanceof Customer) {\n12             Customer cust = (Customer) obj;\n13             if ((cust.getName() == null && name == null) ||\n14                 (cust.getName().equals(name) && ((cust.getAddress() == null && address == null)\n15                 || cust.getAddress().equals(address))) {\n16                 return true;\n17             }\n18         }\n19         return false;\n20     }\n21 \n22 }After the equals() method is overriden, two objects from the same class can be compared like this:Code section 5.20: Method usage.\n\n\n1 Customer cust1 = new Customer();\n2 Customer cust2 = new Customer();\n3 //...\n4 if (cust1.equals(cust2)) {\n5     // Two Customers are equal, by name and address\n6 }Note that equal objects must have equal hash codes. Therefore, when overriding the equals method, you must also override the hashCode method. Failure to do so violates the general contract for the hashCode method, and any classes that use the hash code, such as HashMap will not function properly.", "title": "Comparing for value equality[edit]"}, {"content": "In Java, there are several existing methods that already sort objects from any class like Collections.sort(List<T> list). However, Java needs to know the comparison rules between two objects. So when you define a new class and want the objects of your class to be sortable, you have to implement the Comparable and redefine the compareTo(Object obj) method.int compareTo(T o)\nCompares two objects and return an integer:A negative integer means that the current object is before the parameter object in the natural ordering.\nZero means that the current object and the parameter object are equal.\nA positive integer means that the current object is after the parameter object in the natural ordering.Let's say that the name is more important than the address and the description is ignored.Code listing 5.6: SortableCustomer.java\n\n\n 1 public class SortableCustomer implements Comparable<SortableCustomer> {\n 2     private String name;\n 3     private String address;\n 4     private String description;\n 5     // ...\n 6     public int compareTo(SortableCustomer anotherCustomer) {\n 7         if (name.compareTo(anotherCustomer.getName()) == 0) {\n 8             return address.compareTo(anotherCustomer.getAddress();\n 9         } else {\n10             return name.compareTo(anotherCustomer.getName();\n11         }\n12     }\n13 \n14 }Objects that implement this interface can be used as keys in a sorted map or elements in a sorted set, without the need to specify a comparator.The natural ordering for a class C is said to be consistent with equals if and only if e1.compareTo((Object) e2) == 0 has the same boolean value as e1.equals((Object) e2) for every e1 and e2 of class C. Note that null is not an instance of any class, and e.compareTo(null) should throw a NullPointerException even though e.equals(null) returns false.It is strongly recommended (though not required) that natural orderings be consistent with equals. This is because sorted sets (and sorted maps) without explicit comparators behave \"strangely\" when they are used with elements (or keys) whose natural ordering is inconsistent with equals. In particular, such a sorted set (or sorted map) violates the general contract for set (or map), which is defined in terms of the equals method.", "title": "Sorting/Ordering[edit]"}], "title": "Comparing Objects"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Exceptions", "content": "Navigate Exceptions topic:(vde)\n\n Throwing and catching exceptions\n Checked exceptions\n Unchecked exceptions\n Preventing NullPointerException\n Stack trace\n Nesting exceptions (chained exceptions)The ideal time to catch an error is at compile time, before you even try to run the program. However, not all errors can be detected at compile time. The rest of the problems must be handled at run time through some formality that allows the originator of the error to pass appropriate information to a recipient who will know how to handle the difficulty properly.Improved error recovery is one of the most powerful ways that can increase the robustness of your code. Error recovery is a fundamental concern for every program you write, but it's especially important in Java, where one of the primary goals is to create program components for others to use. To create a robust system, each component must be robust. By providing a consistent error-reporting model using exceptions, Java allows components to reliably communicate problems to client code.", "subdata": [], "title": "Exceptions"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Throwing_and_Catching_Exceptions", "content": "Navigate Exceptions topic:(vde)\n\n Throwing and catching exceptions\n Checked exceptions\n Unchecked exceptions\n Preventing NullPointerException\n Stack trace\n Nesting exceptions (chained exceptions)Language compilers are adept at pointing out most of the erroneous code in a program, however there are some errors that only become apparent when the program is executed. Consider the code listing 6.1; here, the program defines a method divide that does a simple division operation taking two integers as parameter arguments and returning the result of their division. It can safely be assumed that when the divide(4, 2) statement is called, it would return the number 2. However, consider the next statement, where the program relies upon the provided command line arguments to generate a division operation. What if the user provides the number zero (0) as the second argument? We all know that division by zero is impossible, but the compiler couldn't possibly have anticipated the user providing zero as an argument.Code listing 6.1: SimpleDivisionOperation.java\n\n\n 1 public class SimpleDivisionOperation {\n 2   public static void main(String[] args) {\n 3     System.out.println(divide(4, 2));\n 4     if (args.length > 1) {\n 5       int arg0 = Integer.parseInt(args[0]);\n 6       int arg1 = Integer.parseInt(args[1]);\n 7       System.out.println(divide(arg0, arg1));\n 8     }\n 9   }\n10 \n11   public static int divide(int a, int b) {\n12     return a / b;\n13   }\n14 }\n\n\n\n\n\n\n\n\n\nOutput for Code listing 6.1\n\n$ java SimpleDivisionOperation 1 0\n2\nException in thread \"main\" java.lang.ArithmeticException: / by zero\n     at SimpleDivisionOperation.divide(SimpleDivisionOperation.java:12)\n     at SimpleDivisionOperation.main(SimpleDivisionOperation.java:7)Such exceptional code that results in erroneous interpretations at program runtime usually results in errors that are called exceptions in Java. When the Java interpreter encounters an exceptional code, it halts execution and displays information about the error that occurs. This information is known as a stack trace. The stack trace in the above example tells us more about the error, such as the thread  \"main\"  where the exception occurred, the type of exception  java.lang.ArithmeticException, a comprehensible display message  / by zero, and the exact methods and the line numbers where the exception may have occurred.", "subdata": [{"content": "The preceding exception could have been created explicitly by the developer as it is the case in the following code:Code listing 6.2: SimpleDivisionOperation.java\n\n\n 1 public class SimpleDivisionOperation {\n 2   public static void main(String[] args) {\n 3     System.out.println(divide(4, 2));\n 4     if (args.length > 1) {\n 5       // Convert a string to an integer\n 6       int arg0 = Integer.parseInt(args[0]);\n 7       int arg1 = Integer.parseInt(args[1]);\n 8       System.out.println(divide(arg0, arg1));\n 9     }\n10   }\n11 \n12   public static int divide(int a, int b) {\n13     if (b == 0) {\n14       throw new ArithmeticException(\"You can\\'t divide by zero!\");       \n15     } else {\n16       return a / b;\n17     }\n18   }\n19 }\n\n\n\n\n\n\n\n\n\nOutput for Code listing 6.2\n\n$ java SimpleDivisionOperation 1 0\n2\nException in thread \"main\" java.lang.ArithmeticException: You can't divide by zero!\nat SimpleDivisionOperation.divide(SimpleDivisionOperation.java:14)\nat SimpleDivisionOperation.main(SimpleDivisionOperation.java:7)Note that when b equals zero, there is no return value. Instead of a java.lang.ArithmeticException generated by the Java interpreter itself, it is an exception created by the coder. The result is the same. It shows you that an exception is an object. Its main particularity is that it can be thrown. An exception object must inherit from java.lang.Exception. Standard exceptions have two constructors:The default constructor; and,\nA constructor taking a string argument so that you can place pertinent information in the exception.Code section 6.1: Instance of an exception object with the default constructor.\n\n\n1 new Exception();Code section 6.2: Instance of an Exception object by passing string in constructor.\n\n\n1 new Exception(\"Something unexpected happened\");This string can later be extracted using various methods, as you can see in the code listing 6.2.You can throw any type of Throwable object using the keyword throw. It interrupts the method. Anything after the throw statement would not be executed, unless the thrown exception is handled. The exception object is not returned from the method, it is thrown from the method. That means that the exception object is not the return value of the method and the calling method can be interrupted too and so on and so on...Typically, you'll throw a different class of exception for each different type of error. The information about the error is represented both inside the exception object and implicitly in the name of the exception class, so someone in the bigger context can figure out what to do with your exception. Often, the only information is the type of exception, and nothing meaningful is stored within the exception object.Oracle standard exception classes[edit]The box 6.1 below talks about the various exception classes within the java.lang package.Box 6.1: The Java exception classes\n\nThrowable\nThe Throwable class is the superclass of all errors and exceptions in the Java language. Only objects that are instances of this class (or one of its subclasses) are thrown by the Java Virtual Machine or can be thrown by the Java throw statement.\nA throwable contains a snapshot of the execution stack of its thread at the time it was created. It can also contain a message string that gives more information about the error. Finally, it can contain a cause: another throwable that caused this throwable to get thrown. The cause facility was added in release 1.4. It is also known as the chained exception facility, as the cause can, itself, have a cause, and so on, leading to a \"chain\" of exceptions, each caused by another.\nError\nAn Error indicates serious problems that a reasonable application should not try to handle. Most such errors are abnormal conditions.\nException\nThe class Exception and its subclasses are a form of Throwable that indicates conditions that a reasonable application might want to handle. Also this is the class that a programmer may want to extend when adding business logic exceptions.\nRuntimeException\nRuntimeException is the superclass of those exceptions that can be thrown during the normal operation of the Java Virtual Machine. A method is not required to declare in its throws clause any subclasses of RuntimeException that might be thrown during the execution of the method but not caught.\n\n\nFigure 6.2: The exception classes and their inheritance model in the JCL.", "title": "Exception object[edit]"}, {"content": "By default, when an exception is thrown, the current method is interrupted, the calling method is interrupted too and so on till the main method. A thrown exception can also be caught using a try/catch statement. Below is how a try/catch statement works:Code section 6.3: Division into a try block.\n\n\n 1 int a = 4;\n 2 int b = 2;\n 3 int result = 0;\n 4 try {\n 5   int c = a / b;\n 6   result = c;\n 7 } catch(ArithmeticException ex) {\n 8   result = 0;\n 9 }\n10 return result;The executed code lines have been highlighted. When no exception is thrown, the method flow executes the try statement and not the catch statement.Code section 6.4: Catching 'division by zero' errors.\n\n\n 1 int a = 4;\n 2 int b = 0;\n 3 int result = 0;\n 4 try {\n 5   int c = a / b;\n 6   result = c;\n 7 } catch(ArithmeticException ex) {\n 8   result = 0;\n 9 }\n10 return result;As there is a thrown exception at line 5, the line 6 is not executed, but the exception is caught by the catch statement so the catch block is executed. The following code is also executed. Note that the catch statement takes an exception as parameter. There is a third case: when the exception is not from the same class as the parameter:Code section 6.5: Uncaught exception.\n\n\n 1 int a = 4;\n 2 int b = 0;\n 3 int result = 0;\n 4 try {\n 5   int c = a / b;\n 6   result = c;\n 7 } catch(NullPointerException ex) {\n 8   result = 0;\n 9 }\n10 return result;It is as if there is no try/catch statement. The exception is thrown to the calling method.", "title": "try/catch statement[edit]"}, {"content": "A try/catch statement can contain several catch blocks, to handle different exceptions in different ways. Each catch block must take a parameter of a different throwable class. A thrown object may match several catch block but only the first catch block that matches the object will be executed. A catch-block will catch a thrown exception if and only if:the thrown exception object is the same as the exception object specified by the catch-block.\nthe thrown exception object is the subtype of the exception object specified by the catch-block.This means that the catch block order is important. As a consequence, you can't put a catch block that catches all the exception (which take a java.lang.Exception as parameter) before a catch block that catches a more specific exception as the second block could never be executed.Code section 6.6: Exception handling with catch blocks.\n\n\n 1 try {\n 2   // Suppose the code here throws any exceptions,\n 3   // then each is handled in a separate catch block.\n 4 \n 5   int[] tooSmallArray = new int[2];\n 6   int outOfBoundsIndex = 10000;\n 7   tooSmallArray[outOfBoundsIndex] = 1;\n 8 \n 9   System.out.println(\"No exception thrown.\");\n10 } catch(NullPointerException ex) {\n11   System.out.println(\"Exception handling code for the NullPointerException.\");\n12 } catch(NumberFormatException ex) {\n13   System.out.println(\"Exception handling code for the NumberFormatException.\");\n14 } catch(ArithmeticException | IndexOutOfBoundsException ex) {\n15   System.out.println(\"Exception handling code for ArithmeticException\"\n16     + \" or IndexOutOfBoundsException.\");\n17 } catch(Exception ex) {\n18   System.out.println(\"Exception handling code for any other Exception.\");\n19 }\n\n\n\n\n\n\n\n\n\nOutput for Code section 6.6\n\nException handling code for ArithmeticException or IndexOutOfBoundsException.At line 14, we use a multi-catch clause. It is available since the JDK 7. This is a combination of several catch clauses and let's you handle exceptions in a single handler while also maintaining their types. So, instead of being boxed into a parent Exception super-class, they retain their individual types.You can also use the java.lang.Throwable class here, since Throwable is the parent class for the application-specific Exception classes. However, this is discouraged in Java programming circles. This is because Throwable happens to also be the parent class for the non-application specific Error classes which are not meant to be handled explicitly as they are catered for by the JVM itself.", "title": "catch blocks[edit]"}, {"content": "A finally block can be added after the catch blocks. A finally block is always executed, even when no exception is thrown, an exception is thrown and caught, or an exception is thrown and not caught. It's a place to put code that should always be executed after an unsafe operation like a file close or a database disconnection. You can define a try block without catch block, however, in this case, it must be followed by a finally block.", "title": "finally block[edit]"}, {"content": "Let's examine the following code:Code section 6.7: Handling exceptions.\n\n\n 1 public void methodA() throws SomeException {\n 2     // Method body\n 3 }\n 4 \n 5 public void methodB() throws CustomException, AnotherException {\n 6     // Method body\n 7 }\n 8 \n 9 public void methodC() {\n10     methodB();\n11     methodA();\n12 }In the code section 6.7, methodC is invalid. Because methodA and methodB pass (or throw) exceptions, methodC must be prepared to handle them. This can be handled in two ways: a try-catch block, which will handle the exception within the method and a throws clause which would in turn throw the exception to the caller to handle. The above example will cause a compilation error, as Java is very strict about exception handling. So the programmer is forced to handle any possible error condition at some point.A method can do two things with an exception: ask the calling method to handle it by the throws declaration or handle the exception inside the method by the try-catch block.To work correctly, the original code can be modified in multiple ways. For example, the following:Code section 6.8: Catching and throwing exceptions.\n\n\n1 public void methodC() throws CustomException, SomeException {\n2   try {\n3     methodB();\n4   } catch(AnotherException e) {\n5     // Handle caught exceptions.\n6   }\n7   methodA();\n8 }The AnotherException from methodB will be handled locally, while CustomException and SomeException will be thrown to the caller to handle it. Most of the developers are embarrassed when they have to choose between the two options. This type of decision should not be taken at development time. If you are a development team, it should be discussed between all the developers in order to have a common exception handling policy.", "title": "Example of handling exceptions[edit]"}], "title": "Throwing and Catching Exceptions"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Checked_Exceptions", "content": "Navigate Exceptions topic:(vde)\n\n Throwing and catching exceptions\n Checked exceptions\n Unchecked exceptions\n Preventing NullPointerException\n Stack trace\n Nesting exceptions (chained exceptions)A checked exception is a type of exception that must be either caught or declared in the method in which it is thrown. For example, the java.io.IOException is a checked exception. To understand what is a checked exception, consider the following code:Code section 6.9: Unhandled exception.\n\n\n1 public void ioOperation(boolean isResourceAvailable) {\n2   if (!isResourceAvailable) {\n3     throw new IOException();\n4   }\n5 }This code won't compile because it can throw a checked exception. The compilation error can be resolved in either of two ways: By catching the exception and handling it, or by declaring that the exception can be thrown using the throws keyword.Code section 6.10: Catching an exception.\n\n\n1 public void ioOperation(boolean isResourceAvailable) {\n2   try {\n3     if (!isResourceAvailable) {\n4       throw new IOException();\n5     }\n6   } catch(IOException e) {\n7     // Handle caught exceptions.\n8   }\n9 }\n\n\n\n\n\n\n\n\n\nCode section 6.11: Declaring an exception.\n\n\n1 public void ioOperation(boolean isResourceAvailable) throws IOException {\n2   if (!isResourceAvailable) {\n3     throw new IOException();\n4   }\n5 }In the Java class hierarchy, an exception is a checked exception if it inherits from java.lang.Throwable, but not from java.lang.RuntimeException or java.lang.Error. All the application or business logic exceptions should be checked exceptions.It is possible that a method declares that it can throw an exception, but actually it does not. Still, the caller has to deal with it. The checked exception declaration has a domino effect. Any methods that will use the previous method will also have to handle the checked exception, and so on.So the compiler for the Java programming language checks, at compile time, that a program contains handlers for all application exceptions, by analyzing each method body. If, by executing the method body, an exception can be thrown to the caller, that exception must be declared. How does the compiler know whether a method body can throw an exception? That is easy. Inside the method body, there are calls to other methods; the compiler looks at each of their method signature, what exceptions they declared to throw.", "subdata": [{"content": "This may look boring to the developer but it forces them to think about all the checked exceptions and increase the code quality. This compile-time checking for the presence of exception handlers is designed to make the application developer life easier. To debug whether a particular thrown exception has a matching catch would be a long process. In conventional languages like C, and C++, a separate error handling debugging were needed. In java we can be sure that when an application exception is thrown, that exception somewhere in the program is handled. In C, and C++, that has to be tested. In Java that does not need to be tested, so the freed up time can be used for more meaningful testing, testing the business features.", "title": "Why Force Exception Handling?[edit]"}, {"content": "The checked exception classes specified after the throws keyword are part of the contract between the implementer and user. An overriding method can declare the same exceptions, subclasses or no exceptions.", "title": "What Exceptions can be Declared when Overriding a Method?[edit]"}], "title": "Checked Exceptions"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Unchecked_Exceptions", "subdata": [], "title": "Unchecked Exceptions"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Preventing_NullPointerException", "content": "Navigate Exceptions topic:(vde)\n\n Throwing and catching exceptions\n Checked exceptions\n Unchecked exceptions\n Preventing NullPointerException\n Stack trace\n Nesting exceptions (chained exceptions)NullPointerException is a RuntimeException. In Java, a special null value can be assigned to an object reference. NullPointerException is thrown when an application attempts to use an object reference that has the null value. These include:Calling an instance method on the object referred by a null reference.\nAccessing or modifying an instance field of the object referred by a null reference.\nIf the reference type is an array type, taking the length of a null reference.\nIf the reference type is an array type, accessing or modifying the slots of a null reference.\nIf the reference type is a subtype of Throwable, throwing a null reference.Applications should throw instances of this class to indicate other illegal uses of the null object.Code section 6.13: Null pointer.\n\n\n1 Object obj = null;\n2 obj.toString();  // This statement will throw a NullPointerExceptionThe above code shows one of the pitfalls of Java and the most common source of bugs. No object is created and the compiler does not detect it. NullPointerException is one of the most common exceptions thrown in Java.", "subdata": [{"content": "The reason we need it is because many times we need to create an object reference before the object itself is created. Object references cannot exist without a value, so we assign the null value to it.Code section 6.14: Non-instantiated declared object.\n\n\n1 public Person getPerson(boolean isWoman) {\n2   Person person = null;\n3   if (isWoman) {\n4     person = createWoman();\n5   } else {\n6     person = createMan();\n7   }\n8   return person;\n9 }In code section 6.14 we want to create the Person inside the if-else, but we also want to return the object reference to the caller, so we need to create the object reference outside of the if-else, because of the scoping rule in Java. Incorrect error-handling and poor contract design can be a pitfall with any programming language. This is also true for Java.Now we will describe how to prevent NullPointerException. We do not describe general techniques for how you should program Java, we just hope to make you more aware of null values, and to be more careful about generating them yourself.This list is not complete  there are no rules for preventing NullPointerException entirely in Java, because the standard libraries have to be used, and they can cause NullPointerExceptions. Also, it is possible to observe an uninitialized final field in Java, so you can't even treat a final field as being completely trusted during the object's creation.A good approach is to learn how to deal with NullPointerExceptions first, and become competent with that. These suggestions will help you to cause less NullPointerExceptions, but they don't replace the need to know about NullPointerExceptions.", "title": "Why do we need null?[edit]"}, {"content": "When you compare a variable with a string literal, most of people would do that this way:Code section 6.15: Bad comparison.\n\n\n1 if (state.equals(\"OK\")) {\n2   ...\n3 }Always put the string literal first:Code section 6.16: Better comparison.\n\n\n1 if (\"OK\".equals(state)) {\n2   ...\n3 }If the state variable is null, you get a NullPointerException in the first example, but not in the second one.", "title": "Comparing string variable with a string literal[edit]"}, {"content": "This means not doing things like:Code section 6.17: Declaring an exception.\n\n\n 1 String s = null;\n 2 while (something) {\n 3     if (something2) {\n 4         s = \"yep\";\n 5     }\n 6 }\n 7 \n 8 if (s != null) {\n 9     something3(s);\n10 }You can replace this with:Code section 6.18: Declaring an exception.\n\n\n1 boolean done = false;\n2 \n3 while (!done && something) {\n4     if (something2) {\n5        done = true;\n6        something3(\"yep\");\n7     }\n8 }You might also consider replacing null with \"\" in the first example, but default values bring about bugs caused by default values being left in place. A NullPointerException is actually better, as it allows the runtime to tell you about the bug, rather than just continue with a default value.", "title": "Minimize the use of the keyword 'null' in assignment statements[edit]"}, {"content": "An array created using new Object[10] has 10 null pointers. That's 10 more than we want, so use collections instead, or explicitly fill the array at initialization with:Code section 6.19: Declaring an exception.\n\n\n1 Object[] objects = {\"blah\", 5, new File(\"/usr/bin\")};or:Code section 6.20: Declaring an exception.\n\n\n1 Object[] objects;\n2 objects = new Object[]{\"blah\", 5, new File(\"/usr/bin\")};", "title": "Minimize the use of the new Type[int] syntax for creating arrays of objects[edit]"}, {"content": "Many methods that can return a reference can return a null reference. Make sure you check these. For example:Code section 6.21: Declaring an exception.\n\n\n1 File file = new File(\"/etc\");\n2 File[] files = file.listFiles();\n3 if (files != null) {\n4     stuff\n5 }File.listFiles() can return null if /etc is not a directory.You can decide to trust some methods not to return null, if you like, but that's an assumption you're making. Some methods that don't specify that they might return null, actually do, instead of throwing an exception.", "title": "Check all references obtained from 'untrusted' methods[edit]"}, {"content": "Beware if you loop on an array or a collection in a for each loop.Code section 6.22: Visit a collection.\n\n\n1 Collection<Integer> myNumbers = buildNumbers();\n2 for (Integer myNumber : myNumbers) {\n3   System.out.println(myNumber);\n4 }If the object is null, it does not just do zero loops, it throws a null pointer exception. So don't forget this case. Add an if statement or return empty collections:Code section 6.23: Visit a collection safety.\n\n\n1 Collection<Integer> myNumbers = buildNumbers();\n2 if (myNumbers != null) {\n3   for (Integer myNumber : myNumbers) {\n4     System.out.println(myNumber);\n5   }\n6 }", "title": "For each loop trap[edit]"}], "title": "Preventing NullPointerException"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Stack_trace", "content": "Navigate Exceptions topic:(vde)\n\n Throwing and catching exceptions\n Checked exceptions\n Unchecked exceptions\n Preventing NullPointerException\n Stack trace\n Nesting exceptions (chained exceptions)Stack Trace is a list of method calls from the point when the application was started to the point where the exception was thrown. The most recent method calls are at the top.Code listing 6.3: StackTraceExample.java\n\n\n 1 public class StackTraceExample {\n 2   public static void main(String[] args) {\n 3     method1();\n 4   }\n 5 \n 6   public static void method1() {\n 7     method11();\n 8   }\n 9 \n10   public static void method11() {\n11     method111();\n12   }\n13 \n14   public static void method111() {\n15     throw new NullPointerException(\"Fictitious NullPointerException\");\n16   }\n17 }\n\n\n\n\n\n\n\n\n\nOutput for Code listing 6.3\n\nException in thread \"main\" java.lang.NullPointerException: Fictitious NullPointerException\nat StackTraceExample.method111(StackTraceExample.java:15)\nat StackTraceExample.method11(StackTraceExample.java:11)\nat StackTraceExample.method1(StackTraceExample.java:7)\nat StackTraceExample.main(StackTraceExample.java:3)The stack trace can be printed to the standard error by calling the public void printStackTrace() method of an exception.From Java 1.4, the stack trace is encapsulated into an array of a java class called java.lang.StackTraceElement. The stack trace element array returned by Throwable.getStackTrace() method. Each element represents a single stack frame. All stack frames except for the one at the top of the stack represent a method invocation. The frame at the top of the stack represents the execution point at which the stack trace was generated. Typically, this is the point at which the throwable corresponding to the stack trace was created.A stack frame represents the following information:Code section 6.24: Stack frame.\n\n\n1 public StackTraceElement(String declaringClass,\n2                          String methodName,\n3                          String fileName,\n4                          int lineNumber);Creates a stack trace element representing the specified execution point.", "subdata": [], "title": "Stack trace"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Nesting_Exceptions", "subdata": [], "title": "Nesting Exceptions"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Concurrent_Programming", "subdata": [], "title": "Concurrent Programming"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Threads_and_Runnables", "content": "Navigate Concurrent Programming topic: (vde)\n\n Threads and Runnables\n Basic Synchronization\n Client Server Programming\n Remote Method Invocation (RMI)\n Enterprise JavaBean Programming (EJB)\n Java Spaces Programming (Jini)CPUs for any computer are designed to execute one task at any given time, yet we run multiple applications side-by-side and everything works in perfect congruence. It's not just because CPUs are extremely fast in performing calculations, it's because CPUs use a clever device of dividing their time amongst various tasks. Each application or task that is invoked on a computer gets associated with the CPU in the form of a process. A CPU therefore manages various processes, and jumps back and forth amongst each process giving it a fraction of its time and processing capability. This happens so fast that to a normal computer user it presents with the illusion of processes being run simultaneously. This capability of the CPU to divide its time amongst processes is called multitasking.So, if we run a Java application on a computer, we are effectively creating a process with the CPU that gets a fraction of the CPU's time. In Java parlance, this main process gets called the daemon process or the daemon thread. But, Java goes one step further. It allows programmers to divide this daemon thread into several multiple threads which get executed simultaneously (much like a CPU) hence providing a Java application with a finer multitasking capability called multithreading.In this section, we will take a look at what threads are and how multithreading is implemented within a Java program to make it appear congruent and effectively fast to respond.", "subdata": [{"content": "In light of the above discussion, a thread is the smallest unit of processing that can be scheduled by an operating system. Therefore, using threads, a programmer can effectively create two or more tasks[1] that run at the same time. The first call-to-action is to implement a set of tasks that a particular thread would execute. To do so, we require the creation of a Runnable process.Creating a Runnable process block[edit]A Runnable process block is a simple class that implements a run() method. Within the run() method is the actual task that needs to be executed by a running thread. By implementing a class with the Runnable interface, we ensure that the class holds a run() method. Consider the following program:Code listing 1: A runnable process\n\n\nimport java.util.Random;\npublic class RunnableProcess implements Runnable {\n    private String name;\n    private int time;\n    private Random rand = new Random();\n\n    public RunnableProcess(String name) {\n        this.name = name;\n        this.time = rand.nextInt(999);\n    }\n\n    public void run() {\n        try {\n            System.out.printf(\"%s is sleeping for %d \\n\", this.name, this.time);\n            Thread.sleep(this.time);\n            System.out.printf(\"%s is done.\\n\", this.name);\n        } catch(Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n}In the above code, we create a class called RunnableProcess and implement the Runnable interface to ensure that we have a run() method in the class declaration.Code section 1.1: Implementing the Runnable interface\n\n\npublic class RunnableProcess implements Runnable {\n    ...\n    public void run() {\n        ...\n    }\n}We then declare the rest of the logic for the class. For the constructor, we take a String parameter that would serve as the name of the class. Then, we initialize the class member variable time with a random number between 0 and 999. To ensure the initialization of a random number, we use the Random class in the java.util package.Code section 1.2: Including ability to generate random integers between 0 and 999\n\n\nimport java.util.Random;\n...\nprivate Random rand = new Random();\n...\nthis.time = rand.nextInt(999);The actual task that would be executed per this runnable block is presented within the run() method. To keep safe from exceptions occurring because of the concurrent programming, we wrap the code within this method with a try..catch block. The executing task actually consists of just three statements. The first outputs the provided name for the Runnable process, and the last reports that the thread has executed. Perhaps the most intriguing part of the code is the second statement: Thread.sleep(...).Code section 1.3: The actual runnable process task\n\n\n...\nSystem.out.printf(\"%s is sleeping for %d \\n\", this.name, this.time);\nThread.sleep(this.time);\nSystem.out.printf(\"%s is done \\n\", this.name);\n...This statement allows the thread executing the current runnable block to halt its execution for the given amount of time. This time is presented in milliseconds. But for our convenience, this time would be the random number generated in the constructor and can be anywhere between 0 and 999 milliseconds. We will explore this in a later section. Creating a Runnable process block is just the beginning. No code is actually executed. To do so, we would require the creation of threads that would then individually execute this task.Creating threads[edit]Once we have a Runnable process block, we can create various threads that can then execute the logic encased within such blocks. Multithreading capabilities in Java are utilized and manipulated using the Thread class. A Thread object therefore holds all the necessary logic and devices to create truly multithreaded programs. Consider the following program:Code listing 2: Creating Thread objects\n\n\npublic class ThreadLogic {\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new RunnableProcess(\"Thread-1\"));\n        Thread t2 = new Thread(new RunnableProcess(\"Thread-2\"));\n        Thread t3 = new Thread(new RunnableProcess(\"Thread-3\"));\n    }\n}Creating threads is as simple as the above program suggests. You just have to create an object of the Thread class and pass a reference to a Runnable process object. In the case above, we present the Thread constructor with the class object for the RunnableProcess class that we created in code listing 1. But for each object, we give a different name (i.e., \"Thread-1\" and \"Thread-2\", etc.) to differentiate between the three Thread objects. The above example only declares Thread objects and hasn't yet started them for execution.Starting threads[edit]Now, that we know how to effectively create a Runnable process block and a Thread object that executes it, we need to understand how to start the created Thread objects. This couldn't be simpler. For this process, we will be calling the start() method on the Thread objects and voil, our threads will begin executing their individual process tasks.Code listing 3: Starting the Thread objects\n\n\npublic class ThreadLogic {\n    public static void main(String[] args) {\n        Thread t1 = new Thread(new RunnableProcess(\"Thread-1\"));\n        Thread t2 = new Thread(new RunnableProcess(\"Thread-2\"));\n        Thread t3 = new Thread(new RunnableProcess(\"Thread-3\"));\n\n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}The above code will start all three declared threads. This way, all three threads will begin their execution one-by-one. However, this being concurrent programming and us having declared random times for the halting of the execution, the outputs for every one of us would differ. Following is the output we received when we executed the above program.Output for code listing 3\n\nThread-1 is sleeping for 419\nThread-3 is sleeping for 876\nThread-2 is sleeping for 189\nThread-2 is done\nThread-1 is done\nThread-3 is doneIt should be noted that the execution of the Thread didn't occur in the desired order. Instead of the order t1t2t3, the threads executed in the order of t1t3t2. The order in which the threads are executed is completely dependent on the operating system and may change for every execution of the program, thus making output of multithreaded application difficult to predict and control. Some people suggest that this is the major reason that adds to the complexity of multithreaded programming and its debugging. However, it should be observed that once the threads were put to sleep using the Thread.sleep(...) function, the execution intervals and order can be predicted quite capably. The thread with the least amount of sleeping time was t2 (\"Thread-2\") with 189 milliseconds of sleep hence it got called first. Then t1 was called and finally t3 was called.", "title": "Threads[edit]"}, {"content": "It can be said that the execution order of the threads was manipulated to some degree using the Thread.sleep(...) method. The Thread class has such static methods that can arguably affect the execution order and manipulation of threads. Below are some useful static methods in the Thread class. These methods when called will only affect the currently running threads.Method\nDescription\n\n\nThread.currentThread()\nReturns the currently executing thread at any given time.\n\n\nThread.dumpStack()\nPrints a stack trace of the currently running thread.\n\n\nThread.sleep(long millis)\nHalts execution of the currently running thread for the given amount of time (in milliseconds).\nthrows InterruptedException\n\n\nThread.sleep(long millis, int nanos)\nHalts execution of the currently running thread for the given amount of time (in milliseconds plus provided nanoseconds).\nthrows InterruptedException\n\n\nThread.yield()\nTemporarily pauses the execution of the currently running thread to allow other threads to execute.", "title": "Manipulating threads[edit]"}, {"content": "The text in its current form is incomplete.Given below is an example of creating and running multiple threads that behave in a synchronous manner such that when one thread is using a particular resource, the others wait until the resource has been released. We will talk more about this in later sections.Code listing 4: Creation of the multiple Thread objects running synchronously\n\n\npublic class MultiThreadExample {\n    public static boolean cthread;\n    public static String stuff = \" printing material\";\n\n    public static void main(String args[]) {\n        Thread t1 = new Thread(new RunnableProcess());\n        Thread t2 = new Thread(new RunnableProcess());\n        t1.setName(\"Thread-1\");\n        t2.setName(\"Thread-2\");\n        t2.start();\n        t1.start();\n    }\n    /*\n     * Prints information about the current thread and the index it is\n     * on within the RunnableProcess\n     */\n    public static void printFor(int index) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(Thread.currentThread().getName()).append(stuff);\n        sb.append(\" for the \").append(index).append(\" time.\");\n        System.out.print(sb.toString());\n    }\n}\nclass RunnableProcess implements Runnable {\n    public void run() {\n        for(int i = 0; i < 10; i++) {\n            synchronized(MultiThreadExample.stuff) {\n                MultiThreadExample.printFor(i);\n                try {\n               \t    MultiThreadExample.stuff.notifyAll();\n                    MultiThreadExample.stuff.wait();\n                } catch(InterruptedException ex) {\n                   ex.printStackTrace();\n                }\n            }\n        }\n    }\n}Output for code listing 4\n\nThread-1 printing material for the 0 time.\nThread-2 printing material for the 0 time.\nThread-1 printing material for the 1 time.\nThread-2 printing material for the 1 time.\nThread-1 printing material for the 2 time.\nThread-2 printing material for the 2 time.\nThread-1 printing material for the 3 time.\nThread-2 printing material for the 3 time.\nThread-1 printing material for the 4 time.\nThread-2 printing material for the 4 time.\nThread-1 printing material for the 5 time.\nThread-2 printing material for the 5 time.\nThread-1 printing material for the 6 time.\nThread-2 printing material for the 6 time.\nThread-1 printing material for the 7 time.\nThread-2 printing material for the 7 time.\nThread-1 printing material for the 8 time.\nThread-2 printing material for the 8 time.\nThread-1 printing material for the 9 time.\nThread-2 printing material for the 9 time.", "title": "Synchronization[edit]"}, {"content": "Video games intensively use threadsThreads are used intensively in applications that require a considerable amount of CPU usage. For operations that are time-consuming and intensive, it is usually advised to use threads. A example of such an application would be a typical video game. At any given time, a video game involves various characters, objects in the surroundings and other such nuances that needs to be dealt with simultaneously. Dealing with each element or object within the game requires a fair amount of threads to monitor every object.For example, take this screen-shot of a role-playing strategy game on the right. Here the game visuals depict various in-game characters moving about on the screen. Now imagine processing the movements, direction and behaviors of each of the characters visible on screen. It would certainly take a lot of time moving each character one-by-one if this were to be done one task after another. However if fundamentals of multi-threading are employed, each character would move in a synchronous manner with respect to others.Threads are not only used heavily in video games, their use is common in everything from simple browser applications to complex operating systems and networking applications. Today it often goes beyond the simple preference of the developer but into the need to maximize the usefulness of contemporaneous hardware that is predicated in heavy multitasking.", "title": "Where are threads used?[edit]"}], "title": "Threads and Runnables"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Basic_Synchronization", "subdata": [], "title": "Basic Synchronization"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Client_Server", "content": "Navigate Concurrent Programming topic: (vde)\n\n Threads and Runnables\n Basic Synchronization\n Client Server Programming\n Remote Method Invocation (RMI)\n Enterprise JavaBean Programming (EJB)\n Java Spaces Programming (Jini)In 1990s, the trend was moving away from Mainframe computing to Client/Server as the price of Unix servers dropped. The database access and some business logic were centralized on the back-end server, collecting data from the user program was installed on the front-end users' \"client\" computers. In the Java world there are three main ways the front-end and the back-end can communicate.The client application uses JDBC (Java DataBase Connectivity API) to connect to the data base server, (Limited business logic on the back-end, unless using Stored procedures).\nThe client application uses RMI (Remote Method Invocation) to communicate with the back-end.\nThe client application uses a socket connection to communicate with the back-end.", "subdata": [], "title": "Client Server"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Remote_Method_Invocation", "content": "Navigate Concurrent Programming topic: (vde)\n\n Threads and Runnables\n Basic Synchronization\n Client Server Programming\n Remote Method Invocation (RMI)\n Enterprise JavaBean Programming (EJB)\n Java Spaces Programming (Jini)Java's Remote Method Invocation (commonly referred to as RMI) is used for client and server models. RMI is the object oriented equivalent to RPC (Remote procedure call).The Java Remote Method Invocation (RMI) system allows an object running in one Java Virtual Machine (VM) to invoke methods of an object running in another Java VM. RMI provides for remote communication between programs written in the Java programming language.RMI is only defined for use with the Java platform. If you need to call methods between different language environments, use CORBA. With CORBA a Java client can call a C++ server and/or a C++ client can call a Java server. With RMI that can not be done.", "subdata": [{"content": "The remote method invocation goes through a STUB on the client side and a so called SKELETON on the server side.CLIENT --> STUB --> ... Network ... --> SKELETON --> REMOTE OBJECTPrior to Java 1.2 the skeleton had to be explicitly generated with the rmic tool. Since 1.2 a dynamic skeleton is used, which employs the features of Java Reflection to do its work.", "title": "STUB and SKELETON[edit]"}, {"content": "Remote objects can be listed in the RMI Registry. Clients can get a reference to the remote object by querying the Registry. After that, the client can call methods on the remote objects. (Remote object references can also be acquired by calling other remote methods. The Registry is really a 'bootstrap' that solves the problem of where to get the initial remote reference from.)The RMI Registry can either be started within the server JVM, via the LocateRegistry.createRegistry() API, or a separate process called rmiregistry that has to be started before remote objects can be added to it, e.g. by the command line in Unix:rmiregistry on Unix\n\nrmiregistry <port> &or under Windows:rmiregistry on Windows\n\nstart rmiregistry <port>If port is not specified the default 1099 is used. The client will need to connect to this port to access the Registry.The Registry can also be started from a program by calling the following code:Code section 1: rmiregistry starting\n\n\nimport java.rmi.registry.LocateRegistry;\n...\nRegistry reg = LocateRegistry.createRegistry(iPort);Objects passed in as parameters to the remote objects's methods will be passed by value. If the remote object changes the passed-in object values, it won't be reflected on the client side, this is opposite what happens when a local object is called. Objects that used as parameters for remote methods invocation must implement the java.io.Serializable interface, as they are going to be serialized when passed through the network, and a new object will be created on the other side.However, exported remote objects passed as parameters are passed by remote reference.", "title": "rmiregistry[edit]"}, {"content": "", "title": "rmic tool[edit]"}, {"content": "The remote object has to either extend the java.rmi.server.UnicastRemoteObject object, or be explicitly exported by calling the java.rmi.server.UnicastRemoteObject.exportObject() method.", "title": "RMI Remote object[edit]"}], "title": "Remote Method Invocation"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/EJB", "content": "Navigate Concurrent Programming topic: (vde)\n\n Threads and Runnables\n Basic Synchronization\n Client Server Programming\n Remote Method Invocation (RMI)\n Enterprise JavaBean Programming (EJB)\n Java Spaces Programming (Jini)Enterprise JavaBeans (EJB) technology is the server-side component architecture for Java Platform, Enterprise Edition (Java EE). EJB technology enables to create distributed, transactional, secure and portable application component objects.EJB supports the development and deployment of component based business applications. Applications written using the Enterprise JavaBeans architecture are scalable, transactional, and multi-user secure. These applications may be written once, and then deployed on any server platform that supports the Enterprise JavaBeans specification.", "subdata": [{"content": "", "title": "EJB History[edit]"}, {"content": "Security Management\nPersistence Management\nTransaction Management\nDistributable Interoperable Management\nException Management", "title": "EJB Features[edit]"}, {"content": "Session Beans\n\nStateFull Session Beans\nStateless Session Beans\n\n\nEntity Beans\nMessage Driven Beans", "title": "Types of EJB[edit]"}, {"content": "EJBs are an attempt to create component based application development. With EJBs it is easier to develop components, but the same basic and fundamental maintenance problem will still be there. That is the dependencies between the client and the components. The usage of a component is fixed, changes on the component interface cause to break the client code. The same client/server problem comes back, that is as the users of a component increases the maintenance of that component getting harder and harder until it goes to impossible.For a true component based application development we need to standardize the usage of a component. The client must somehow flexibly figure out automatically how to use a component, so component changes don't affect any of the clients using that component. Without that flexibility, a true component based application development will remain as an idea, a dream, a theory without significant practical use. If we had that flexibility, it could cause a paradigm shift in the software development industry.JINI was an attempt from Sun to address this flexibility problem. In JINI, the client download the component interface implementation and execute it in the client space.So we need to mix (somehow) EJB and JINI technologies to come up with a true flexible component based technology.", "title": "Problems with EJB as a component based development[edit]"}, {"content": "Sun EJB Home", "title": "References[edit]"}, {"content": "EJB in Java EE", "title": "See also[edit]"}], "title": "EJB"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/JavaSpaces", "content": "Navigate Concurrent Programming topic: (vde)\n\n Threads and Runnables\n Basic Synchronization\n Client Server Programming\n Remote Method Invocation (RMI)\n Enterprise JavaBean Programming (EJB)\n Java Spaces Programming (Jini)After J2EE, Sun had a vision about the next step of network computing: in a network environment, there would be many independent services and consumers. That is JavaSpaces. JavaSpaces would allow these services/consumers to interact dynamically with each other in a robust way. It can be viewed as an object repository that provides a distributed persistent object exchange mechanism (persistent can be in memory or disk) for Java objects. It can be used to store the system state and implement distributed algorithms. In a JavaSpace, all communication partners (peers) communicate by sharing state. It is an implementation of the Tuple spaces idea.JavaSpaces is used when someone wants to achieve scalability and availability and at the same time reducing the complexity of the overall system.Processes perform simple operations to write new objects into a JavaSpace, take objects from a JavaSpace, or read (make a copy of) objects from the JavaSpace.In conventional applications, objects are assembled from the database before presenting to the end user. In JavaSpace applications, we keep the ready made \"end user\" objects and store them in the JavaSpace. In JavaSpace applications the services are decoupled from each other; they communicate through objects that they write and read/take from the JavaSpace. Services search for objects that they want to take or read from the Space by using template object.", "subdata": [{"content": "JavaSpaces technology is part of the Java Jini technology. The basic features of JINI are:No user intervention is needed when services are brought on or offline. (In contrast to EJBs where the client program has to know the server and port number where the EJB is deployed. In JINI the client is supposed to find, discover the service in the network.)\nSelf healing by adapting when services (consumers of services) come and go. Services need to periodically renew a lease to indicate that they are still available.\nConsumers of JINI services do not need prior knowledge of the service's implementation. The implementation is downloaded dynamically and run on the consumer JVM, without configuration and user intervention. For example, the end user may be presented with slightly different user interface depending which service is being used at the time. The implementation of those user interface code would be provided by the service being used.This fact that the implementation is running on the consumer/client's JVM can increase performance, by eliminating the need of remote calls.A minimal JINI network environment consists of:One or more services\nA lookup-service keeping a list of registered services\nOne or more consumers", "title": "JINI[edit]"}, {"content": "The lookup service is described in the: Jini Lookup Service Specification (reggie). This service interface defines all operations that are possible on the lookup service. Clients locate services by requesting with a lookup server that implements a particular interface. Client asks the lookup server for all services that implement the particular service interface. The lookup service returns service objects for all registered services that implement the given interface. The client may invoke methods on that object in order to interact directly with the server.", "title": "The JINI Lookup Service[edit]"}, {"content": "Jini Discovery and Join Specification describes how does the client find the jini lookup service. There is a protocol to do that, jini comes with a set of API's that implement that protocol. The Jini Discovery Utility Specification defines a set of utility classes that are used to work with the protocol.", "title": "Lookup Discovery[edit]"}, {"content": "When a service registers with the lookup service, it receives a lease from the lookup service, described in the Jini Distributed Leasing Specification.", "title": "Leasing[edit]"}, {"content": "", "title": "Entries and Templates[edit]"}], "title": "JavaSpaces"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Annotations", "subdata": [], "title": "Annotations"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Javadoc", "content": "Navigate Javadoc & Annotations topic: (vde)\n\n Javadoc\n Introduction to Annotation\n Creating custom annotations\n Meta-annotations\n Helping the compilerJava allows users to document the classes and the members by using a particular syntax of comment.", "subdata": [{"content": "A documentation comment is framed by slash-star-star and star-slash (i.e. /** ... */). The documentation is in the HTML format.Code listing 8.1: Example.java\n\n\n1 /**\n2  *  A class to give an <b>example</b> of HTML documentation.\n3  */\n4 public class Example {\n5     /** ...Documentation of a member with the type integer named example... */\n6     public int example;\n7 }A documentation comment is placed just above the commented entity (class, constructor, method, field).In a documentation comment, the first part is a description text in the HTML format. The second part is a list of special attributes whose name starts with an at sign (@):Code section 8.1: Documentation comment.\n\n\n1 /**\n2  *  Get the sum of two integers.\n3  *  @param a The first integer number.\n4  *  @param b The second integer number.\n5  *  @return The value of the sum of the two given integers.\n6  */\n7 public int sum(int a, int b) {\n8     return a + b;\n9 }Get the sum of two integers.\nDescription of the sum method.\n@param a The first integer number.\nDescription attribute of the parameter a of the method.\n@param b The second integer number.\nDescription attribute of the parameter b of the method.\n@return The value of the sum of the two given integers.\nDescription attribute of the value returned by the method.Here is a non exhaustive list of special attributes:Attribute and syntax\nIn a comment of ...\nDescription\n\n\n@author author\nclass\nName of the author of the class.\n\n\n@version version\nclass\nVersion of the class.\n\n\n@deprecated description\nclass, constructor, method, field\nFlags the entity as deprecated (old version), describes why and by what replace it.\nIf the entity flagged as deprecated by this attribute is used, the compiler give a warning.\n\n\n\n@see reference\nclass, constructor, method, field\nAdd a link in the section \"See also\".\n\n\n@param id description\nconstructor and method\nDescribes the method parameter.\n\n\n@return description\nmethod\nDescribes the value returned by the method.\n\n\n@exception type description\nconstructor and method\nDescribes the reason of the throw of an exception of the specified type (throws clause).See also annotations since Java 5.", "title": "Syntax[edit]"}, {"content": "The JDK provides a tool named javadoc which allows to generate the documentation of the well commented classes. The javadoc command without argument give the complete syntax of the command.Example: for a class named Example defined in a package named org.wikibooks.en dans le fichier C:\\ProgJava\\org\\wikibooks\\en\\Example.java:Code listing 8.2: Example.java\n\n\n 1 package org.wikibooks.en;\n 2 \n 3 /**\n 4  *  An example class.\n 5  */\n 6 public class Example {\n 7     /**\n 8     Get the sum of two integers.\n 9     @param a The first integer number.\n10     @param b The second integer number.\n11     @return The value of the sum of the two given integers.\n12     */\n13     public int sum(int a, int b) {\n14         return a + b;\n15     }\n16 }The documentation can be generated in a specific folder (C:\\ProgDoc for example) with the following command:Command 8.1: Documentation generation\n\n$ javadoc -locale en_US -use -classpath C:\\ProgJava -sourcepath C:\\ProgJava -d C:\\ProgDoc org.wikibooks.enThe options of this command are described below:-locale en_US\nThe documentation in US English.\n-use\nCreate the pages about the use of the classes and the packages.\n-classpath C:\\ProgJava\nThe path of the compiled classes (*.class).\n-sourcepath C:\\ProgJava\nThe path of the source classes (*.java).\n-d C:\\ProgDoc\nThe path where the documentation must be generated.\norg.wikibooks.en\nThe name of the package to document. It is possible to specify several packages, or one or several class names to document only those ones.The description page of a package copy the description text from the file named package.html which should be placed in the given folder. In our example, we should document the package in the file C:\\ProgJava\\org\\wikibooks\\en\\package.html.Since Java 5[1], the package.html file can be replaced by a special Java file named package-info.java containing only the package declaration preceding by a documentation comment.Code listing 8.3: C:\\ProgJava\\org\\wikibooks\\en\\package-info.java\n\n\n1 /**\n2  * This fake package is used to illustrate the Java wikibook.\n3  * at <i>en.wikibooks.org</i>.\n4  */\n5 package org.wikibooks.en;", "title": "Documentation[edit]"}], "title": "Javadoc"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Annotations/Introduction", "content": "Navigate Javadoc & Annotations topic: (vde)\n\n Javadoc\n Introduction to Annotation\n Creating custom annotations\n Meta-annotations\n Helping the compiler", "subdata": [{"content": "In Java, an annotation is a language construct (introduced in J2SE 1.5) that provides a mechanism for including metadata directly in the source code.Annotations can provide metadata for Java classes, attributes, and methods. Syntactically, annotations can be viewed as a special kind of modifier and can be used anywhere that other modifiers (such as public, static, or final) can be used.One of the main forces of adding this feature to Java was the wide spread use of XML descriptors to add additional information, metadata, for Java classes. Frameworks like EJB, JSF, Spring, Hibernate were heavily using external XML descriptors. The problem of those external descriptors was that those files are out of reach of the Java compiler and for that reason compiler type checking could not be used. A small spelling mistake bug in a huge XML descriptor file is hard to locate and fix. On the other hand the Java annotations use the Java compiler type checking features so spelling mistakes in annotation names will be caught by the Java compiler.In summary, annotations can be...used as a source of information for the compiler;\nmade available for compile-time or deployment-time processing;\nexamined at runtime.", "title": "Introduction[edit]"}], "title": "Annotations"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Annotations/Custom_Annotations", "content": "Navigate Javadoc & Annotations topic: (vde)\n\n Javadoc\n Introduction to Annotation\n Creating custom annotations\n Meta-annotations\n Helping the compilerAnnotations can be viewed as a source of defining meta-data for a piece of code in Java. The annotation @CodeDescription used in the following sections does not come as a part of the Java API.", "subdata": [{"content": "Before you can use an annotation with classes, theirs members and statements or expressions, you need to define an annotation type. Following is the syntax on how to define a type for the mentioned annotation.Code listing 1.1: Annotation type declaration\n\n\n@interface CodeDescription\n{\n    String author();\n    String version();\n}That's it! Our first ever annotation has been defined. Now, we can use it with any of our classes. An annotation definition if you look closely resembles the definition of a normal interface, except that the interface keyword is preceded by the @ character. Some refer to this syntactical declaration as the annotation type declaration due to the fact that @ is 'AT' or 'Annotation Type' for that very instance.", "title": "Annotation Type Declaration[edit]"}, {"content": "What look like methods in the body of the annotation definition are called annotation element declarations. These are the named entities that we used with the annotation body in the example in the previous section. However, for the sake of clarity, code below also represents the calling of the following annotation:Code listing 1.2: Calling of annotation\n\n\npublic class MyMethod\n{\n    @CodeDescription\n    (\n        author = \"Unknown\",\n        version = \"1.0.0.1\"\n    )\n    public void doSomething()\n    {\n        ...\n    }\n}", "title": "Annotation Element Declarations[edit]"}], "title": "Custom Annotations"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Annotations/Meta-Annotations", "content": "Navigate Javadoc & Annotations topic: (vde)\n\n Javadoc\n Introduction to Annotation\n Creating custom annotations\n Meta-annotations\n Helping the compilerThere are five annotation types in the java.lang.annotation package called meta-annotations. These annotation types are used to annotate other annotation types.", "subdata": [{"content": "If a member is annotated with a type itself marked as @Documented, then that member will be documented as annotating that type.Code listing 1.1: Use of @Documented\n\n\n@interface Secret { }\n\n@Documented\n@interface NotSecret { }\n\n@Secret\n@NotSecret\npublic class Example {\n}In the documentation for the Example class, such as the JavaDoc, Example will be shown as annotated with @NotSecret, but not @Secret.", "title": "Documented[edit]"}, {"content": "Exactly as the name sounds, an @Inherited annotation type is inherited by subclasses of an annotated type.Code listing 1.2: Use of @Inherited\n\n\n@Inherited\n@interface ForEveryone { }\n\n@interface JustForMe { }\n\n@ForEveryone\n@JustForMe\nclass Superclass { }\n\nclass Subclass extends Superclass { }In this example, Superclass has been explicitly annotated with both @ForEveryone and @JustForMe. Subclass hasn't been explicitly marked with either one; however, it inherits @ForEveryone because the latter is annotated with @Inherited. @JustForMe isn't annotated, so it isn't inherited by Subclass.", "title": "Inherited[edit]"}, {"content": "This section is a stub.\nYou can help Wikibooks by expanding it.A @Repeatable annotation type is repeatable - i.e. can be specified multiple times on the same class. This meta-annotation was added in Java 8.", "title": "Repeatable[edit]"}, {"content": "Different annotation types have different purposes. Some are intended for use with the compiler; others are meant to be reflected dynamically at runtime. There's no reason for a compiler annotation to be available at runtime, so the @Retention meta-annotation specifies how long an annotation type should be retained. The value attribute is one of the java.lang.annotation.RetentionPolicy enum constants. The possible values, in order from shortest to longest retention, are as follows:RetentionPolicy.SOURCE\nThe annotation will not be included in the class file. This is useful for annotations which are intended for the compiler only.\nRetentionPolicy.CLASS\nThe annotation will be included in the class file, but cannot be read reflectively.\nRetentionPolicy.RUNTIME\nThe annotation can be reflected at runtime.If no @Retention policy is specified, it defaults to RetentionPolicy.CLASS.", "title": "Retention[edit]"}], "title": "Meta-Annotations"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Annotations/Compiler_and_Annotations", "content": "Navigate Javadoc & Annotations topic: (vde)\n\n Javadoc\n Introduction to Annotation\n Creating custom annotations\n Meta-annotations\n Helping the compilerAnnotations can be used by the compiler to carry out certain directives. Much that you'd love programming in Java, you probably would have been fussed about compiler warnings. Compiler warnings are not necessarily errors but are warnings that tell you the code might malfunction because of some reason.Taming the compiler[edit]You can issue directive to the compiler in the shape of three pre-defined annotation to tell it what sort of pre-processing a certain bit of code requires. The three annotations are:@Deprecated\n@Override\n@SuppressWarnings(..)@Deprecated is used to flag that a method or class should no longer be used, normally because a better alternative exists. Compilers and IDEs typically raise a warning if deprecated code is invoked from non deprecated code. [1]@Override flags that a method overrides a method in a superclass. If there is no overridden method, a compile error should occur. [2]@SuppressWarnings(..) SuppressWarnings tells the compiler not to report on some, or all, types of warnings. It can be applied to a type, a method or a variable. [3]", "subdata": [], "title": "Compiler and Annotations"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Basic_IO", "content": "Topics:\n\nPreface\nGetting started\nLanguage fundamentals\nClasses and objects\nAggregate\nExceptions\nConcurrent Programming\nJavadoc & Annotations\nDesigning user interfaces\nAdvanced topicsNavigate User Interface topic:(vde)\n\n Basic I/O\n Streams\n Event handling\n JavaBeans\n Canvas\n Graphics\n\n Drawing basic shapes\n Drawing complex shapes\n Drawing text\n Understanding gradients\n\n\n Applets\n\n\n\n\n Overview\n User Interface\n Event Listeners\n Graphics and MediaThis section covers the Java platform classes used for basic input and output. But before we begin we need to have a concrete understanding of what input and output means in programming. To grasp this concept, think of the Java platform as a system.", "subdata": [], "title": "Basic IO"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Streams", "content": "Navigate User Interface topic:(vde)\n\n Basic I/O\n Streams\n Event handling\n JavaBeans\n Canvas\n Graphics\n\n Drawing basic shapes\n Drawing complex shapes\n Drawing text\n Understanding gradients\n\n\n Applets\n\n\n\n\n Overview\n User Interface\n Event Listeners\n Graphics and MediaThe most basic input and output in Java (System.in and System.out fields that have been used in the Basic I/O) is done using streams. Streams are objects that represent sources and destinations of data. Streams that are sources of data can be read from, and streams that are destinations of data can be written to. A stream in Java is an ordered sequence of bytes of undetermined length. Streams are ordered and in sequence so that the java virtual machine can understand and work upon the stream. Streams are analogous to water streams. They exist as a communication medium, just like electromagnetic waves in communication. The order or sequence of bytes in a Java stream allow the virtual machine to classify it among other streams.Java has various inbuilt streams implemented as classes in the package java.io like the classes of System.in and System.out. Streams can be classed as both input and output streams. All Java streams are derived from Input Stream (java.io.InputStream) and Output Stream (java.io.OutputStream) classes. They are abstract base classes meant for other stream classes. The System.in is the input stream class derivative and analogically System.out is the output counterpart. Both are basic classes used to directly interact with input and output through console, similarly follows System.err. Also Java has streams to communicate across different parts of a program or even among threads. There are also classes that \"filter\" streams, changing one format to another (e.g. class DataOutputStream, which translates various primitive types to byte streams).It is a characteristic of streams that they deal only in one discrete unit of data at a time, and different streams deal with different types of data. If one had a stream that represented a destination for bytes, for example, one would send data to the destination one byte at a time. If a stream was a source of byte data, one would read the data a byte at a time. Because this is the only way to access data from a stream, in this latter case, we wouldn't know when we had read all the data from the stream until we actually got there. When reading a stream, one generally has to check each unit of data each read operation to see if the end of the stream has been reached (with byte streams, the special value is the integer -1, or FFFF hex).", "subdata": [{"content": "Input streams acquire bytes for our programmed java application/program (e.g. a file, an array, a keyboard or monitor, etc.). InputStream is an abstract class that represents a source of byte data. It has a read() method, which returns the next byte in the stream and a close() method, which should be called by a program when that program is done with the stream. The read() method is overloaded, and can take a byte array to read to. It has a skip() method that can skip a number of bytes, and an available() method that a program can use to determine the number of bytes immediately available to be read, as not all the data is necessarily ready immediately. As an abstract class, it cannot be instantiated, but describes the general behavior of an input stream. A few examples of concrete subclasses would be ByteArrayInputStream, which reads from a byte array, and FileInputStream, which reads byte data from a file.In the following example, we print \"Hello world!\" on the screen several times. The number of times the message is printed is stored in a file named source.txt. This file should only contain a integer and should be placed in the same folder of the ConfiguredApplication class.Code listing 9.1: Example of input stream.\n\n\n 1 import java.io.File;\n 2 import java.io.FileInputStream;\n 3  \n 4 public class ConfiguredApplication {\n 5  \n 6   public static void main(String[] args) throws Exception {\n 7  \n 8     // Data reading\n 9     File file = new File(\"source.txt\");\n10     FileInputStream stream = new FileInputStream(file);\n11  \n12     StringBuffer buffer = new StringBuffer();\n13  \n14     int character = 0;\n15     while ((character = stream.read()) != -1) {\n16       buffer.append((char) character);\n17     }\n18  \n19     stream.close();\n20  \n21     // Data use\n22     Integer readInteger = Integer.parseInt(buffer.toString());\n23     for (int i = 0; i < readInteger ; i++) {\n24       System.out.println(\"Hello world!\");\n25     }\n26   }\n27 }The close() method is not always mandatory but can avoid some inter-process concurrency conflicts. However if it occurs before a read() or write() (in the same process) they return the warning Stream closed.The class start to identify the filename with a File object. The File object is used by an input stream as the source of the stream. We create a buffer and a character to prepare the data loading. The buffer will contain all the file content and the character will temporary contain each character present in the file, one after one. This is done while{}in the loop. Each iteration of the loop will copy a character from the stream to the buffer. The loop ends when no more character is present in the stream. Then we close the stream. The last part of the code use the data we have loaded in from the file. It is transformed into string and then into an integer (so the data must be an integer). If it works, the integer is used to determine the number of time we print \"Hello world!\" on the screen. No try/catch block has been defined for readability but the thrown exceptions should be caught.Let's try with the following source file:Code listing 9.2: source.txt\n4We should obtain this:Output for ConfiguredApplication\n\n$ java ConfiguredApplication\nHello world!\nHello world!\nHello world!\nHello world!If it shows a FileNotFoundException or an IOException, the source may not be placed in the right folder or its name is badly spelled.\nIf it shows a NumberFormatException, the content of the file may not be an integer.There is also Reader which is an abstract class that represents a source of character data. It is analogous to InputStream, except that it deals with characters instead of bytes (remember that Java uses Unicode, so that a character is 2 bytes, not one). Its methods are generally similar to those of InputStream. Concrete subclasses include classes like FileReader, which reads characters from files, and StringReader, which reads characters from strings. You can also convert an InputStream object to a Reader object with the InputStreamReader class, which can be \"wrapped around\" an InputStream object (by passing it as an argument in its constructor). It uses a character encoding scheme (which can be changed by the programmer) to translate a byte into a 16-bit Unicode character.", "title": "Input streams[edit]"}, {"content": "Output Streams direct streams of bytes outwards to the environment from our program or application. OutputStream is an abstract class which is the destination counterpart of InputStream. OutputStream has a write() method which can be used to write a byte to the stream. The method is overloaded, and can take an array as well. A close() method closes the stream when the application is finished with it, and it has a flush() method. The stream may wait until it has a certain amount before it writes it all at once for efficiency. If the stream object is buffering any data before writing it, the flush() method will force it to write all of this data. Like InputStream, this class cannot be instantiated, but has concrete subclasses that parallel those of InputStream, eg ByteArrayOutputStream, FileOutputStream, etc.In the following example, we store the current time in an already existing file called log.txt located in the same folder than the class.Code listing 9.2: Example of output stream.\n\n\n 1 import java.io.File;\n 2 import java.io.FileOutputStream;\n 3 import java.util.Date;\n 4  \n 5 public class LogTime {\n 6     public static void main(String[] args) throws Exception {\n 7         // Generate data\n 8         String timeInString = new Date().toString();\n 9 \n10         // Store data\n11         File file = new File(\"log.txt\");\n12         FileOutputStream stream = new FileOutputStream(file);\n13 \n14         byte[] timeInBytes = timeInString.getBytes();\n15 \n16         stream.write(timeInBytes);\n17         stream.flush();\n18         stream.close();\n19     }\n20 }This case is more simple as we can put all the data in the stream at the same time. The first part of the code generate a string containing the current time. Then we create a File object identifying the output file and an output stream for this file. We write the data in the stream, flush it and close it. That's all. No try/catch block has been defined for readability but the thrown exceptions should be caught.In order to read a text file several times from the beginning, a FileChannel variable should be introduced, only to reposition the reader.Now let's execute it:LogTime execution\n\n$ java LogTimeWe should obtain this content:Code listing 9.4: log.txt\nThu Oct 26 14:33:33 CEUTC 2017If it shows a FileNotFoundException or an IOException, the file should not have been created or it is not placed in the right folder.There is also Writer which is a character counterpart of OutputStream, and a destination counterpart to Reader, this is also an abstract superclass. Particular implementations parallel those of Reader, eg FileWriter, StringWriter, and OutputStreamWriter, for converting a regular OutputStream into a reader so that it can take character data.", "title": "Output streams[edit]"}, {"content": "System is a class in the package java.lang with a number of static members that are available to Java programs. Two members that are useful for console output are System.out and System.err. Both System.out and System.err are PrintStream objects. PrintStream is a subclass of FilterOutputStream, itself a subclass of OutputStream (discussed above), and its main purpose is to translate a wide variety of data types into streams of bytes that represent that data in characters according to some encoding scheme.System.out and System.err both display text to a console where the user can read it, however what this means exactly depends on the platform used and the environment in which the program is running. In BlueJay and Eclipse IDE, for example, there is a special \"terminal\" window that will display this output. If the program is launched in Windows, the output will be sent to the DOS prompt (usually this means that you have to launch the program from the command line to see the output).System.out and System.err differ in what they're supposed to be used for. System.out should be used for normal program output, System.err should be used to inform the user that some kind of error has occurred in the program. In some situations, this may be important. In DOS, for instance, a user can redirect standard output to some other destination (a file, for example), but error output will not be redirected, but rather displayed on the screen. If this weren't the case, the user might never be able to tell that an error had occurred.", "title": "System.out and System.err[edit]"}, {"content": "Versions of Java prior to J2SE 1.4 only supported stream-based blocking I/O. This required a thread per stream being handled, as no other processing could take place while the active thread blocked waiting for input or output. This was a major scalability and performance issue for anyone needing to implement any Java network service. Since the introduction of NIO (New I/O) in J2SE 1.4, this scalability problem has been rectified by the introduction of a non-blocking I/O framework (though there are a number of open issues in the NIO API as implemented by Oracle).The non-blocking IO framework, though considerably more complex than the original blocking IO framework, allows any number of \"channels\" to be handled by a single thread. The framework is based on the Reactor Pattern.", "title": "New I/O[edit]"}], "title": "Streams"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Event_Handling", "content": "Navigate User Interface topic:(vde)\n\n Basic I/O\n Streams\n Event handling\n JavaBeans\n Canvas\n Graphics\n\n Drawing basic shapes\n Drawing complex shapes\n Drawing text\n Understanding gradients\n\n\n Applets\n\n\n\n\n Overview\n User Interface\n Event Listeners\n Graphics and MediaThe Java platform Event Model is the basis for event-driven programming on the Java platform.", "subdata": [{"content": "No matter what the programming language or paradigm you are using, chances are that you will eventually run into a situation where your program will have to wait for an external event to happen. Perhaps your program must wait for some user input, or perhaps it must wait for data to be delivered over the network. Or perhaps something else. In any case, the program must wait for something to happen that is beyond the program's control: the program cannot make that event happen.In this situation there are two general options for making a program wait for an external event to happen. The first of these is called polling and means you write a little loop of the for \"while the event has not happened, check again\". Polling is very simple to build and very straightforward. But it is also very wasteful: it means a program takes up processor time in order to do absolutely nothing but wait. This is usually considered too much of a drawback for programs that have to do a lot of waiting. Programs that have a lot of waiting moments (for example, programs that have a graphical user interface and often have to wait for long periods of time until the user does something) usually fare much better when they use the other mechanism: event-driven programming.In event-driven programming a program that must wait, simply goes to sleep. It no longer takes up processor time, might even be unloaded from memory and generally leaves the computer available to do useful things. But the program doesn't completely go away; instead, it makes a deal with the computer or the operating system. A deal sort of like this:Okay Mr. Operating System, since I have to wait for an event to happen, I'll go away and let you do useful work in the meantime. But in return, you have to let me know when my event has happened and let me come back to deal with it.Event-driven programming usually has a pretty large impact on the design of a program. Usually, a program has to be broken up into separate pieces to do event-driven programming (one piece for general processing and one or more others to deal with events that occur). Event-driven programming in Java is more complicated than non-event driven but it makes far more efficient use of the hardware and sometimes (like when developing a graphical user interface) dividing your code up into event-driven blocks actually fits very naturally with your program's structure.In this module we examine the basis of the Java Platform's facilities for event-driven programming and we look at some typical examples of how that basis has been used throughout the platform.", "title": "Event-driven programming[edit]"}, {"content": "Introduction[edit]One of the most interesting things about support for event-driven programming on the Java platform is that there is none, as such. Or, depending on your point of view, there are many different individual pieces of the platform that offer their own support for event-driven programming.The reason that the Java platform doesn't offer one general implementation of event-driven programming is linked to the origins of the support that the platform does offer. Back in 1996 the Java programming language was just getting started in the world and was still trying to gain a foothold and conquer a place for itself in software development. Part of this early development concentrated on software development tooling like IDEs. One of the trends in software development around that time was for reusable software components geared towards user interfaces: components that would encapsulate some sort of interesting, reusable functionality into a single package that could be handled as a single entity rather than as a loose collection of individual classes. Sun Microsystems tried to get on the component bandwagon by introducing what they called a JavaBean, a software component not only geared towards the UI but that could also be configured easily from an IDE. In order to make this happen Sun came up with a large specification of JavaBeans (the JavaBeans Spec) dealing mostly with naming conventions (to make the components easy to handle from an IDE). But Sun also realized at the same time that a UI-centric component would need support for an event-driven way of connecting events in the component to business logic that would have to be written by the individual developer. So the JavaBeans Spec also included a small specification for an event Model for the Java platform.When they started working on this Event Model, the Sun engineers were faced with a choice: try to come up with a huge specification to encompass all possible uses of an event model, or just specify an abstract, generic framework that could be expanded for individual use in specific situations. They chose the latter option and so, love it or hate it, the Java Platform has no generic support for event-driven programming other than this general Event Model framework.The Event Model framework[edit]The basic Event Model frameworkThe Event Model framework is really very simple in and of itself, consisting of three classes (one abstract) and an interface. Most of all it consists of naming conventions that the programmer must obey. The framework is depicted in the image on the right.Speaking in terms of classes and interfaces, the most important parts of the framework are the java.util.EventObject abstract class and the java.util.EventListener interface. These two types are the centerpieces of the rules and conventions of the Java Platform Event Model, which are:A class that has to be notified when an event occurs, is called an event listener. An event listener has one distinct method for each type of event notification that it is interested in.\nEvent notification method declarations are grouped together into categories. Each category is represented by an event listener interface, which must extend java.util.EventListener. By convention an event listener interface is named <Event category name>Listener. Any class that will be notified of events must implement at least one listener interface.\nAny and all state related to an event occurrence will be captured in a state object. The class of this object must be a subclass of java.util.EventObject and must record at least which object was the source of the event. Such a class is called an event class and by convention is named <Event category name>Event.\nUsually (but not necessarily!) an event listener interface will relate to a single event class. An event listener may have multiple event notification methods that take the same event class as an argument.\nAn event notification method usually (but not necessarily!) has the conventional signature public void <specific event>(<Event category name>Event evt).\nA class that is the source of events must have a method that allows for the registration of listeners, one for each possible listener interface type. These methods must by convention have the signature public void add<Event category name>Listener(<Event category name>Listener listener).\nA class that is the source of events may have a method that allows for the deregistration of listeners, one for each possible listener interface type. These methods must by convention have the signature public void remove<Event category name>Listener(<Event category name>Listener listener).A general example of how the framework is usedThat seems like a lot, but it's pretty simple once you get used to it. Take a look at the image on the left, which contains a general example of how you might use the framework. In this example we have a class called EventSourceClass that publishes interesting events. Following the rules of the Event Model, the events are represented by the InterestingEvent class which has a reference back to the EventSourceClass object (source, inherited from java.util.EventObject).Whenever an interesting event occurs, the EventSourceClass must notify all of the listeners for that event that it knows about by calling the notification method that exist for that purpose. All of the notification methods (in this example there is only one, interestingEventOccurred) have been grouped together by topic in a listener interface: InterestingEventListener, which implements java.util.EventListener and is named according to the Event Model conventions. This interface must be implemented by all event listener classes (in this case only InterestingEventListenerImpl). Because EventSourceClass must be able to notify any interested listeners, it must be possible to register them. For this purpose the EventSourceClass has an addInterestingEventListener method. And since it is required, there is a removeInterestingEventListener method as well.As you can clearly see from the example, using the Event Model is mostly about following naming conventions. This might seem a little cumbersome at first, but the point of having naming conventions is to allow automated tooling to access and use the event model. And there are indeed many tools, IDEs and frameworks that are based on these naming conventions.Degrees of freedom in the Model[edit]There's one more thing to notice about the Event Model and that is what is not in the Model. The Event Model is designed to allow implementations a large degree of freedom in the implementation choices made, which means that the Event Model can serve as the basis for a very wide range of specific, purpose-built event handling systems.Aside from naming conventions and some base classes and interfaces, the Event Model specifies the following:It must be possible to register and deregister listeners.\nAn event source must publish events by calling the correct notification method on all registered listeners.\nA call to an event notification method is a normal, synchronous Java call and the method must be executed by the same thread that called it.But the Event Model doesn't specify how any of this must be done. There are no rules regarding which classes exactly must be event sources, nor about how they must keep track of registered event listeners. So one class might publish its own events, or be responsible for publishing the events that relate to an entire collection of objects (like an entire component). And an event source might allow listeners to be deregistered at any time (even in the middle of handling an event) or might limit this to certain times (which is relevant to multithreading).Also, the Event Model doesn't specify how it must be embedded within any program. So, while the model specifies that a call to an event handling method is a synchronous call, the Model does not prescribe that the event handling method cannot hand off tasks to another thread or that the entire event model implementation must run in the main thread of the application. In fact, the Java Platform's standard user interface framework (Swing) includes an event handling implementation that runs as a complete subsystem of a desktop application, in its own thread.Event notification methods, unicast event handling and event adaptors[edit]In the previous section we mentioned that an event notification method usually takes a single argument. This is the preferred convention, but the specification does allow for exceptions to this rule if the application really needs that exception. A typical case for an exception is when the event notification must be sent across the network to a remote system though non-Java means, like the CORBA standard. In this case it is required to have multiple arguments and the Event Model allows for that. However, as a general rule the correct format for a notification method isCode section 1.1: Simple notification method\n\n\npublic void specificEventDescription(Event_type evt)Another thing we mentioned earlier is that, as a general rule, the Event Model allows many event listeners to register with a single event source for the same event. In this case the event source must broadcast any relevant events to all the registered listeners. However, once again the Event Model specification allows for an exception to the rule. If it is necessary from a design point of view you may limit an event source to registering a single listener; this is called unicast event listener registration. When unicast registration is used, the registration method must be declared to throw the java.util.TooManyListenersException exception if too many listeners are registered:Code section 1.2: Listener registration\n\n\npublic void add<Event_type>Listener(<Event_type>Listener listener) throws java.util.TooManyListenersExceptionAn event adaptor in between the event source and the event listener.Finally, the specification allows for one more extension: the event adaptor. An event adaptor is an implementation of an event listener interface that can be inserted between an event source and an actual event listener class. This is done by registering the adaptor with the event source object using the regular registration method. Adaptors are used to add additional functionality to the event handling mechanism, such as routing of event objects, event filtering or enriching of the event object before processing by an actual event handler class.", "title": "The Java Platform Event Model[edit]"}, {"content": "In the previous section we've explored the depths (such as there are) of the Java platform Event Model framework. If you're like most people, you've found the theoretical text more confusing than the actual use of the model. Certainly more confusing than should be necessary to explain what is, really, quite a simple framework.In order to clear everything up a bit, let's examine a simple example based on the Event Model framework. Let's assume that we want to write a program that reads a stream of numbers input by the user at the command line and processes this stream somehow. Say, by keeping track of the running sum of numbers and producing that sum once the stream has been completely read.Of course we could implement this program quite simply with a loop in a main() method. But instead let's be a little more creative. Let's say that we want to divide our program neatly into classes, each with a responsibility of its own (like we should in a proper, object-oriented design). And let's imagine that we want it to be possible not only to calculate the sum of all the numbers read, but to perform any number of calculations on the same number stream. In fact, it should be possible to add new calculations with relative ease and without having to affect any previously existing code.If we analyze these requirements, we come to the conclusion that we have a number of different responsibilities in the program:Reading the number stream from the command line\nProcessing the number stream (possibly multiple of these)\nStarting the entire programUsing the Event Model framework allows us to separate the two main responsibilities cleanly and affords us the flexibility we are looking for. If we implement the logic for reading the number stream in a single class and treat the reading of a single number as an event, the Event Model allows us to broadcast that event (and the number) to as many stream processors as we like. The class for reading the number stream will act as the event source of the program and each stream processor will be a listener. Since each listener is a class of its own and can be registered with the stream reader (or not) this means our model allows us to have multiple, independent stream processing that we can add on to without affecting the code to read the stream or any pre-existing stream processor.The Event Model says that any state associated with an event should be included in a class that represents the event. That's perfect for us; we can implement a simple event class that will record the number read from the command line. Each listener can then process this number as it sees fit.For our interesting event set let's keep things simple: let's limit ourselves to having read a new number and having reached the end of the stream. With this choice we come to the following design for our example application:In the following sections we look at the implementation of this example.Example basics[edit]Let's start with the basics. According to the Event Model rules, we must define an event class to encapsulate our interesting event. We should call this class something-somethingEvent. Let's go for NumberReadEvent, since that's what will interest us. According to the Model rules, this class should encapsulate any state that belongs with an event occurrence. In our case, that's the number read from the stream. And our event class must inherit from java.util.EventObject. So all in all, the following class is all we need:Code listing 1.1: NumberReadEvent.\n\n\npackage org.wikibooks.en.javaprogramming.example;\n\nimport java.util.EventObject;\n\npublic class NumberReadEvent extends EventObject {\n\n    private double number;\n   \n    public NumberReadEvent(Object source, Double number) {\n        super(source);\n        this.number = number;\n    }\n\n    public double getNumber() {\n        return number;\n    }\n}Next, we must define a listener interface. This interface must define methods for interesting events and must extend java.util.EventListener. We said earlier our interesting events were \"number read\" and \"end of stream reached\", so here we go:Code listing 1.2: NumberReadListener.\n\n\npackage org.wikibooks.en.javaprogramming.example;\n\nimport java.util.EventListener;\n\npublic interface NumberReadListener extends EventListener {\n    public void numberRead(NumberReadEvent numberReadEvent);\n   \n    public void numberStreamTerminated(NumberReadEvent numberReadEvent);\n}Actually the numberStreamTerminated method is a little weird, since it isn't actually a \"number read\" event. In a real program you'd probably want to do this differently. But let's keep things simple in this example.The event listener implementation[edit]So, with our listener interface defined, we need one or more implementations (actual listener classes). At the very least we need one that will keep a running sum of the numbers read. We can add as many as we like, of course. But let's stick with just one for now. Obviously, this class must implement our NumberReadListener interface. Keeping a running summation is a matter of adding numbers to a field as the events arrive. And we wanted to report on the sum when the end of the stream is reached; since we know when that happens (i.e. the numberStreamTerminated method is called), a simple println statement will do:Code listing 1.3: NumberReadListenerImpl.\n\n\npackage org.wikibooks.en.javaprogramming.example;\n\npublic class NumberReadListenerImpl implements NumberReadListener {\n   \n    double totalSoFar = 0D;\n\n    @Override\n    public void numberRead(NumberReadEvent numberReadEvent) {\n        totalSoFar += numberReadEvent.getNumber();\n    }\n\n    @Override\n    public void numberStreamTerminated(NumberReadEvent numberReadEvent) {\n        System.out.println(\"Sum of the number stream: \" + totalSoFar);\n    }\n}So, is this code any good? No. It's yucky and terrible and most of all not thread safe. But it will do for our example.The event source[edit]This is where things get interesting: the event source class. This is the interesting place because this is where we must put code to read the number stream, code to send events to all the listeners and code to manage listeners (add and remove them and keep track of them).Let's start by thinking about keeping track of listeners. Normally this is a tricky business, since you have to take all sorts of multithreading concerns into account. But we're being simple in this example, so let's just stick with a simple java.util.Set of listeners. Which we can initialize in the constructor:Code section 1.1: The constructor\n\n\nprivate Set<NumberReadListener> listeners;\n   \npublic NumberReader() {\n    listeners = new HashSet<NumberReadListener>();\n}That choice makes it really easy to implement adding and removing of listeners:Code section 1.2: The register/deregister\n\n\npublic void addNumberReadListener(NumberReadListener listener) {\n    this.listeners.add(listener);\n}\n\npublic void removeNumberReadListener(NumberReadListener listener) {\n    this.listeners.remove(listener);\n}We won't actually use the remove method in this example  but recall that the Model says it must be present.Another advantage of this simple choice is that notification of all the listeners is easy as well. We can just assume any listeners will be in the set and iterate over them. And since the notification methods are synchronous (rule of the model) we can just call them directly:Code section 1.3: The notifiers\n\n\nprivate void notifyListenersOfEndOfStream() {\n    for (NumberReadListener numberReadListener : listeners) {\n        numberReadListener.numberStreamTerminated(new NumberReadEvent(this, 0D));\n    }\n}\n\nprivate void notifyListeners(Double d) {\n    for (NumberReadListener numberReadListener: listeners) {\n        numberReadListener.numberRead(new NumberReadEvent(this, d));\n    }\n}Note that we've made some assumptions here. For starters, we've assumed that we'll get the Double value d from somewhere. Also, we've assumed that no listener will ever care about the number value in the end-of-stream notification and have passed in the fixed value 0 for that event.Finally we must deal with reading the number stream. We'll use the Console class for that and just keep on reading numbers until there are no more:Code section 1.4: The main method\n\n\npublic void start() {\n    Console console = System.console();\n    if (console != null) {\n        Double d = null;\n        do {\n            String readLine = console.readLine(\"Enter a number: \", (Object[])null);\n            d = getDoubleValue(readLine);\n            if (d != null) {\n                notifyListeners(d);\n            }\n        } while (d != null);\n        notifyListenersOfEndOfStream();\n    }\n}Note how we've hooked the number-reading loop into the event handling mechanism by calling the notify methods? The entire class looks like this:Code listing 1.4: NumberReader.\n\n\npackage org.wikibooks.en.javaprogramming.example;\n\nimport java.io.Console;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class NumberReader {\n    private Set<NumberReadListener> listeners;\n   \n    public NumberReader() {\n        listeners = new HashSet<NumberReadListener>();\n    }\n   \n    public void addNumberReadListener(NumberReadListener listener) {\n        this.listeners.add(listener);\n    }\n   \n    public void removeNumberReadListener(NumberReadListener listener) {\n        this.listeners.remove(listener);\n    }\n   \n    public void start() {\n        Console console = System.console();\n        if (console != null) {\n            Double d = null;\n            do {\n                String readLine = console.readLine(\"Enter a number: \", (Object[])null);\n                d = getDoubleValue(readLine);\n                if (d != null) {\n                    notifyListeners(d);\n                }\n            } while (d != null);\n            notifyListenersOfEndOfStream();\n        }\n    }\n\n    private void notifyListenersOfEndOfStream() {\n        for (NumberReadListener numberReadListener: listeners) {\n            numberReadListener.numberStreamTerminated(new NumberReadEvent(this, 0D));\n        }\n    }\n\n    private void notifyListeners(Double d) {\n        for (NumberReadListener numberReadListener: listeners) {\n            numberReadListener.numberRead(new NumberReadEvent(this, d));\n        }\n    }\n\n    private Double getDoubleValue(String readLine) {\n        Double result;\n        try {\n            result = Double.valueOf(readLine);\n        } catch (Exception e) {\n            result = null;\n        }\n        return result;\n    }\n}Running the example[edit]Finally, we need one more class: the kickoff point for the application. This class will contain a main() method, plus code to create a NumberReader, a listener and to combine the two:Code listing 1.5: Main.\n\n\npackage org.wikibooks.en.javaprogramming.example;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        NumberReader reader = new NumberReader();\n        NumberReadListener listener = new NumberReadListenerImpl();\n        reader.addNumberReadListener(listener);\n        reader.start();\n    }\n}If you compile and run the program, the result looks somewhat like this:An example run\n\n>java org.wikibooks.en.javaprogramming.example.Main\nEnter a number: 0.1\nEnter a number: 0.2\nEnter a number: 0.3\nEnter a number: 0.4\nEnter a number:Output\n\nSum of the number stream: 1.0Extending the example with an adaptor[edit]Next, let's take a look at applying an adaptor to our design. Adaptors are used to add functionality to the event handling process that:is general to the process and not specific to any one listener; or\nis not supposed to affect the implementation of specific listeners.According to the Event Model specification a typical use case for an adaptor is to add routing logic for events. But you can also add filtering or logging. In our case, let's do that: add logging of the numbers as \"proof\" for the calculations done in the listeners.An adaptor, as explained earlier, is a class that sits between the event source and the listeners. From the point of view of the event source, it masquerades as a listener (so it must implement the listener interface). From the point of view of the listeners it pretends to be the event source (so it should have add and remove methods). In other words, to write an adaptor you have to repeat some code from the event source (to manage listeners) and you have to re-implement the event notification methods to do some extra stuff and then pass the event on to the actual listeners.In our case we need an adaptor that writes the numbers to a log file. Keeping it simple once again, let's settle for an adaptor that:Uses a fixed log file name and overwrites that log file with every program run.\nOpens a FileWriter in the constructor and just keeps it open.\nImplements the numberRead method by writing the number to the FileWriter.\nImplements the numberStreamTerminated method by closing the FileWriter.Also, we can make life easy on ourselves by just copying all the code we need to manage listeners over from the NumberReader class. Again, in a real program you'd want to do this differently. Note that each notification method implementation also passes the event on to all the real listeners:Code listing 1.6: NumberReaderLoggingAdaptor.\n\n\npackage org.wikibooks.en.javaprogramming.example;\n\nimport java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class NumberReaderLoggingAdaptor implements NumberReadListener {\n    private Set<NumberReadListener> listeners;\n    private BufferedWriter output;\n   \n    public NumberReaderLoggingAdaptor() {\n        listeners = new HashSet<NumberReadListener>();\n        try {\n            output = new BufferedWriter(new FileWriter(\"numberLog.log\"));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n    }\n   \n    public void addNumberReadListener(NumberReadListener listener) {\n        this.listeners.add(listener);\n    }\n   \n    public void removeNumberReadListener(NumberReadListener listener) {\n        this.listeners.remove(listener);\n    }\n   \n   \n    @Override\n    public void numberRead(NumberReadEvent numberReadEvent) {\n        try {\n            output.write(numberReadEvent.getNumber() + \"\\n\");\n        } catch (Exception e) {\n           \n        }\n        for (NumberReadListener numberReadListener: listeners) {\n            numberReadListener.numberRead(numberReadEvent);\n        }\n    }\n\n    @Override\n    public void numberStreamTerminated(NumberReadEvent numberReadEvent) {\n        try {\n            output.flush();\n            output.close();\n        } catch (Exception e) {\n           \n        }\n        for (NumberReadListener numberReadListener: listeners) {\n            numberReadListener.numberStreamTerminated(numberReadEvent);\n        }\n    }\n\n}Of course, to make the adaptor work we have to make some changes to the bootstrap code:Code listing 1.7: Main.\n\n\npackage org.wikibooks.en.javaprogramming.example;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        NumberReader reader = new NumberReader();\n        NumberReadListener listener = new NumberReadListenerImpl();\n        NumberReaderLoggingAdaptor adaptor = new NumberReaderLoggingAdaptor();\n        adaptor.addNumberReadListener(listener);\n        reader.addNumberReadListener(adaptor);\n        reader.start();\n    }\n}But note how nicely and easily we can re-link the objects in our system. The fact that adaptors and listeners both implement the listener interface and the adaptor and event source both look like event sources means that we can hook the adaptor into the system without having to change a single statement in the classes that we developed earlier.And of course, if we run the same example as given above, the numbers are now recorded in a log file.", "title": "A simple example[edit]"}], "title": "Event Handling"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/JavaBeans", "content": "Navigate User Interface topic:(vde)\n\n Basic I/O\n Streams\n Event handling\n JavaBeans\n Canvas\n Graphics\n\n Drawing basic shapes\n Drawing complex shapes\n Drawing text\n Understanding gradients\n\n\n Applets\n\n\n\n\n Overview\n User Interface\n Event Listeners\n Graphics and MediaReusability comes at the core of any modern computer language's framework. It is often desirable to use components you previously built in recurring environments. In Rapid Application Development, these prove more helpful as you can drag them off a list of components and use it elsewhere in your project. Such level of reusability is added into the Java Programming language with the help of the JavaBeans architecture.JavaBeans are the mainstream Java component model, introduced in 1996 by Sun Microsystems. JavaBeans are defined as follows:\"A JavaBean is a reusable software component that can be manipulated visually in a builder tool.\"Together with the component model, Sun released a simple visual composition tool, the BeanBox. It is mostly intended for experimenting with Beans rather than offering a professional IDE. For real world applications, one should better deploy on one of the Java IDEs like Visual Age or JBuilder that support the visual composition of JavaBeans.As we will see, JavaBeans do not essentially differ from standard Java classes, which makes the component model quite easy to use. What sets a JavaBean apart from normal Java classes is that a JavaBean follows the Oracle JavaBeans Standard (the term JavaBean or simply bean also refers to the instances of a JavaBean class). There is a set of features and conventions adopted for facilitating reuse:Presence of a no argument constructor;\nSupport for persistence;\nProperties manipulated by getter and setter methods;\nSupport for introspection;\nEvents as the mechanism of communication between beans;\nSupport for customization via property editors.The JavaBeans standard provides a framework for creating objects to be used by GUI tools, including Java development environments. But in more common usage, a bean is a serializable class that follows the JavaBeans naming conventions for its properties. These naming standards make it easy to use Java introspection.", "subdata": [{"content": "To follow these standards, the bean needs one or more properties abstractions which represent different state values of an object. A property has a name (a valid Java identifier) and a type (either a reference type, a primitive type or an array type). By default, the properties of a JavaBean class are inferred by the presence of either a getter method, a setter method, or both:A getter method which is used to obtain the value of the property from a bean. The name is usually of the form getPropertyName. For example, the getter method for the String property whiskey is public String getWhiskey(). For boolean properties (those whose type is boolean, the convention is to use the naming pattern isPropertyName.isDiscounted() would be the getter method for a boolean property named discounted. Thus, the method signature of most getters is public PropertyType getPropertyName() or public boolean isPropertyName().A setter method which is used to assign a value to a bean's property. A setter method is a method of the form public void setPropertyName(PropertyType value). For the previous example, the setter could be invoked as setWhiskey(\"bourbon\");.As per the JavaBeans standard, getters and setters defined as described above automatically determine the properties of the class. However, by creating java.beans.PropertyDescriptor classes, you can specify alternate implementations by explicitly declaring the property names and the getter and/or setter methods for each property.Properties are often implemented with private instance variables, but this is not required.", "title": "Implementation[edit]"}, {"content": "This is an example of a simple JavaBean type with the properties int age and String color.Code listing 9.12: Puppy.java\n\n\n 1 class Puppy implements java.io.Serializable {\n 2 \n 3   private static final long serialVersionUID = 348652158488L;\n 4 \n 5   private String color;\n 6 \n 7   private int age;\n 8 \n 9   public String getColor() {\n10     return color;\n11   }\n12 \n13   public void setColor(String color) {\n14     this.color = color;\n15   }\n16 \n17   public int getAge() {\n18     return age;\n19   }\n20 \n21   public void setAge(int age) {\n22     this.age = age;\n23   }\n24 }", "title": "A Simple JavaBean[edit]"}, {"content": "The requirements for an object to be a bean is to define a public parameterless constructor, so that beans can be instantiated by builder tools in an uncomplicated way (In the Point bean, the parameterless constructor is given implicitly). Secondly, one of the interfaces java.io.Serializable or java.io.Externalizable need to be implemented. The interfaces do not prescribe the implementation of any methods, but are an approval, that the bean may be saved in persistent storage as in a file or database. In doing so, the bean can be restored after an application was shut down or transferred across networks. The ability to store state of a component in persistent storage is called persistence. Java offers a standard serialization mechanism, which makes it very easy to serialize objects. Alternatively, a component can be stored in a customized manner (e.g. in xml format) by implementing the Externalizable interface.", "title": "Persistence[edit]"}, {"content": "The properties of a bean are all private fields that are accessible and modifiable by public methods. These getter and setter methods should be marked as such by following a simple naming convention: for some property named, say, xxx there should be a getXxx() which returns the property value and a setXxx() which sets the property.", "title": "Properties[edit]"}, {"content": "In Java and J2EE programming, you can call a method on an object only if it is casted to a class or an interface that declares it. The structured definition of bean properties is very useful for comparing a single common property across several objects that are not and should not be related by inheritance.For example, a program may contain both a bean representing a company's employees, and another containing a list of buildings that a company occupies. A programmer writing a function called listAssetNames() wants to write a simple way of getting the field \"name\" from several beans that can get the field from both Employee and Building beans, and that can be easily adapted to get the same field from other types of beans that may not be written yet.While this could be done by rewriting both Employee and Building so that they each inherit from one class named NamedObject, or by creating a NamedObject interface, both methods have their own problems. Using inheritance is limiting, as each child class can only inherit from one parent class, which limits the number of different classes that can share properties, as well as the number of common properties that can be shared. Furthermore, using inheritance to express relationships other than a simple \"is-a\" relationship can be confusing, as can looking through dozens of class definitions to find where a single \"dumb\" getter function is implemented. Creating an interface fixes the problems caused by the multiple inheritance rule, as a class can use any number of interfaces, but it still requires every shared property to be explicitly spelled out.The simplest, most elegant way to deal with this type of relationship is to read the bean properties using introspection. The jakarta BeanUtils package is a common way of handling objects that need to be related in this way, as it takes advantage of the regularity of JavaBean naming conventions.Code listing 9.13: Get property from a JavaBean\n\n\n 1 public static Object getProperty(Object o, String propertyName) {\n 2    if (o == null ||\n 3        propertyName == null ||\n 4        propertyName.length() < 1) {\n 5       return null;\n 6    }\n 7    // Based on the property name build the getter method name\n 8    String methodName = \"get\" +\n 9                       propertyName.substring(0,1).toUpperCase() +\n10                       propertyName.substring(1);\n11    Object property = null;\n12    try {\n13       java.lang.Class c = o.getClass();\n14       java.lang.reflect.Method m = c.getMethod(methodName, null);\n15       property = m.invoke(o, null);\n16    } catch (NoSuchMethodException e) {\n17      // Handle exception\n18    }  catch (SecurityException e) {\n19      // No permission; Handle exception\n20    }\n21 return property;\n22 }orCode listing 9.14: Use Apache Commons BeanUtils\n\n\n 1 import org.apache.commons.beanutils.PropertyUtils;\n 2 \n 3 try {\n 4   Object myValue = PropertyUtils.getSimpleProperty(o, propertyName);\n 5 } catch (IllegalAccessException e) {\n 6   // Handle exception\n 7 } catch (InvocationTargetException e) {\n 8   // Handle exception\n 9 } catch (NoSuchMethodException e) {\n10   // Handle exception\n11 }", "title": "Introspection[edit]"}, {"content": "JavaBeans interact with each other by means of events. Events are notifications, a component can give to other components, that something interesting has happened. An example for an event might be a mouse click on a button or the closing of a window. Beans can be source and target of events. To be informed about an event, a bean has to register at another Bean as a listener.The Java event model realizes the observer design pattern with the effect that the inter-component coupling is reduced. Method calls require tight coupling, as caller and receiver need to know each other at compile time, while with events all communication happens solely via interfaces.A special kind of event are PropertyChangeEvents. They are used to restrict some properties to take only specific values, for example for a month integer values between 1 and 12. Every time, such a bound property is modified, notifications to all registered PropertyChangeListeners will be send.", "title": "Events[edit]"}, {"content": "Customization is done via Property Editors. A property editor is a tool for customizing at design time a particular property type. Property editors are activated from so-called property sheets, which display all properties of a bean. If a property is selected for customization, the property sheet finds out the type of the property, displays the appropriate property editor with the property's current value.", "title": "Customization[edit]"}, {"content": "A big strength of the JavaBean component model is that it is designed for simplicity. Developing JavaBeans is very simple, because a lot of behavior (like the platform independence or packaging mechanism) is supported in the Java Programming Language by default. However, one can optionally equip beans with additional objects like BeanInfos or custom PropertyEditors to use the component model in a more flexible way. A second facility is that Sun designed the whole Swing GUI library according to the JavaBeans component model. Thereby Swing components can easily be composed in visual builder tools.However, JavaBeans do not realize all features of a component model. A drawback is that JavaBeans are restricted to the Java programming language, while an important goal of components is the independence of an implementation language.", "title": "Additional Remarks[edit]"}], "title": "JavaBeans"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Canvas", "content": "Navigate User Interface topic:(vde)\n\n Basic I/O\n Streams\n Event handling\n JavaBeans\n Canvas\n Graphics\n\n Drawing basic shapes\n Drawing complex shapes\n Drawing text\n Understanding gradients\n\n\n Applets\n\n\n\n\n Overview\n User Interface\n Event Listeners\n Graphics and MediaAn essential part of programming in Java requires you to build exciting new user interfaces for yourselves. Components that come built into the Java framework are regular UI elements, however for a more rich experience, you need controls of your own. Take, for instance, a charting application. No charting tool comes built into a Java API. You need to manually draw the chart yourself.Coding drawing, to begin with, is pretty daunting but once you know the basics of Graphics programming in Java, you can create elegant graphics and art in no time. But the question that arises in one's mind is what to draw on. The answer to this question is simpler than it seems. You can start drawing on any component in the Java framework. Whether it be a panel, window or even a button.Let me break it down for you. A component in the Java language is a class that has been derived from the Component class. Each component has a method with a signature paint(Graphics) which can be overridden to manually draw something atop it.", "subdata": [{"content": "Below is an example on how you need to override the above method. For this very example, the component class that we would be using would be the Canvas class. For more information about the Canvas class, see the section on Understanding the Canvas classCode listing 9.1: Initializing a Canvas class\n\n\nimport java.awt.*;\n\npublic class MyCanvas extends Canvas {\n\n    public MyCanvas() {\n        //...\n    }\n\n    public void paint(Graphics graphics) {\n        /* We override the method here. The graphics\n         * code comes here within the method body. */\n    }\n}", "title": "Overriding the paint(Graphics) method[edit]"}, {"content": "Code listing 9.1 shows the simplicity and power of the syntax for enabling the graphics functions within Java. Lets begin by understanding what a Canvas class does. A Canvas class is a derivative or a sub-class of the Component class and when placed over a Frame, displays as a blank area.For the purpose of drawing graphics, you may use any other class derived from the Component class, for instance, JPanel or even JTextField or JButton. Why we use the Canvas class is purely to grasp the idea of drawing in Java.Let us refine the above code for the class to be executable and the Canvas to be displayed. For this we will add an entry-point method namely the main(String[]) method in its body and calling a JFrame class to load the canvas on.Code listing 9.2: Displaying a Canvas class atop a JFrame\n\n\nimport java.awt.*;\nimport javax.swing.*;\n\npublic class MyCanvas extends Canvas {\n    public MyCanvas() {\n    }\n\n    public void paint(Graphics graphics) {\n    }\n\n    public static void main(String[] args) {\n        // We initialize our class here\n        MyCanvas canvas = new MyCanvas();\n        JFrame frame = new JFrame();\n        frame.setSize(400, 400);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        // Here we add it to the frame\n        frame.getContentPane().add(canvas);\n        frame.setVisible(true);\n    }\n}The following code now helps our class to be executable and displays the canvas on top of the frame as it displays. Running this class would result in an empty frame, however it should be clear that the canvas is sitting atop it and is merely not displaying any drawings yet.Figure 9.1: A blank canvas atop a JFrame", "title": "Understanding the Canvas class[edit]"}], "title": "Canvas"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Graphics", "content": "Navigate User Interface topic:(vde)\n\n Basic I/O\n Streams\n Event handling\n JavaBeans\n Canvas\n Graphics\n\n Drawing basic shapes\n Drawing complex shapes\n Drawing text\n Understanding gradients\n\n\n Applets\n\n\n\n\n Overview\n User Interface\n Event Listeners\n Graphics and Media", "subdata": [], "title": "Graphics"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Graphics/Drawing_shapes", "content": "Navigate User Interface topic:(vde)\n\n Basic I/O\n Streams\n Event handling\n JavaBeans\n Canvas\n Graphics\n\n Drawing basic shapes\n Drawing complex shapes\n Drawing text\n Understanding gradients\n\n\n Applets\n\n\n\n\n Overview\n User Interface\n Event Listeners\n Graphics and Media", "subdata": [{"content": "Throughout this chapter, we will refer to the process of creating Graphical content with code as either drawing or painting. However, Java officially recognizes the latter as the proper word for the process, but we will differentiate between the two later on.Now, the main class that you would be needing would, without doubt, be the Graphics class. If you take a closer look at the method that we used in theIdentifying the acquisition of the Graphics class in our codeCode listing 9.3: A basic canvas\n\n\nimport java.awt.*;\nimport javax.swing.*;\npublic class MyCanvas extends Canvas {\n    public MyCanvas() {\n    }\n\n    public void paint(Graphics graphics) {\n        /* We would be using this method only for the sake\n         * of brevity throughout the current section. Note\n         * that the Graphics class has been acquired along\n         * with the method that we overrode. */\n    }\n\n    public static void main(String[] args) {\n        MyCanvas canvas = new MyCanvas();\n        JFrame frame = new JFrame();\n        frame.setSize(400, 400);\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        frame.getContentPane().add(canvas);\n        frame.setVisible(true);\n    }\n}To view the contents of the Graphics class, please check the external links at the bottom of the page for links to the online API.", "title": "Introduction to Graphics[edit]"}, {"content": "Understanding coordinates[edit]To start off your drawing experience, consider drawing the most basic shape  a line. A canvas when viewed upon with regards to drawing routines can be expressed as an inverted Cartesian coordinate system. A plane expressed by an x- and a y-axis. The origin point or \n\n\n\n(\n0\n,\n0\n)\n\n\n{\\displaystyle (0,0)}\n\n being the top-left corner of a canvas and the visible area of the canvas being the Cartesian quadrant I or the positive-positive (+,+) quadrant. The further you go down from the top, the greater the value of y-coordinate on the y-axis, vice-versa for the x-axis as you move toward the right from the left. And unlike the values on a normal graph, the values appear to be positive. So a point at \n\n\n\n(\n10\n,\n20\n)\n\n\n{\\displaystyle (10,20)}\n\n would be 10 pixels away from the left and 20 pixels away from the top, hence the format \n\n\n\n(\nx\n,\ny\n)\n\n\n{\\displaystyle (x,y)}\n\n.Figure 9.2: A simple line form displayed across the canvas from Code section 9.4Drawing a simple line across the screen[edit]Now, we already know that a line is a connection of two discreet points atop a canvas. So, if one point is at \n\n\n\n(\nx\n1\n,\ny\n1\n)\n\n\n{\\displaystyle (x1,y1)}\n\n and the other is at \n\n\n\n(\nx\n2\n,\ny\n2\n)\n\n\n{\\displaystyle (x2,y2)}\n\n, drawing a line would require you to write a syntax like code below. For the sake of brevity, we will skim out the rest of the method unused in the example.Code section 9.4: Drawing a simple line form\n\n\n...\npublic class MyCanvas extends Canvas {\n    ...\n    public void paint(Graphics graphics) {\n        graphics.setColor(Color.black);\n        graphics.drawLine(40, 30, 330, 380);\n        \n    }\n    ...\n}In the above example, a simple method is used to define precisely where to place the line on the Cartesian scale of the canvas. The drawLine(int,int,int,int) asks you to put four arguments, appearing in order, the x1 coordinate, the y1 coordinate, the x2 coordinate and the y2 coordinate. Running the program will show a simple black line diagonally going across the canvas.Figure 9.3: A simple black-outlined rectangle drawn", "title": "Etching a line on the canvas[edit]"}, {"content": "We now proceed on to our second drawing. A simple rectangle would do it justice, see below for code.Code section 9.5: Drawing a simple rectangle\n\n\n...\npublic class MyCanvas extends Canvas {\n    ...\n    public void paint(Graphics graphics) {\n        graphics.drawRect(10, 10, 100, 100);\n    }\n    ...\n}In the above example, you see how easy it is to draw a simple rectangle using the drawRect(int, int, int, int) method in the Graphics instance that we obtained. Run the program and you will see a simple black outline of a rectangle appearing where once a blank canvas was.The four arguments that are being passed into the method are, in order of appearance, the x-coordinate, the y-coordinate, width and the height. Hence, the resultant rectangle would start painting at the point on the screen 10 pixels from the left and 10 from the top and would be a 100 pixel wide and a 100 pixel in height. To save the argument here, the above drawing is that of a square with equal sides but squares are drawn using the same method and there is no such method as drawSquare(int, int, int)Figure 9.4: Same rectangle drawn with a red outlinePlaying around with colors[edit]You can change the color of the outline by telling the Graphics instance the color you desire. This can be done as follows:Code section 9.6: Changing the outline color of the rectangle\n\n\n...\npublic class MyCanvas extends Canvas {\n    ...\n    public void paint(Graphics graphics) {\n        graphics.setColor(Color.red);\n        graphics.drawRect(100, 100, 500, 500);\n    }\n    ...\n}Running the program would render the same rectangle but with a red colored outline.For the purposes of bringing color to our drawing, we used a method namely the setColor(Color) method. This method comes into force for all the drawing made after its call until another color is set. It asks for an argument of type Color. Now because you have no idea of how to actually instantiate a Color class, the class itself has a few built-in colors. Some built-in colors that you can use are mentioned below.Color.red\nColor.blue\nColor.green\nColor.yellow\nColor.pink\nColor.black\nColor.whiteTry running the program while coding changes to colors for a different colored outline each time. Play around a bit with more colors. Look for the Color class API documentation in the external links at the bottom of the page.Figure 9.5: Same rectangle drawn with a red outline and a yellow fillFilling up the area of the rectangle[edit]Up until now, you have been able to draw a simple rectangle for yourself while asking a question silently, \"why is the outline of the rectangle being painted rather the area as a whole?\" The answer is simple. Any method that starts with drawXxxx(...) only draws the outline. To paint the area within the outline, we use the fillXxxx(...) methods. For instance, the code below would fill a rectangle with yellow color while having a red outline. Notice that the arguments remain the same.Code section 9.7: Drawing a yellow rectangle with a red outline\n\n\n...\npublic class MyCanvas extends Canvas {\n    ...\n    public void paint(Graphics graphics) {\n        graphics.setColor(Color.yellow);\n        graphics.fillRect(10, 10, 100, 100);\n        graphics.setColor(Color.red);\n        graphics.drawRect(10, 10, 100, 100);\n    }\n    ...\n}Figure 9.6: A white circle drawn with a blue outline", "title": "Drawing a simple rectangle[edit]"}, {"content": "Drawing a circle is ever so easy? It is the same process as the syntax above only that the word Rect is changed to the word Oval. And don't ask me why oval? You simply don't have the method drawCircle(int, int, int) as you don't have drawSquare(int, int, int). Following is the application of Graphics code to draw a circle just to whet your appetite.Code section 9.8: Drawing a white circle with a blue outline\n\n\n...\npublic class MyCanvas extends Canvas {\n    ...\n    public void paint(Graphics graphics) {\n        graphics.setColor(new Color(0,0,255));\n        graphics.drawOval(50, 50, 100, 100);\n    }\n    ...\n}", "title": "What about a circle?[edit]"}, {"content": "Figure 9.7: A pink rounded rectangle with a red outline. Amazing!Simple so far, isn't it? Of all the shapes out there, these two are the only shapes that you'd need to build for the moment. Complex graphics routines are required to build shapes like a rhombus, triangle, trapezium or a parallelogram. We would be tackling them later on in another section. However, on a last note I would leave you with another interesting shape - a combination of both ovals and rectangle. Think a rectangle with rounded corners, a Rounded Rectangle (RoundRect).Code section 9.9: Drawing a pink rounded rectangle with a red outline\n\n\n...\npublic class MyCanvas extends Canvas {\n    ...\n    public void paint(Graphics graphics) {\n        graphics.setColor(Color.pink);\n        graphics.fillRoundRect(10, 10, 100, 100, 5, 5);\n        graphics.setColor(Color.red);\n        graphics.drawRoundRect(10, 10, 100, 100, 5, 5);\n    }\n    ...\n}Notice that the syntax of the drawRoundRect(int, int, int, int, int, int) method is a bit different than the syntax for the simple rectangle drawing routine drawRect(int, int, int, int). The two new arguments added at the end are the width of the arc in pixels and the height of the arc in pixels. The result is pretty amazing when you run the program. You don't need to squint your eyes to tell that the corners of the rectangle are slightly rounded. The more the values of the width and height of the arcs, the more roundness appears to form around the corner.", "title": "A new form of a rectangle[edit]"}, {"content": "Sometimes people ask, after creating simple programs like the ones above, questions like:Why did I have to tell the Graphics instance the color before each drawing routine? Why can't it remember my choice for the outlines and for the fill colors? The answer is simpler than it seems. But, to fully understand it, we need to focus on one little thing called the Graphics Context. The graphics context is the information that adheres to a single instance of the Graphics class. Such an instance remembers only one color at a time and that is why we need to make sure the context knows of the color we need to use by using the setColor(Color) method.\nCan I manipulate the shapes, like tilt them and crop them? Hold your horses, cowboy! Everything is possible in Java, even tilting and cropping drawings. We will be focusing on these issues in a later section.\nIs making shapes like triangles, rhombuses and other complex ones tedious? Well, to be honest here, you need to go back to your dusty book cabinet and take out that High School Geometry book because we would be covering some geometry basics while dealing with such shapes. Why not read a wikibook on Geometry?Test your knowledge\n\nQuestion 9.3: Throughout the exercise listings above, we have been filling the shapes first and then drawing their outlines. What happens if we do it the other way around? Consider the code below.\n\n\n...\npublic void paint(Graphics graphics) {\n    graphics.setColor(Color.red);\n    graphics.drawRect(10, 10, 100, 100);\n    graphics.setColor(Color.yellow);\n    graphics.fillRect(10, 10, 100, 100);\n}\n...\n\n\nThe left and the top outlines disappear.\nThe right and the bottom outlines disappear.\nThe color for the outline becomes the color for the fill area.\nAll the outlines disappear.\n\n\nAnswer\n\nAll the outlines disappear.\n\n\nQuestion 9.4: What would drawLine(10, 100, 100, 100) give you?\n\nA horizontal line.\nA vertical line.\nA diagonal line.\n\n\nAnswer\n\nA horizontal line.If you have any questions regarding the content provided here, please feel free to comment in this page's discussion.", "title": "Hmm, everything's perfect, but...[edit]"}], "title": "Drawing shapes"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Graphics/Drawing_complex_shapes", "subdata": [], "title": "Drawing complex shapes"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Graphics/Drawing_text", "subdata": [], "title": "Drawing text"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Graphics/Understanding_gradients", "subdata": [], "title": "Understanding gradients"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Applets", "subdata": [], "title": "Applets"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Applets/Overview", "content": "Navigate User Interface topic:(vde)\n\n Basic I/O\n Streams\n Event handling\n JavaBeans\n Canvas\n Graphics\n\n Drawing basic shapes\n Drawing complex shapes\n Drawing text\n Understanding gradients\n\n\n Applets\n\n\n\n\n Overview\n User Interface\n Event Listeners\n Graphics and MediaA Java applet is an applet delivered in the form of Java bytecode. Java applets can run in a Web browser using a Java Virtual Machine (JVM), or in Oracle's AppletViewer, a stand alone tool to test applets. Java applets were introduced in the first version of the Java language in 1995. Java applets are usually written in the Java programming language but they can also be written in other languages that compile to Java bytecode such as Jython.Applets are used to provide interactive features to web applications that cannot be provided by HTML. Since Java's bytecode is platform independent, Java applets can be executed by browsers for many platforms, including Windows, Unix, Mac OS and Linux. There are open source tools like applet2app which can be used to convert an applet to a stand alone Java application/windows executable. This has the advantage of running a Java applet in off-line mode without the need for Internet browser software.The Java applet is less and less used. You'd rather use JavaScript when it is possible.", "subdata": [{"content": "The two things you must at least create is an HTML page and a Java class. It can be done on a local folder, no need to run a server but it will be harder to understand what is local, what is remote. The HTML page has to call the Java class using the <applet/> markup:Code listing 9.3: HelloWorld.html\n\n\n1 <!DOCTYPE html>\n2 <html>\n3   <body>\n4     HTML content before the applet.<applet code=\"HelloWorld\" height=\"40\" width=\"200\"></applet>HTML content after the applet.\n5   </body>\n6 </html>Save this file on a folder. As the <applet/> markup is calling a Java class called HelloWorld, our class should be called HelloWorld.java:Code listing 9.4: HelloWorld.java\n\n\n 1 import java.applet.Applet;\n 2 import java.awt.Graphics;\n 3 \n 4 public class HelloWorld extends Applet {\n 5 \n 6     /**\n 7      * Print a message on the screen.\n 8      */\n 9     public void paint(Graphics g) {\n10         g.drawString(\"Hello, world!\", 20, 10);\n11     }\n12 }Save this file and compile the class on the same folder. Now let's open the web page on a browser:Figure 9.8: Java applet HelloWorld.We clearly see that \"Hello, world!\" is not rendered the same way as the rest of the page.", "title": "First applet[edit]"}, {"content": "See also applet markup.To embed an applet in a HTML page, you have to insert a <applet/> markup. This markup can have several attributes:code*\nThe name of the main class to call. It could be the name of the class with or without the .class .\n\n\nheight\nThe height of the area where the content of the applet can be rendered on the web page.\n\n\nwidth\nThe width of the area where the content of the applet can be rendered on the web page.\n\n\narchive\nThe name of a compressed zip archive having .jar extension. The archive can contain all the needed classes to run the applet. Applets are usually delivered in this form, to minimize the download time.The attributes with * are mandatory.There have been some discussions about the usage of applet tag but it still can be used for beginning and also would work in the real world as well.", "title": "HTML code[edit]"}], "title": "Overview"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Applets/User_Interface", "content": "Navigate User Interface topic:(vde)\n\n Basic I/O\n Streams\n Event handling\n JavaBeans\n Canvas\n Graphics\n\n Drawing basic shapes\n Drawing complex shapes\n Drawing text\n Understanding gradients\n\n\n Applets\n\n\n\n\n Overview\n User Interface\n Event Listeners\n Graphics and MediaThe main difference between an applet and a regular command-line executed program is that applets allow for extensible Graphical User Interfaces (GUI).Since applets provide for the ability to create complex GUI, it is important for developers to know how to create such programs.", "subdata": [{"content": "In Java applets, graphical portions are initialized and added in two different areas. While objects are initialized in the main class, they are added to the layout of the applet in the init() method. This is done using the syntax of add(<object>). A typical init() method looks something like this:Code section 9.8: A typical init() method\n\n\n 1 ...\n 2 \n 3 public void init() {\n 4     setFont(new Font(\"Times New Roman\", Font.PLAIN, 24));\n 5     setForeground(Color.white);\n 6     setBackground(Color.black);\n 7     setLayout(new GridLayout);\n 8    \n 9     ...\n10    \n11     add(label);\n12     add(button);\n13 }The different aspects of this method will be covered below.", "title": "Applying styles and adding content[edit]"}, {"content": "Lots of applets use buttons. There are only a few ways to have contact between the applet and the user, and the use of buttons is one of those ways. Buttons are created the same way as most other Java applet objects:Code section 9.9: Button creation\n\n\n1 Button submitButton = new Button(\"Submit\");When initializing a button, it is necessary to define what text will appear on that button in the given parameter. In this example, the button is initialized with the word \"Submit\" printed on it. Adding the button to the actual layout is done in the init() method, as described above.Code section 9.10: Button display\n\n\n1 public void init() {\n2    \n3     ...\n4    \n5     add(submitButton);\n6 }Allowing buttons to carry out tasks or utilize a user's input is a bit more complicated. These functions require an ActionListener, and will be discussed in ActionListener section.", "title": "Button[edit]"}, {"content": "Labels are areas in applets that contain text which can not be edited by the user. This is usually ideal for descriptions (i.e. \"Insert name:\"). Labels are initialized and added to applet layouts in the same way as buttons. Also, like buttons, the text inside labels must be identified at initialization. If, however, the label will receive its text as the cause of a later function and should start off blank, no text should be placed between the quotation marks.Code section 9.11: Label display\n\n\n1 Label nameLabel = new Label(\"Name: \");\n2 \n3 ...\n4 \n5 public void init() {\n6     add(nameLabel);\n7 }", "title": "Label[edit]"}, {"content": "TextFields are areas in applets that allow users to insert text. The two parameters, which are optional, for TextFields can set predefined text in the field or set the number of columns allowed in the TextField. Here are a few examples:Code section 9.12: Text field creation\n\n\n 1     TextField t1 = new TextField();                // Blank\n 2     TextField t2 = new TextField(5);               // Blank in 5 columns\n 3     TextField t3 = new TextField(\"Input here\");    // Predefined text\n 4     TextField t4 = new TextField(\"Input here\", 5); // Predefined text in 5 columns\n 5 \n 6     ...\n 7 \n 8     public void init() {\n 9         add(t1);\n10         add(t2);\n11         add(t3);\n12         add(t4);\n13         ...\n14     }", "title": "TextField[edit]"}, {"content": "Using stylish fonts in your Java applets may be necessary to help keep your Java applets attractive. The setFont() allows for either the font used throughout the applet to be defined or for one element's font to be set at a time.The syntax for setting a font is setFont(<fontName>, <fontStyle>, <fontSize>).To make every font in the applet plain, size 24 Times New Roman, the following code should be used:Code section 9.13: Font setting\n\n\n1 Font f = new Font(\"Times New Roman\", Font.PLAIN, 24);\n2 setFont(f);It is not necessary to initialize the font and set the font through two different lines of code.Code section 9.14: Direct font setting\n\n\n1 setFont(new Font(\"Times New Roman\", Font.PLAIN, 24));However, to make the font of element a plain, size 24 Times New Roman, and element b italicized, size 28 Times New Roman, the following code should be used:Code section 9.15: Object font setting\n\n\n1 a.setFont(new Font(\"Times New Roman\", Font.PLAIN, 24));\n2 b.setFont(new Font(\"Times New Roman\", Font.ITALIC, 28));To set the color of the fonts used in an applet, the setForeground(<color>) method is used. This method already includes some predefined colors which can be used by calling, for example, setForeground(Color.white). Here are all of the predefined colors:Color.black\nColor.blue\nColor.cyan\nColor.darkGray\nColor.gray\nColor.green\nColor.red\nColor.white\nColor.yellowTo create a custom color, the RGB values of the color can be passed in as the color parameter. For example, if red were not a predefined color, one could use setForeground(new Color(255, 0, 0)) to define red.Just as font styles, font colors can be applied to separate elements. The syntax follows the same pattern: a.setForeground(Color.white).", "title": "Font[edit]"}, {"content": "Layouts are what make applets visible. Without a layout, nothing would display. There are five different types of layouts to choose from  some are very simple while others are complex.Flow Layout[edit]This layout places components left to right, using as much space as is needed. The Flow Layout is the default layout for applets and, therefore, does not need to be set. However, for clarity, one can specify the applet layout as a Flow Layout by placing this line of code at the top of the init() method:Code section 9.16: Flow Layout\n\n\n1 setLayout(new FlowLayout());The added components to the layout that follow will be placed on screen in order of which they are added.Code section 9.17: Component display\n\n\n1 public void init() {\n2     setLayout(new FlowLayout());\n3     add(nameLabel);\n4     add(t1);\n5     add(submitButton);\n6 }Assuming that these variables are defined the same as above, these lines of code will create the layout of an applet that is composed of a label, a text field, and a button. They will all appear on one line if the window permits. By changing the width of window, the Flow Layout will contract and expand the components accordingly.Grid Layout[edit]This layout arranges components in the form of the table (grid). The number of rows and columns in the grid is specified in the constructor. The other two parameters, if present, specify vertical and horizontal padding between components.Code listing 9.4: GridLayoutApplet.java\n\n\n 1 import java.applet.Applet;\n 2 import java.awt.Button;\n 3 import java.awt.GridLayout;\n 4 import java.awt.Label;\n 5 import java.awt.TextField;\n 6 \n 7 public class GridLayoutApplet extends Applet {\n 8 \n 9     Button submitButton = new Button(\"Submit\");\n10     TextField t1 = new TextField();                // Blank\n11     TextField t2 = new TextField(5);               // Blank in 5 columns\n12     TextField t3 = new TextField(\"Input here\");    // Predefined text\n13     TextField t4 = new TextField(\"Input here\", 5); // Predefined text in 5 columns\n14     Label nameLabel = new Label(\"Name: \");\n15 \n16     /**\n17      * Init.\n18      */\n19     public void init() {\n20         // 3 rows, 4 columns, 2 pixel spacing\n21         setLayout(new GridLayout(3, 4, 2, 2));\n22         add(nameLabel);\n23         add(t1);\n24         add(t2);\n25         add(t3);\n26         add(t4);\n27         add(submitButton);\n28     }\n29 }The items have been displayed in this order:1st\n2nd\n\n\n\n\n3th\n4th\n\n\n\n\n5th\n6thWe see that the layout has been configured to fill the grid left-to-right and then top-to-bottom and that the two last columns have been ignored (they don't even exist). They have been ignored because there are not enough items to fill them and the number of rows is prior to the number of columns. This means that when you specify a number of rows that is not zero, the number of columns is simply ignored. You should specify zero rows in order that the number of columns is taken into account.A grid layout creates cells with equal sizes. So it can be used not only to display items as a grid but also to display two items with the same width or height.Border Layout[edit]This layout places one big component in the center and up till four components at the edges. When adding to the container with this layout, you need to specify the location as the second parameter like BorderLayout.CENTER for the center or one of the world directions for the edge (BorderLayout.NORTH points to the top edge).Code section 9.19: Border layout\n\n\n1 import java.awt.*;\n2 \n3 Container container = getContentPane();\n4 container.setLayout(new BorderLayout());\n5 \n6 JButton b2 = new JButton(\"two\");\n7 // Add the button to the right edge.\n8 container.add(b2, BorderLayout.EAST);\n9 ...If you have two components, it is not the same to put the first in the north and the second to the center as to put the first in the center and the second to the south. In the first case, the layout will calculate the size of the component and the second component will have all the space left. In the second case, it is the opposite.Card Layout[edit]A card stackThe card layout displays only one item at a time and is only interesting with interactivity. The other items are stored in a stack and the displayed item is one of the items of the stack. The name of the card layout is a reference to a playing card deck where you can see the card at the top of the stack and you can put a card on the top. The difference in the card layout is that the items in the stack keeps their order. When you use this layout, you must use this method to add items to the container, i.e. the applet:void add(String itemId, Component item)\nAdds an item to the container and associate the item to the id.The card layout has several methods to change the currently displayed item:void first(Container container)\nDisplay the first item of the stack.\n\n\nvoid next(Container container)\nDisplay the item of the stack that is located after the displayed item.\n\n\nvoid previous(Container container)\nDisplay the item of the stack that is located before the displayed item.\n\n\nvoid last(Container container)\nDisplay the last item of the stack.\n\n\nvoid show(Container container, String itemId)\nDisplay an item by its id.Code listing 9.5: CardLayoutApplet.java\n\n\n 1 import java.applet.Applet;\n 2 import java.awt.CardLayout;\n 3 import java.awt.Label;\n 4 \n 5 public class CardLayoutApplet extends Applet {\n 6 \n 7     static final String COMPONENT_POSITION_TOP = \"TOP\";\n 8     static final String COMPONENT_POSITION_MIDDLE = \"MIDDLE\";\n 9     static final String COMPONENT_POSITION_BOTTOM = \"BOTTOM\";\n10 \n11     Label topLabel = new Label(\"At the top\");\n12     Label middleLabel = new Label(\"In the middle\");\n13     Label bottomLabel = new Label(\"At the bottom\");\n14 \n15     /**\n16      * Init.\n17      */\n18     public void init() {\n19         setLayout(new CardLayout());\n20         add(COMPONENT_POSITION_TOP, topLabel);\n21         add(COMPONENT_POSITION_MIDDLE, middleLabel);\n22         add(COMPONENT_POSITION_BOTTOM, bottomLabel);\n23         ((CardLayout)getLayout()).show(this, COMPONENT_POSITION_MIDDLE);\n24     }\n25 }", "title": "Layout[edit]"}], "title": "UserInterface"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Applets/Event_Listeners", "content": "Navigate User Interface topic:(vde)\n\n Basic I/O\n Streams\n Event handling\n JavaBeans\n Canvas\n Graphics\n\n Drawing basic shapes\n Drawing complex shapes\n Drawing text\n Understanding gradients\n\n\n Applets\n\n\n\n\n Overview\n User Interface\n Event Listeners\n Graphics and MediaAn Event Listener, once set to an applet object, waits for some action to be performed on it, be it mouse click, mouse hover, pressing of keys, click of button, etc. The class you are using (e.g. JButton, etc.) reports the activity to a class set by the class using it. That method then decides on how to react because of that action, usually with a series of if statements to determine which action it was performed on. source.getSource() will return the name of the object that the event was performed on, while the source is the object passed to the function when the action is performed. Every single time the action is performed, it calls the method.", "subdata": [{"content": "ActionListener is an interface that could be implemented in order to determine how a certain event should be handled. When implementing an interface, all methods in that interface should be implemented, ActionListener interface has one method to implement named actionPerformed().The code listing 9.6 shows how to implement ActionListener:Code listing 9.6: EventApplet.java\n\n\n 1 import java.applet.Applet;\n 2 import java.awt.Button;\n 3 import java.awt.Container;\n 4 import java.awt.Dialog;\n 5 import java.awt.FlowLayout;\n 6 import java.awt.Frame;\n 7 import java.awt.Label;\n 8 import java.awt.event.ActionEvent;\n 9 import java.awt.event.ActionListener;\n10 \n11 public class EventApplet extends Applet {\n12 \n13     /**\n14      * Init.\n15      */\n16     public void init() {\n17         Button clickMeButton = new Button(\"Click me\");\n18 \n19         final Applet eventApplet = this;\n20 \n21         ActionListener specificClassToPerformButtonAction = new ActionListener() {\n22 \n23             public void actionPerformed(ActionEvent event) {\n24                 Dialog dialog = new Dialog(getParentFrame(eventApplet), false);\n25                 dialog.setLayout(new FlowLayout());\n26                 dialog.add(new Label(\"Hi!!!\"));\n27                 dialog.pack();\n28                 dialog.setLocation(100, 100);\n29                 dialog.setVisible(true);\n30             }\n31 \n32             private Frame getParentFrame(Container container) {\n33                 if (container == null) {\n34                     return null;\n35                 } else if (container instanceof Frame) {\n36                     return (Frame) container;\n37                 } else {\n38                     return getParentFrame(container.getParent());\n39                 }\n40 \n41             }\n42         };\n43         clickMeButton.addActionListener(specificClassToPerformButtonAction);\n44 \n45         add(clickMeButton);\n46     }\n47 }When you compile and run the above code, the message \"Hi!!!\" will appear when you click on the button.", "title": "ActionListener[edit]"}], "title": "Event Listeners"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Applets/Graphics_and_Media", "subdata": [], "title": "Graphics and Media"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Reflection", "subdata": [], "title": "Reflection"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Reflection/Overview", "content": "Navigate Reflection topic: (vde)\n\n Reflection Overview\n Dynamic Class Loading\n Dynamic Method Invocation\n Accessing Private Features with ReflectionReflection is the mechanism by which Java exposes the features of a class during runtime, allowing Java programs to enumerate and access a class' methods, fields, and constructors as objects. In other words, there are object-based mirrors that reflect the Java object model, and you can use these objects to access an object's features using runtime API constructs instead of compile-time language constructs. Each object instance has a getClass() method, inherited from java.lang.Object, which returns an object with the runtime representation of that object's class; this object is an instance of the java.lang.Class, which in turn has methods that return the fields, methods, constructors, superclass, and other properties of that class. You can use these reflection objects to access fields, invoke methods, or instantiate instances, all without having compile-time dependencies on those features. The Java runtime provides the corresponding classes for reflection. Most of the Java classes that support reflection are in the java.lang.reflect package. Reflection is most useful for performing dynamic operations with Java  operations that are not hard-coded into a source program, but that are determined at run time. One of the most important aspects of reflection is dynamic class loading.", "subdata": [], "title": "Reflection Overview"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Reflection/Dynamic_Class_Loading", "content": "Navigate Reflection topic: (vde)\n\n Reflection Overview\n Dynamic Class Loading\n Dynamic Method Invocation\n Accessing Private Features with ReflectionDynamic Class Loading allows the loading of java code that is not known about before a program starts. Many classes rely on other classes and resources such as icons which make loading a single class unfeasible. For this reason the ClassLoader (java.lang.ClassLoader) is used to manage all the inner dependencies of a collection of classes. The Java model loads classes as needed and doesn't need to know the name of all classes in a collection before any one of its classes can be loaded and run.", "subdata": [], "title": "Dynamic Class Loading"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Reflection/Dynamic_Invocation", "subdata": [], "title": "Dynamic Invocation"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Reflection/Accessing_Private_Features_with_Reflection", "subdata": [], "title": "Accessing Private Features with Reflection"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Networking", "subdata": [], "title": "Networking"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Database_Programming", "content": "Navigate Advanced topic: (vde)\n\n Networking\n Database programming\n Regular Expressions\n Libraries, extensions and frameworks\n 3D programming\n Java Native Interface\n Invoking C\n Byte CodeJava uses JDBC, an API that defines how a client may access a database. Its drivers may be installed first. [1][2]", "subdata": [{"content": "The following is used to open an ODBC connection to an Access database. Note that the username (and password, if applicable) are given in the DSN rather than the getConnection call. This is a MS Windows-only example, due to the requirement for the Microsoft Access Driver.Class.forName(\"sun.jdbc.odbc.JdbcOdbcDriver\");\nString path = \"C:/example.mdb\";\nString dsn = \"jdbc:odbc:Driver={Microsoft Access Driver (*.mdb)};DBQ=\" + path + \";UID=admin\";\naccessConn = DriverManager.getConnection(dsn, \"\", \"\");", "title": "Connecting to Microsoft Access databases[edit]"}, {"content": "try {\n   Class.forName(\"com.mysql.jdbc.Driver\");\n   Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost/MySite?user=MyAccount&password=MyPassword\");\n   conn.close();\n} catch(SQLException e) { e.printStackTrace(); }", "title": "Connecting to MySQL[edit]"}, {"content": "This script returns the database size:import java.sql.*; \nimport java.io.*; \nimport oracle.jdbc.*; \nimport oracle.sql.*; \n\npublic class OracleDatabase {\n  public static void main(String[] args) {\n    try {\n      DriverManager.registerDriver(new oracle.jdbc.OracleDriver());\n      Connection conn = DriverManager.getConnection(\"jdbc:oracle:thin:@localhost:1521:MyDatabase\", \"MyAccount\", \"MyPassword\"); \t\n      conn.setAutoCommit(true);\n      String sql = \"SELECT sum(bytes) from dba_segments;\";\n      Statement stmt = conn.createStatement();\n      stmt.execute(sql); \n      stmt.close();\n      conn.close();   \n    } catch(SQLException e) { e.printStackTrace(); }\n  }\n}", "title": "Connecting to Oracle Database[edit]"}, {"content": "try {\n   Class.forName(\"org.postgresql.Driver\");\n   Connection conn = DriverManager.getConnection(\"jdbc:postgresql:MyDatabase\", \"MyAccount\", \"MyPassword\");\n   conn.close();\n} catch(SQLException e) { e.printStackTrace(); }", "title": "Connecting to PostgreSQL[edit]"}, {"content": "package oracle.jdbc does not exist[edit]If you have Oracle Database on your PC, just add to the classpath its following files[3]:C:\\oracle12\\app\\oracle\\product\\12.1.0\\dbhome_1\\jdbc\\lib\\ojdbc7.jar\nC:\\oracle12\\app\\oracle\\product\\12.1.0\\dbhome_1\\sqlj\\lib\\runtime12.jarOtherwise, ojdbc7.jar can be downloaded from http://www.oracle.com/technetwork/database/features/jdbc/jdbc-drivers-12c-download-1958347.html, and add it to the compilation. Eg:javac MyClass.java -classpath ojdbc7.jarORA-28009: connection as SYS should be as SYSDBA or SYSOPER[edit]Just add \" as sysdba\" after your Oracle account name, eg:Connection conn = DriverManager.getConnection(\"jdbc:oracle:thin:@localhost:1521:MyDatabase\", \"MyAccount as sysdba\",", "title": "Known errors[edit]"}], "title": "Database Programming"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Regular_Expressions", "content": "Navigate Advanced topic: (vde)\n\n Networking\n Database programming\n Regular Expressions\n Libraries, extensions and frameworks\n 3D programming\n Java Native Interface\n Invoking C\n Byte CodeThe regular expressions (regex) are provided by the package java.util.regex.", "subdata": [{"content": "The Pattern class offers the function matches which returns true if an expression is found into a string.For example, this script returns the unknown word preceding a known word:import java.util.regex.Pattern;\npublic class Regex {\n\tpublic static void main(String[] args) {\n\t\tString s = \"Test Java regex for Wikibooks.\";\n\t\tSystem.out.println(Pattern.matches(\"[a-z]* Wikibooks\",s));\n    }\n}\n// Displays: \"for Wikibooks\"The Matcher class allows to get all matches for a given expression, with different methods:find(): find the next result.\ngroup(): displays the result.For example, this script displays the HTML b tags contents:import java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class Regex {\n\tpublic static void main(String[] args) {\n\t\tString s = \"Test <i>Java</i> <b>regex</b> for <b>Wikibooks</b>.\";\n\t\tPattern p = Pattern.compile(\"<b>([^<]+)</b>\");\n\t\tMatcher m = p.matcher(s);\n\t\twhile(m.find()) {\n\t\t\tSystem.out.println(m.group());\n\t\t\tSystem.out.println(m.group(1));\n\t\t}\n\t}\n}\n/* Displays:\n <b>regex</b>\n regex\n <b>Wikibooks</b>\n Wikibooks\n*/", "title": "Researches[edit]"}], "title": "Regular Expressions"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Libraries,_extensions_and_frameworks", "content": "Navigate Advanced topic: (vde)\n\n Networking\n Database programming\n Regular Expressions\n Libraries, extensions and frameworks\n 3D programming\n Java Native Interface\n Invoking C\n Byte Code", "subdata": [], "title": "Libraries, extensions and frameworks"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/3D_Programming", "content": "This page or section is an undeveloped draft or outline.\nYou can help to develop the work, or you can ask for assistance in the project room.Although Java comes with the Java 3D library other libraries have been developed over time with similar functionality. Thus, unlike many other areas of Java development explored in this book, a Java programmer has a choice to make as to which 3D library to use.", "subdata": [], "title": "3D Programming"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Java_Native_Interface", "content": "Navigate Advanced topic: (vde)\n\n Networking\n Database programming\n Regular Expressions\n Libraries, extensions and frameworks\n 3D programming\n Java Native Interface\n Invoking C\n Byte CodeThe Java Native Interface (JNI) enables Java code running in a Java Virtual Machine (JVM) to call and to be called by native applications (programs specific to a hardware and operating system platform) and libraries written in other languages, such as C, C++ and assembly.JNI can be used:To implement or use features that are platform-specific.\nTo implement or use features that the standard Java class library does not support.\nTo enable an existing applicationwritten in another programming languageto be accessible to Java applications.\nTo let a native method use Java objects in the same way that Java code uses these objects (a native method can create Java objects and then inspect and use these objects to perform its tasks).\nTo let a native method inspect and use objects created by Java application code.\nFor time-critical calculations or operations like solving complicated mathematical equations (native code may be faster than JVM code).On the other hand, an application that relies on JNI loses the platform portability Java offers. So you will have to write a separate implementation of JNI code for each platform and have Java detect the operating system and load the correct one at runtime. Many of the standard library classes depend on JNI to provide functionality to the developer and the user (file I/O, sound capabilities...). Including performance- and platform-sensitive API implementations in the standard library allows all Java applications to access this functionality in a safe and platform-independent manner. Only applications and signed applets can invoke JNI. JNI should be used with caution. Subtle errors in the use of JNI can destabilize the entire JVM in ways that are very difficult to reproduce and debug. Error checking is a must or it has the potential to crash the JNI side and the JVM.This page will only explain how to call native code from JVM, not how to call JVM from native code.", "subdata": [{"content": "In the JNI framework, native functions are implemented in separate .c or .cpp files. C++ provides a slightly simpler interface with JNI. When the JVM invokes the function, it passes a JNIEnv pointer, a jobject pointer, and any Java arguments declared by the Java method. A JNI function may look like this:JNIEXPORT void JNICALL Java_ClassName_MethodName\n   (JNIEnv *env, jobject obj)\n {\n     /*Implement Native Method Here*/\n }The env pointer is a structure that contains the interface to the JVM. It includes all of the functions necessary to interact with the JVM and to work with Java objects. Example JNI functions are converting native arrays to/from Java arrays, converting native strings to/from Java strings, instantiating objects, throwing exceptions, etc. Basically, anything that Java code can do can be done using JNIEnv, albeit with considerably less ease.On Linux and Solaris platforms, if the native code registers itself as a signal handler, it could intercept signals intended for the JVM. Signal chaining should be used to allow native code to better interoperate with JVM. On Windows platforms, Structured Exception Handling (SEH) may be employed to wrap native code in SEH try/catch blocks so as to capture machine (CPU/FPU) generated software interrupts (such as NULL pointer access violations and divide-by-zero operations), and to handle these situations before the interrupt is propagated back up into the JVM (i.e. Java side code), in all likelihood resulting in an unhandled exception.C++ code[edit]For example, the following converts a Java string to a native string:extern \"C\"\n JNIEXPORT void JNICALL Java_ClassName_MethodName\n   (JNIEnv *env, jobject obj, jstring javaString)\n {\n     //Get the native string from javaString\n     const char *nativeString = env->GetStringUTFChars(javaString, 0);\n\n     //Do something with the nativeString\n\n     //DON'T FORGET THIS LINE!!!\n     env->ReleaseStringUTFChars(javaString, nativeString);\n }The JNI framework does not provide any automatic garbage collection for non-JVM memory resources allocated by code executing on the native side. Consequently, native side code (such as C, C++, or assembly language) must assume the responsibility for explicitly releasing any such memory resources that it itself acquires.C code[edit]JNIEXPORT void JNICALL Java_ClassName_MethodName\n   (JNIEnv *env, jobject obj, jstring javaString)\n {\n     /*Get the native string from javaString*/\n     const char *nativeString = (*env)->GetStringUTFChars(env, javaString, 0);\n\n     /*Do something with the nativeString*/\n\n     /*DON'T FORGET THIS LINE!!!*/\n     (*env)->ReleaseStringUTFChars(env, javaString, nativeString);\n }Note that C++ JNI code is syntactically slightly cleaner than C JNI code because like Java, C++ uses object method invocation semantics. That means that in C, the env parameter is dereferenced using (*env)-> and env has to be explicitly passed to JNIEnv methods. In C++, the env parameter is dereferenced using env-> and the env parameter is implicitly passed as part of the object method invocation semantics.Objective-C code[edit]JNIEXPORT void JNICALL Java_ClassName_MethodName(JNIEnv *env, jobject obj, jstring javaString)\n {\n     /*DON'T FORGET THIS LINE!!!*/\n     JNF_COCOA_ENTER(env);\n\n     /*Get the native string from javaString*/\n     NSString* nativeString = JNFJavaToNSString(env, javaString);\n\n     /*Do something with the nativeString*/\n\n     /*DON'T FORGET THIS LINE!!!*/\n     JNF_COCOA_EXIT(env);\n }JNI also allows direct access to assembly code, without even going through a C bridge.Mapping types[edit]Native data types can be mapped to/from Java data types. For compound types such as objects, arrays and strings the native code must explicitly convert the data by calling methods in the JNIEnv. The following table shows the mapping of types between Java (JNI) and native code.Native Type\nJNI Type\nDescription\nType signature\n\n\nunsigned char\njboolean\nunsigned 8 bits\nZ\n\n\nsigned char\njbyte\nsigned 8 bits\nB\n\n\nunsigned short\njchar\nunsigned 16 bits\nC\n\n\nshort\njshort\nsigned 16 bits\nS\n\n\nlong\njint\nsigned 32 bits\nI\n\n\n\nlong long\n__int64\n\njlong\nsigned 64 bits\nJ\n\n\nfloat\njfloat\n32 bits\nF\n\n\ndouble\njdouble\n64 bits\nDIn addition, the signature \"L fully-qualified-class;\" would mean the class uniquely specified by that name; e.g., the signature \"Ljava/lang/String;\" refers to the class java.lang.String. Also, prefixing [ to the signature makes the array of that type; for example, [I means the int array type. Finally, a void signature uses the V code. Here, these types are interchangeable. You can use jint where you normally use an int, and vice-versa, without any typecasting required.However, mapping between Java Strings and arrays to native strings and arrays is different. If you use a jstring in where a char * would be, your code could crash the JVM.JNIEXPORT void JNICALL Java_ClassName_MethodName\n        (JNIEnv *env, jobject obj, jstring javaString) {\n    // printf(\"%s\", javaString);        // INCORRECT: Could crash VM!\n\n    // Correct way: Create and release native string from Java string\n    const char *nativeString = (*env)->GetStringUTFChars(env, javaString, 0);\n    printf(\"%s\", nativeString);\n    (*env)->ReleaseStringUTFChars(env, javaString, nativeString);\n}The encoding used for the NewStringUTF, GetStringUTFLength, GetStringUTFChars, ReleaseStringUTFChars, GetStringUTFRegion functions is not standard UTF-8, but modified UTF-8. The null character (U+0000) and codepoints greater than or equal to U+10000 are encoded differently in modified UTF-8. Many programs actually use these functions incorrectly and treat the UTF-8 strings returned or passed into the functions as standard UTF-8 strings instead of modified UTF-8 strings. Programs should use the NewString, GetStringLength, GetStringChars, ReleaseStringChars, GetStringRegion, GetStringCritical, and ReleaseStringCritical functions, which use UTF-16LE encoding on little-endian architectures and UTF-16BE on big-endian architectures, and then use a UTF-16 to standard UTF-8 conversion routine.The code is similar with Java arrays, as illustrated in the example below that takes the sum of all the elements in an array.JNIEXPORT jint JNICALL Java_IntArray_sumArray\n        (JNIEnv *env, jobject obj, jintArray arr) {\n    jint buf[10];\n    jint i, sum = 0;\n    // This line is necessary, since Java arrays are not guaranteed\n    // to have a continuous memory layout like C arrays.\n    env->GetIntArrayRegion(arr, 0, 10, buf);\n    for (i = 0; i < 10; i++) {\n        sum += buf[i];\n    }\n    return sum;\n}Of course, there is much more to it than this.JNIEnv*[edit]A JNI environment pointer (JNIEnv*) is passed as an argument for each native function mapped to a Java method, allowing for interaction with the JNI environment within the native method. This JNI interface pointer can be stored, but remains valid only in the current thread. Other threads must first call AttachCurrentThread() to attach themselves to the VM and obtain a JNI interface pointer. Once attached, a native thread works like a regular Java thread running within a native method. The native thread remains attached to the VM until it calls DetachCurrentThread() to detach itself.To attach to the current thread and get a JNI interface pointer:JNIEnv *env;\n(*g_vm)->AttachCurrentThread (g_vm, (void **) &env, NULL);To detach from the current thread:(*g_vm)->DetachCurrentThread (g_vm);", "title": "Calling native code from JVM[edit]"}, {"content": "Code listing 10.1: HelloWorld.java\n\n\n 1 public class HelloWorld {\n 2  private native void print();\n 3 \n 4  public static void main(String[] args) {\n 5   new HelloWorld().print();\n 6  }\n 7 \n 8  static {\n 9   System.loadLibrary(\"HelloWorld\");\n10  }\n11 }HelloWorld.h/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class HelloWorld */\n\n#ifndef _Included_HelloWorld\n#define _Included_HelloWorld\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     HelloWorld\n * Method:    print\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_HelloWorld_print\n  (JNIEnv *, jobject);\n\n#ifdef __cplusplus\n}\n#endif\n#endiflibHelloWorld.c#include <stdio.h>\n #include \"HelloWorld.h\"\n\n JNIEXPORT void JNICALL\n Java_HelloWorld_print(JNIEnv *env, jobject obj)\n {\n     printf(\"Hello World!\\n\");\n     return;\n }make.sh#!/bin/sh\n\n# openbsd 4.9\n# gcc 4.2.1\n# openjdk 1.7.0\nJAVA_HOME=$(readlink -f /usr/bin/javac | sed \"s:bin/javac::\")\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.\njavac HelloWorld.java\njavah HelloWorld\ngcc -I${JAVA_HOME}/include -shared libHelloWorld.c -o libHelloWorld.so\njava HelloWorldCommands to execute on POSIX\n\nchmod +x make.sh\n./make.sh", "title": "HelloWorld[edit]"}], "title": "Java Native Interface"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Invoking_C", "content": "Navigate Advanced topic: (vde)\n\n Networking\n Database programming\n Regular Expressions\n Libraries, extensions and frameworks\n 3D programming\n Java Native Interface\n Invoking C\n Byte CodeYou can use Runtime.exec() method to invoke a program from within a running Java application. Runtime.exec() also allows you to perform operations related to the program, such as control the program's standard input and output, wait until it completes execution, and get its exit status.Here's a simple C application that illustrates these features. This C program will be called from Java:#include <stdio.h>\n\nint main() {\n    printf(\"testing\\n\");\n    return 0;\n}This application writes a string \"testing\" to standard output, and then terminates with an exit status of 0. To execute this simple program within a Java application, compile the C application:Compilation\n\n$ cc test.c -o testThen invoke the C program using this Java code:Code listing 10.2: Invoking C programs.\n\n\n 1 import java.io.InputStream;\n 2 import java.io.BufferedReader;\n 3 import java.io.InputStreamReader;\n 4 import java.io.IOException;\n 5 import java.io.InterruptedException;\n 6 import java.io.Process;\n 7 import java.io.Runtime;\n 8 \n 9 import java.util.ArrayList;\n10 \n11 public class ExecDemo {\n12     public static String[] runCommand(String cmd) throws IOException {\n13         // --- set up list to capture command output lines ---\n14         ArrayList list = new ArrayList();\n15 \n16         // --- start command running\n17         Process proc = Runtime.getRuntime().exec(cmd);\n18 \n19         // --- get command's output stream and\n20         // put a buffered reader input stream on it ---\n21         InputStream istr = proc.getInputStream();\n22         BufferedReader br = new BufferedReader(new InputStreamReader(istr));\n23 \n24         // --- read output lines from command\n25         String str;\n26         while ((str = br.readLine()) != null) {\n27             list.add(str);\n28         }\n29 \n30         // wait for command to terminate\n31         try {\n32             proc.waitFor();\n33         }\n34         catch (InterruptedException e) {\n35             System.err.println(\"process was interrupted\");\n36         }\n37 \n38         // check its exit value\n39         if (proc.exitValue() != 0) {\n40             System.err.println(\"exit value was non-zero\");\n41         }\n42 \n43         // close stream\n44         br.close();\n45 \n46         // return list of strings to caller\n47         return (String[])list.toArray(new String[0]);\n48     }\n49 \n50     public static void main(String args[]) throws IOException {\n51         try {\n52 \n53             // run a command\n54             String outlist[] = runCommand(\"test\");\n55 \n56             // display its output\n57             for (int i = 0; i < outlist.length; i++)\n58                 System.out.println(outlist[i]);\n59         }\n60         catch (IOException e) {\n61             System.err.println(e);\n62         }\n63     }\n64 }The demo calls a method runCommand to actually run the program.Code section 10.1: Running a command.\n\n\n1 String outlist[] = runCommand(\"test\");This method hooks an input stream to the program's output stream, so that it can read the program's output, and save it into a list of strings.Code section 10.2: Reading the program's output.\n\n\n1 InputStream istr = proc.getInputStream();\n2 BufferedReader br = new BufferedReader(new InputStreamReader(istr));\n3              \n4 String str;\n5 while ((str = br.readLine()) != null) {\n6     list.add(str);\n7 }", "subdata": [], "title": "Invoking C"}, {"url": "https://en.wikibooks.org/wiki/Java_Programming/Byte_Code", "content": "Topics:\n\nPreface\nGetting started\nLanguage fundamentals\nClasses and objects\nAggregate\nExceptions\nConcurrent Programming\nJavadoc & Annotations\nDesigning user interfaces\nAdvanced topicsJava Byte Code is the language to which Java source is compiled and the Java Virtual Machine understands. Unlike compiled languages that have to be specifically compiled for each different type of computers, a Java program only needs to be converted to byte code once, after which it can run on any platform for which a Java Virtual Machine exists.Bytecode is the compiled format for Java programs. Once a Java program has been converted to bytecode, it can be transferred across a network and executed by Java Virtual Machine (JVM). Bytecode files generally have a .class extension. It is not normally necessary for a Java programmer to know byte code, but it can be useful.Contents\n\n\n1 Other Languages\n2 Example\n3 Example 2\n4 The Java bytecodes\n5 References\n6 External Links", "subdata": [{"content": "There are a number of exciting new languages being created that also compile to Java byte code, such as Groovy.GNAT\nThe GNU Ada-Compiler, is capable of compiling Ada into Java-style bytecode.\nftp://cs.nyu.edu/pub/gnatJPython\nCompiles Python to Java-style bytecode.\nhttp://www.jpython.org/Kawa\nCompiles Scheme to Java-style bytecode.\nhttp://www.gnu.org/software/kawa/", "title": "Other Languages[edit]"}, {"content": "Consider the following Java code.outer:\n for (int i = 2; i < 1000; i++) {\n  for (int j = 2; j < i; j++) {\n    if (i % j == 0)\n      continue outer;\n  }\n  System.out.println (i);\n }A Java compiler might translate the Java code above into byte code as follows, assuming the above was put in a method:Code:\n  0:   iconst_2\n  1:   istore_1\n  2:   iload_1\n  3:   sipush  1000\n  6:   if_icmpge       44\n  9:   iconst_2\n  10:  istore_2\n  11:  iload_2\n  12:  iload_1\n  13:  if_icmpge       31\n  16:  iload_1\n  17:  iload_2\n  18:  irem             # remainder\n  19:  ifne    25\n  22:  goto    38\n  25:  iinc    2, 1\n  28:  goto    11\n  31:  getstatic       #84; //Field java/lang/System.out:Ljava/io/PrintStream;\n  34:  iload_1\n  35:  invokevirtual   #85; //Method java/io/PrintStream.println:(I)V\n  38:  iinc    1, 1\n  41:  goto    2\n  44:  return", "title": "Example[edit]"}, {"content": "As an example we can write a simple Foo.java source:public class Foo {\n  public static void main(final String[] args) {\n    System.out.println(\"This is a simple example of decompilation using javap\");\n    a();\n    b();\n  }\n\t\n  public static void a() {\n    System.out.println(\"Now we are calling a function...\");\n  }\n\n  public static void b() {\n    System.out.println(\"...and now we are calling b\");\n  }\n}Compile it and then move Foo.java to another directory or delete it if you wish. What can we do with javap and Foo.class?$javap Fooproduces this result:Compiled from \"Foo.java\"\npublic class Foo extends java.lang.Object {\n    public Foo();\n    public static void main(java.lang.String[]);\n    public static void a();\n    public static void b();\n}As you can see the javac compiler doesn't strip any (public) variable name from the .class file. As a result the names of the functions, their parameters and types of return are exposed. (This is necessary in order for other classes to access them.)Let's do a bit more, try:$javap -c FooCompiled from \"Foo.java\"\npublic class Foo extends java.lang.Object{\npublic Foo();\n  Code:\n   0:   aload_0\n   1:   invokespecial   #1; //Method java/lang/Object.\"<init>\":()V\n   4:   return\n\npublic static void main(java.lang.String[]);\n  Code:\n   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;\n   3:   ldc             #3; //String This is a simple example of decompilation using javap\n   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V\n   8:   invokestatic    #5; //Method a:()V\n   11:  invokestatic    #6; //Method b:()V\n   14:  return\n\npublic static void a();\n  Code:\n   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;\n   3:   ldc             #7; //String Now we are calling a function...\n   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V\n   8:   return\n\npublic static void b();\n  Code:\n   0:   getstatic       #2; //Field java/lang/System.out:Ljava/io/PrintStream;\n   3:   ldc             #8; //String ...and now we are calling b\n   5:   invokevirtual   #4; //Method java/io/PrintStream.println:(Ljava/lang/String;)V\n   8:   return\n\n}", "title": "Example 2[edit]"}, {"content": "See Oracle's Java Virtual Machine Specification[1] for more detailed descriptionsThe manipulation of the operand stack is notated as [before][after], where [before] is the stack before the instruction is executed and [after] is the stack after the instruction is executed. A stack with the element 'b' on the top and element 'a' just after the top element is denoted 'a,b'.Mnemonic\nOpcode\n(in hex)\nOther bytes\nStack\n[before][after]\nDescription\n\n\nA\n\n\naaload\n32\n\narrayref, index  value\nloads onto the stack a reference from an array\n\n\naastore\n53\n\narrayref, index, value \nstores a reference into an array\n\n\naconst_null\n01\n\n null\npushes a null reference onto the stack\n\n\naload\n19\nindex\n objectref\nloads a reference onto the stack from a local variable #index\n\n\naload_0\n2a\n\n objectref\nloads a reference onto the stack from local variable 0\n\n\naload_1\n2b\n\n objectref\nloads a reference onto the stack from local variable 1\n\n\naload_2\n2c\n\n objectref\nloads a reference onto the stack from local variable 2\n\n\naload_3\n2d\n\n objectref\nloads a reference onto the stack from local variable 3\n\n\nanewarray\nbd\nindexbyte1, indexbyte2\ncount  arrayref\ncreates a new array of references of length count and component type identified by the class reference index (indexbyte1 << 8 + indexbyte2) in the constant pool\n\n\nareturn\nb0\n\nobjectref  [empty]\nreturns a reference from a method\n\n\narraylength\nbe\n\narrayref  length\ngets the length of an array\n\n\nastore\n3a\nindex\nobjectref \nstores a reference into a local variable #index\n\n\nastore_0\n4b\n\nobjectref \nstores a reference into local variable 0\n\n\nastore_1\n4c\n\nobjectref \nstores a reference into local variable 1\n\n\nastore_2\n4d\n\nobjectref \nstores a reference into local variable 2\n\n\nastore_3\n4e\n\nobjectref \nstores a reference into local variable 3\n\n\nathrow\nbf\n\nobjectref  [empty], objectref\nthrows an error or exception (notice that the rest of the stack is cleared, leaving only a reference to the Throwable)\n\n\nB\n\n\nbaload\n33\n\narrayref, index  value\nloads a byte or Boolean value from an array\n\n\nbastore\n54\n\narrayref, index, value \nstores a byte or Boolean value into an array\n\n\nbipush\n10\nbyte\n value\npushes a byte onto the stack as an integer value\n\n\nC\n\n\ncaload\n34\n\narrayref, index  value\nloads a char from an array\n\n\ncastore\n55\n\narrayref, index, value \nstores a char into an array\n\n\ncheckcast\nc0\nindexbyte1, indexbyte2\nobjectref  objectref\nchecks whether an objectref is of a certain type, the class reference of which is in the constant pool at index (indexbyte1 << 8 + indexbyte2)\n\n\nD\n\n\nd2f\n90\n\nvalue  result\nconverts a double to a float\n\n\nd2i\n8e\n\nvalue  result\nconverts a double to an int\n\n\nd2l\n8f\n\nvalue  result\nconverts a double to a long\n\n\ndadd\n63\n\nvalue1, value2  result\nadds two doubles\n\n\ndaload\n31\n\narrayref, index  value\nloads a double from an array\n\n\ndastore\n52\n\narrayref, index, value \nstores a double into an array\n\n\ndcmpg\n98\n\nvalue1, value2  result\ncompares two doubles\n\n\ndcmpl\n97\n\nvalue1, value2  result\ncompares two doubles\n\n\ndconst_0\n0e\n\n 0.0\npushes the constant 0.0 onto the stack\n\n\ndconst_1\n0f\n\n 1.0\npushes the constant 1.0 onto the stack\n\n\nddiv\n6f\n\nvalue1, value2  result\ndivides two doubles\n\n\ndload\n18\nindex\n value\nloads a double value from a local variable #index\n\n\ndload_0\n26\n\n value\nloads a double from local variable 0\n\n\ndload_1\n27\n\n value\nloads a double from local variable 1\n\n\ndload_2\n28\n\n value\nloads a double from local variable 2\n\n\ndload_3\n29\n\n value\nloads a double from local variable 3\n\n\ndmul\n6b\n\nvalue1, value2  result\nmultiplies two doubles\n\n\ndneg\n77\n\nvalue  result\nnegates a double\n\n\ndrem\n73\n\nvalue1, value2  result\ngets the remainder from a division between two doubles\n\n\ndreturn\naf\n\nvalue  [empty]\nreturns a double from a method\n\n\ndstore\n39\nindex\nvalue \nstores a double value into a local variable #index\n\n\ndstore_0\n47\n\nvalue \nstores a double into local variable 0\n\n\ndstore_1\n48\n\nvalue \nstores a double into local variable 1\n\n\ndstore_2\n49\n\nvalue \nstores a double into local variable 2\n\n\ndstore_3\n4a\n\nvalue \nstores a double into local variable 3\n\n\ndsub\n67\n\nvalue1, value2  result\nsubtracts a double from another\n\n\ndup\n59\n\nvalue  value, value\nduplicates the value on top of the stack\n\n\ndup_x1\n5a\n\nvalue2, value1  value1, value2, value1\ninserts a copy of the top value into the stack two values from the top\n\n\ndup_x2\n5b\n\nvalue3, value2, value1  value1, value3, value2, value1\ninserts a copy of the top value into the stack two (if value2 is double or long it takes up the entry of value3, too) or three values (if value2 is neither double nor long) from the top\n\n\ndup2\n5c\n\n{value2, value1}  {value2, value1}, {value2, value1}\nduplicate top two stack words (two values, if value1 is not double nor long; a single value, if value1 is double or long)\n\n\ndup2_x1\n5d\n\nvalue3, {value2, value1}  {value2, value1}, value3, {value2, value1}\nduplicate two words and insert beneath third word (see explanation above)\n\n\ndup2_x2\n5e\n\n{value4, value3}, {value2, value1}  {value2, value1}, {value4, value3}, {value2, value1}\nduplicate two words and insert beneath fourth word\n\n\nF\n\n\nf2d\n8d\n\nvalue  result\nconverts a float to a double\n\n\nf2i\n8b\n\nvalue  result\nconverts a float to an int\n\n\nf2l\n8c\n\nvalue  result\nconverts a float to a long\n\n\nfadd\n62\n\nvalue1, value2  result\nadds two floats\n\n\nfaload\n30\n\narrayref, index  value\nloads a float from an array\n\n\nfastore\n51\n\narreyref, index, value \nstores a float in an array\n\n\nfcmpg\n96\n\nvalue1, value2  result\ncompares two floats\n\n\nfcmpl\n95\n\nvalue1, value2  result\ncompares two floats\n\n\nfconst_0\n0b\n\n 0.0f\npushes 0.0f on the stack\n\n\nfconst_1\n0c\n\n 1.0f\npushes 1.0f on the stack\n\n\nfconst_2\n0d\n\n 2.0f\npushes 2.0f on the stack\n\n\nfdiv\n6e\n\nvalue1, value2  result\ndivides two floats\n\n\nfload\n17\nindex\n value\nloads a float value from a local variable #index\n\n\nfload_0\n22\n\n value\nloads a float value from local variable 0\n\n\nfload_1\n23\n\n value\nloads a float value from local variable 1\n\n\nfload_2\n24\n\n value\nloads a float value from local variable 2\n\n\nfload_3\n25\n\n value\nloads a float value from local variable 3\n\n\nfmul\n6a\n\nvalue1, value2  result\nmultiplies two floats\n\n\nfneg\n76\n\nvalue  result\nnegates a float\n\n\nfrem\n72\n\nvalue1, value2  result\ngets the remainder from a division between two floats\n\n\nfreturn\nae\n\nvalue  [empty]\nreturns a float from method\n\n\nfstore\n38\nindex\nvalue \nstores a float value into a local variable #index\n\n\nfstore_0\n43\n\nvalue \nstores a float value into local variable 0\n\n\nfstore_1\n44\n\nvalue \nstores a float value into local variable 1\n\n\nfstore_2\n45\n\nvalue \nstores a float value into local variable 2\n\n\nfstore_3\n46\n\nvalue \nstores a float value into local variable 3\n\n\nfsub\n66\n\nvalue1, value2  result\nsubtracts two floats\n\n\nG\n\n\ngetfield\nb4\nindex1, index2\nobjectref  value\ngets a field value of an object objectref, where the field is identified by field reference in the constant pool index (index1 << 8 + index2)\n\n\ngetstatic\nb2\nindex1, index2\n value\ngets a static field value of a class, where the field is identified by field reference in the constant pool index (index1 << 8 + index2)\n\n\ngoto\na7\nbranchbyte1, branchbyte2\n[no change]\ngoes to another instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\ngoto_w\nc8\nbranchbyte1, branchbyte2, branchbyte3, branchbyte4\n[no change]\ngoes to another instruction at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4)\n\n\nI\n\n\ni2b\n91\n\nvalue  result\nconverts an int into a byte\n\n\ni2c\n92\n\nvalue  result\nconverts an int into a character\n\n\ni2d\n87\n\nvalue  result\nconverts an int into a double\n\n\ni2f\n86\n\nvalue  result\nconverts an int into a float\n\n\ni2l\n85\n\nvalue  result\nconverts an int into a long\n\n\ni2s\n93\n\nvalue  result\nconverts an int into a short\n\n\niadd\n60\n\nvalue1, value2  result\nadds two ints together\n\n\niaload\n2e\n\narrayref, index  value\nloads an int from an array\n\n\niand\n7e\n\nvalue1, value2  result\nperforms a logical and on two integers\n\n\niastore\n4f\n\narrayref, index, value \nstores an int into an array\n\n\niconst_m1\n02\n\n -1\nloads the int value -1 onto the stack\n\n\niconst_0\n03\n\n 0\nloads the int value 0 onto the stack\n\n\niconst_1\n04\n\n 1\nloads the int value 1 onto the stack\n\n\niconst_2\n05\n\n 2\nloads the int value 2 onto the stack\n\n\niconst_3\n06\n\n 3\nloads the int value 3 onto the stack\n\n\niconst_4\n07\n\n 4\nloads the int value 4 onto the stack\n\n\niconst_5\n08\n\n 5\nloads the int value 5 onto the stack\n\n\nidiv\n6c\n\nvalue1, value2  result\ndivides two integers\n\n\nif_acmpeq\na5\nbranchbyte1, branchbyte2\nvalue1, value2 \nif references are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_acmpne\na6\nbranchbyte1, branchbyte2\nvalue1, value2 \nif references are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmpeq\n9f\nbranchbyte1, branchbyte2\nvalue1, value2 \nif ints are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmpne\na0\nbranchbyte1, branchbyte2\nvalue1, value2 \nif ints are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmplt\na1\nbranchbyte1, branchbyte2\nvalue1, value2 \nif value1 is less than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmpge\na2\nbranchbyte1, branchbyte2\nvalue1, value2 \nif value1 is greater than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmpgt\na3\nbranchbyte1, branchbyte2\nvalue1, value2 \nif value1 is greater than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nif_icmple\na4\nbranchbyte1, branchbyte2\nvalue1, value2 \nif value1 is less than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifeq\n99\nbranchbyte1, branchbyte2\nvalue \nif value is 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifne\n9a\nbranchbyte1, branchbyte2\nvalue \nif value is not 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\niflt\n9b\nbranchbyte1, branchbyte2\nvalue \nif value is less than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifge\n9c\nbranchbyte1, branchbyte2\nvalue \nif value is greater than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifgt\n9d\nbranchbyte1, branchbyte2\nvalue \nif value is greater than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifle\n9e\nbranchbyte1, branchbyte2\nvalue \nif value is less than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifnonnull\nc7\nbranchbyte1, branchbyte2\nvalue \nif value is not null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\nifnull\nc6\nbranchbyte1, branchbyte2\nvalue \nif value is null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2)\n\n\niinc\n84\nindex, const\n[No change]\nincrement local variable #index by signed byte const\n\n\niload\n15\nindex\n value\nloads an int value from a variable #index\n\n\niload_0\n1a\n\n value\nloads an int value from variable 0\n\n\niload_1\n1b\n\n value\nloads an int value from variable 1\n\n\niload_2\n1c\n\n value\nloads an int value from variable 2\n\n\niload_3\n1d\n\n value\nloads an int value from variable 3\n\n\nimul\n68\n\nvalue1, value2  result\nmultiply two integers\n\n\nineg\n74\n\nvalue  result\nnegate int\n\n\ninstanceof\nc1\nindexbyte1, indexbyte2\nobjectref  result\ndetermines if an object objectref is of a given type, identified by class reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\ninvokeinterface\nb9\nindexbyte1, indexbyte2, count, 0\nobjectref, [arg1, arg2, ...] \ninvokes an interface method on object objectref, where the interface method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2) and count is the number of arguments to pop from the stack frame including the object on which the method is being called and must always be greater than or equal to 1\n\n\ninvokespecial\nb7\nindexbyte1, indexbyte2\nobjectref, [arg1, arg2, ...] \ninvoke instance method on object objectref requiring special handling (instance initialization method, a private method, or a superclass method), where the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\ninvokestatic\nb8\nindexbyte1, indexbyte2\n[arg1, arg2, ...] \ninvoke a static method, where the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\ninvokevirtual\nb6\nindexbyte1, indexbyte2\nobjectref, [arg1, arg2, ...] \ninvoke virtual method on object objectref, where the method is identified by method reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\nior\n80\n\nvalue1, value2  result\nlogical int or\n\n\nirem\n70\n\nvalue1, value2  result\nlogical int remainder\n\n\nireturn\nac\n\nvalue  [empty]\nreturns an integer from a method\n\n\nishl\n78\n\nvalue1, value2  result\nint shift left\n\n\nishr\n7a\n\nvalue1, value2  result\nint shift right\n\n\nistore\n36\nindex\nvalue \nstore int value into variable #index\n\n\nistore_0\n3b\n\nvalue \nstore int value into variable 0\n\n\nistore_1\n3c\n\nvalue \nstore int value into variable 1\n\n\nistore_2\n3d\n\nvalue \nstore int value into variable 2\n\n\nistore_3\n3e\n\nvalue \nstore int value into variable 3\n\n\nisub\n64\n\nvalue1, value2  result\nint subtract\n\n\niushr\n7c\n\nvalue1, value2  result\nint shift right\n\n\nixor\n82\n\nvalue1, value2  result\nint xor\n\n\nJ\n\n\njsr\na8\nbranchbyte1, branchbyte2\n address\njump to subroutine at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 + branchbyte2) and place the return address on the stack\n\n\njsr_w\nc9\nbranchbyte1, branchbyte2, branchbyte3, branchbyte4\n address\njump to subroutine at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 + branchbyte2 << 16 + branchbyte3 << 8 + branchbyte4) and place the return address on the stack\n\n\nL\n\n\nl2d\n8a\n\nvalue  result\nconverts a long to a double\n\n\nl2f\n89\n\nvalue  result\nconverts a long to a float\n\n\nl2i\n88\n\nvalue  result\nconverts a long to an int\n\n\nladd\n61\n\nvalue1, value2  result\nadd two longs\n\n\nlaload\n2f\n\narrayref, index  value\nload a long from an array\n\n\nland\n7f\n\nvalue1, value2  result\nbitwise and of two longs\n\n\nlastore\n50\n\narrayref, index, value \nstore a long to an array\n\n\nlcmp\n94\n\nvalue1, value2  result\ncompares two longs values\n\n\nlconst_0\n09\n\n 0L\npushes the long 0 onto the stack\n\n\nlconst_1\n0a\n\n 1L\npushes the long 1 onto the stack\n\n\nldc\n12\nindex\n value\npushes a constant #index from a constant pool (String, int, float or class type) onto the stack\n\n\nldc_w\n13\nindexbyte1, indexbyte2\n value\npushes a constant #index from a constant pool (String, int, float or class type) onto the stack (wide index is constructed as indexbyte1 << 8 + indexbyte2)\n\n\nldc2_w\n14\nindexbyte1, indexbyte2\n value\npushes a constant #index from a constant pool (double or long) onto the stack (wide index is constructed as indexbyte1 << 8 + indexbyte2)\n\n\nldiv\n6d\n\nvalue1, value2  result\ndivide two longs\n\n\nlload\n16\nindex\n value\nload a long value from a local variable #index\n\n\nlload_0\n1e\n\n value\nload a long value from a local variable 0\n\n\nlload_1\n1f\n\n value\nload a long value from a local variable 1\n\n\nlload_2\n20\n\n value\nload a long value from a local variable 2\n\n\nlload_3\n21\n\n value\nload a long value from a local variable 3\n\n\nlmul\n69\n\nvalue1, value2  result\nmultiplies two longs\n\n\nlneg\n75\n\nvalue  result\nnegates a long\n\n\nlookupswitch\nab\n<0-3 bytes padding>, defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, npairs1, npairs2, npairs3, npairs4, match-offset pairs...\nkey \na target address is looked up from a table using a key and execution continues from the instruction at that address\n\n\nlor\n81\n\nvalue1, value2  result\nbitwise or of two longs\n\n\nlrem\n71\n\nvalue1, value2  result\nremainder of division of two longs\n\n\nlreturn\nad\n\nvalue  [empty]\nreturns a long value\n\n\nlshl\n79\n\nvalue1, value2  result\nbitwise shift left of a long value1 by value2 positions\n\n\nlshr\n7b\n\nvalue1, value2  result\nbitwise shift right of a long value1 by value2 positions\n\n\nlstore\n37\nindex\nvalue \nstore a long value in a local variable #index\n\n\nlstore_0\n3f\n\nvalue \nstore a long value in a local variable 0\n\n\nlstore_1\n40\n\nvalue \nstore a long value in a local variable 1\n\n\nlstore_2\n41\n\nvalue \nstore a long value in a local variable 2\n\n\nlstore_3\n42\n\nvalue \nstore a long value in a local variable 3\n\n\nlsub\n65\n\nvalue1, value2  result\nsubtract two longs\n\n\nlushr\n7d\n\nvalue1, value2  result\nbitwise shift right of a long value1 by value2 positions, unsigned\n\n\nlxor\n83\n\nvalue1, value2  result\nbitwise exclusive or of two longs\n\n\nM\n\n\nmonitorenter\nc2\n\nobjectref \nenter monitor for object (\"grab the lock\" - start of synchronized() section)\n\n\nmonitorexit\nc3\n\nobjectref \nexit monitor for object (\"release the lock\" - end of synchronized() section)\n\n\nmultianewarray\nc5\nindexbyte1, indexbyte2, dimensions\ncount1, [count2,...]  arrayref\ncreate a new array of dimensions dimensions with elements of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2); the sizes of each dimension is identified by count1, [count2, etc]\n\n\nN\n\n\nnew\nbb\nindexbyte1, indexbyte2\n objectref\ncreates new object of type identified by class reference in constant pool index (indexbyte1 << 8 + indexbyte2)\n\n\nnewarray\nbc\natype\ncount  arrayref\ncreates new array with count elements of primitive type identified by atype\n\n\nnop\n00\n\n[No change]\nperforms no operation\n\n\nP\n\n\npop\n57\n\nvalue \ndiscards the top value on the stack\n\n\npop2\n58\n\n{value2, value1} \ndiscards the top two values on the stack (or one value, if it is a double or long)\n\n\nputfield\nb5\nindexbyte1, indexbyte2\nobjectref, value \nset field to value in an object objectref, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\nputstatic\nb3\nindexbyte1, indexbyte2\nvalue \nset static field to value in a class, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 + indexbyte2)\n\n\nR\n\n\nret\na9\nindex\n[No change]\ncontinue execution from address taken from a local variable #index (the asymmetry with jsr is intentional)\n\n\nreturn\nb1\n\n [empty]\nreturn void from method\n\n\nS\n\n\nsaload\n35\n\narrayref, index  value\nload short from array\n\n\nsastore\n56\n\narrayref, index, value \nstore short to array\n\n\nsipush\n11\nbyte1, byte2\n value\npushes a signed integer (byte1 << 8 + byte2) onto the stack\n\n\nswap\n5f\n\nvalue2, value1  value1, value2\nswaps two top words on the stack (note that value1 and value2 must not be double or long)\n\n\nT\n\n\ntableswitch\naa\n[0-3 bytes padding], defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, lowbyte1, lowbyte2, lowbyte3, lowbyte4, highbyte1, highbyte2, highbyte3, highbyte4, jump offsets...\nindex \ncontinue execution from an address in the table at offset index\n\n\nW\n\n\nwide\nc4\nopcode, indexbyte1, indexbyte2\nor\niinc, indexbyte1, indexbyte2, countbyte1, countbyte2\n[same as for corresponding instructions]\nexecute opcode, where opcode is either iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore, or ret, but assume the index is 16 bit; or execute iinc, where the index is 16 bits and the constant to increment by is a signed 16 bit short\n\n\nUnused\n\n\nbreakpoint\nca\n\n\nreserved for breakpoints in Java debuggers; should not appear in any class file\n\n\nimpdep1\nfe\n\n\nreserved for implementation-dependent operations within debuggers; should not appear in any class file\n\n\nimpdep2\nff\n\n\nreserved for implementation-dependent operations within debuggers; should not appear in any class file\n\n\n(no name)\ncb-fd\n\n\nthese values are currently unassigned for opcodes and are reserved for future use\n\n\nxxxunusedxxx\nba\n\n\nthis opcode is reserved \"for historical reasons\"", "title": "The Java bytecodes[edit]"}, {"content": "Oracle's Java Virtual Machine Specification", "title": "References[edit]"}], "title": "Byte Code"}]